# Chapter 10.03: CLI Framework - User Guide - Overview

## Quick Start Guide

The xlibrary CLI Framework provides a comprehensive foundation for building modern command-line interfaces with rich interactive features, plugin support, and enterprise integration capabilities.

### Installation

```bash
# Install CLI pillar
pip install xlibrary[cli]

# Or install everything
pip install xlibrary[all]
```

### 5-Minute Setup

#### 1. Basic CLI Application

```python
from xlibrary.cli import CLIFramework

# Create basic CLI app
cli = CLIFramework(name="myapp", version="1.0.0")

@cli.command()
def hello(name: str = "World"):
    """Say hello to someone."""
    cli.console.print(f"Hello, {name}!", style="green")

if __name__ == "__main__":
    cli.run()
```

#### 2. Running Commands

```bash
# Basic command
python myapp.py hello

# With arguments
python myapp.py hello --name "Alice"

# Help information
python myapp.py --help
python myapp.py hello --help
```

#### 3. Rich Output and Styling

```python
from xlibrary.cli import CLIFramework

cli = CLIFramework(name="styled-app")

@cli.command()
def status():
    """Display system status with rich formatting."""
    cli.console.print("[bold green]✓[/] System Online")
    cli.console.print("[yellow]![/] 3 warnings detected")
    cli.console.print("[red]✗[/] Database connection failed")

@cli.command()
def progress():
    """Show progress bar example."""
    import time
    with cli.progress() as progress:
        task = progress.add_task("Processing...", total=100)
        for i in range(100):
            time.sleep(0.01)
            progress.update(task, advance=1)
```

## Essential Operations

### Command Definition

#### Simple Commands

```python
@cli.command()
def simple_command():
    """A simple command with no arguments."""
    cli.console.print("Command executed!")

@cli.command()
def command_with_args(file: str, count: int = 1):
    """Command with required and optional arguments."""
    cli.console.print(f"Processing {file} {count} times")
```

#### Commands with Options

```python
@cli.command()
def deploy(
    environment: str,
    dry_run: bool = False,
    verbose: bool = False,
    config: str = "default.yaml"
):
    """Deploy application to specified environment."""
    if dry_run:
        cli.console.print("[yellow]Dry run mode - no changes will be made[/]")

    if verbose:
        cli.console.print(f"Using config: {config}")

    cli.console.print(f"Deploying to {environment}...")
```

### Interactive Workflows

#### User Input and Confirmation

```python
@cli.command()
def interactive_setup():
    """Interactive application setup."""
    # Get user input
    name = cli.prompt("Enter your name")
    email = cli.prompt("Enter your email", default="user@example.com")

    # Password input (hidden)
    password = cli.prompt("Enter password", password=True)

    # Confirmation
    if cli.confirm("Save configuration?"):
        cli.console.print("[green]Configuration saved![/]")
    else:
        cli.console.print("[yellow]Configuration cancelled[/]")
```

#### Selection Menus

```python
@cli.command()
def choose_options():
    """Interactive option selection."""
    # Single choice
    deployment = cli.select(
        "Choose deployment target:",
        choices=["development", "staging", "production"]
    )

    # Multiple choices
    features = cli.select_multiple(
        "Select features to enable:",
        choices=["authentication", "caching", "logging", "monitoring"]
    )

    cli.console.print(f"Selected deployment: {deployment}")
    cli.console.print(f"Selected features: {', '.join(features)}")
```

### Configuration Management

#### YAML Configuration

```python
# config.yaml
app:
  name: "MyApp"
  version: "1.0.0"
database:
  host: "localhost"
  port: 5432
  name: "myapp_db"
```

```python
@cli.command()
def show_config():
    """Display current configuration."""
    config = cli.config.get_all()
    cli.console.print_json(data=config)

@cli.command()
def set_config(key: str, value: str):
    """Set configuration value."""
    cli.config.set(key, value)
    cli.console.print(f"[green]Set {key} = {value}[/]")
```

### File Operations

#### File Processing Commands

```python
@cli.command()
def process_files(pattern: str, output_dir: str = "output"):
    """Process files matching pattern."""
    import glob
    import os

    files = glob.glob(pattern)
    if not files:
        cli.console.print("[red]No files found matching pattern[/]")
        return

    os.makedirs(output_dir, exist_ok=True)

    with cli.progress() as progress:
        task = progress.add_task("Processing files...", total=len(files))

        for file in files:
            # Process file here
            cli.console.print(f"Processing {file}")
            progress.update(task, advance=1)

    cli.console.print(f"[green]Processed {len(files)} files to {output_dir}[/]")
```

## Common Use Cases

### 1. Development Tools

```python
from xlibrary.cli import CLIFramework

dev_cli = CLIFramework(name="dev-tools", version="1.0.0")

@dev_cli.command()
def build(clean: bool = False):
    """Build the project."""
    if clean:
        dev_cli.console.print("Cleaning build directory...")
    dev_cli.console.print("Building project...")

@dev_cli.command()
def test(coverage: bool = False, verbose: bool = False):
    """Run tests."""
    cmd = ["pytest"]
    if coverage:
        cmd.extend(["--cov=src"])
    if verbose:
        cmd.append("-v")

    dev_cli.console.print(f"Running: {' '.join(cmd)}")

@dev_cli.command()
def deploy(environment: str):
    """Deploy to environment."""
    if not dev_cli.confirm(f"Deploy to {environment}?"):
        return

    dev_cli.console.print(f"Deploying to {environment}...")
```

### 2. Data Processing Pipeline

```python
@cli.command()
def process_data(
    input_file: str,
    output_file: str,
    format: str = "json"
):
    """Process data file with specified format."""
    if not os.path.exists(input_file):
        cli.console.print(f"[red]File not found: {input_file}[/]")
        return

    cli.console.print(f"Processing {input_file} -> {output_file}")
    cli.console.print(f"Output format: {format}")

    # Process data here
    with cli.progress() as progress:
        task = progress.add_task("Processing...", total=100)
        # Simulation of processing
        for i in range(100):
            time.sleep(0.01)
            progress.update(task, advance=1)

    cli.console.print("[green]Processing complete![/]")
```

### 3. System Administration

```python
@cli.command()
def system_info():
    """Display system information."""
    import platform
    import psutil

    cli.console.print(f"[bold]System Information[/]")
    cli.console.print(f"OS: {platform.system()} {platform.release()}")
    cli.console.print(f"Python: {platform.python_version()}")
    cli.console.print(f"CPU Usage: {psutil.cpu_percent()}%")
    cli.console.print(f"Memory Usage: {psutil.virtual_memory().percent}%")

@cli.command()
def backup(source: str, destination: str, compress: bool = False):
    """Create backup of source directory."""
    if not os.path.exists(source):
        cli.console.print(f"[red]Source directory not found: {source}[/]")
        return

    cli.console.print(f"Backing up {source} to {destination}")
    if compress:
        cli.console.print("Compression enabled")

    # Backup logic here
    cli.console.print("[green]Backup completed![/]")
```

## Error Handling

### Graceful Error Management

```python
@cli.command()
def safe_operation(file: str):
    """Demonstrate error handling."""
    try:
        with open(file, 'r') as f:
            content = f.read()
            cli.console.print(f"File has {len(content)} characters")
    except FileNotFoundError:
        cli.console.print(f"[red]Error: File '{file}' not found[/]")
        cli.exit(1)
    except PermissionError:
        cli.console.print(f"[red]Error: Permission denied for '{file}'[/]")
        cli.exit(1)
    except Exception as e:
        cli.console.print(f"[red]Unexpected error: {e}[/]")
        cli.exit(1)
```

### Input Validation

```python
@cli.command()
def validate_input(port: int, host: str = "localhost"):
    """Command with input validation."""
    if not (1 <= port <= 65535):
        cli.console.print("[red]Error: Port must be between 1 and 65535[/]")
        cli.exit(1)

    if not host:
        cli.console.print("[red]Error: Host cannot be empty[/]")
        cli.exit(1)

    cli.console.print(f"Connecting to {host}:{port}")
```

## Quick Reference

### Essential Commands

```bash
# Run CLI application
python app.py command [options]

# Get help
python app.py --help
python app.py command --help

# Version information
python app.py --version

# Verbose output
python app.py command --verbose

# Configuration
python app.py config set key value
python app.py config get key
python app.py config list
```

### Common Patterns

```python
# Command with subcommands
@cli.group()
def database():
    """Database operations."""
    pass

@database.command()
def migrate():
    """Run database migrations."""
    pass

@database.command()
def backup():
    """Backup database."""
    pass
```

### Styling and Output

```python
# Console styling
cli.console.print("[bold red]Error message[/]")
cli.console.print("[green]Success message[/]")
cli.console.print("[yellow]Warning message[/]")

# Tables
from rich.table import Table
table = Table()
table.add_column("Name")
table.add_column("Status")
table.add_row("Service 1", "[green]Running[/]")
table.add_row("Service 2", "[red]Stopped[/]")
cli.console.print(table)

# Progress bars
with cli.progress() as progress:
    task = progress.add_task("Working...", total=100)
    # Update progress
    progress.update(task, advance=10)
```

## Troubleshooting

### Common Issues

**Command Not Found**
```bash
# Ensure proper command registration
@cli.command()  # Don't forget the decorator
def my_command():
    pass
```

**Import Errors**
```bash
# Install CLI pillar
pip install xlibrary[cli]

# Check installation
python -c "from xlibrary.cli import CLIFramework; print('CLI Framework available')"
```

**Configuration Issues**
```python
# Verify config file location
cli.console.print(f"Config file: {cli.config.config_file}")

# Reset configuration
cli.config.reset()
```

## Next Steps

- **Advanced Features**: See [User Guide - Detailed](./10.04%20Chapter%2010%20-%20CLI%20Framework%20-%20User%20Guide%20-%20Detailed.md)
- **Plugin Development**: Learn about creating CLI plugins
- **Enterprise Integration**: Explore SSO, audit logging, and compliance features
- **Performance Optimization**: Advanced caching and async operations
- **Testing**: CLI application testing strategies

The CLI Framework provides the foundation for building professional command-line tools with rich interactive features and enterprise-grade capabilities.