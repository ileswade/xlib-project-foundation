# Chapter 6: Communication Manager - User Guide Overview

> **ðŸš€ QUICK START GUIDE**
> Get up and running with the Communication Manager in 5 minutes. Essential patterns for email automation, multi-channel messaging, and unified communication workflows.

## 5-Minute Quick Start

### Installation
```bash
# Install communication pillar
pip install xlibrary[communication]
```

### Basic Usage

```python
from xlibrary.communication import CommManager, EmailQuery

# Initialize communication manager
comm = CommManager()

# Setup Gmail
gmail = comm.gmail(credentials_path="gmail_credentials.json")

# Send simple email
message = gmail.compose()
message.to("recipient@example.com")
message.subject("Hello from xlibrary")
message.body("This is a test message from xlibrary Communication Manager.")
result = message.send()

# Search emails
messages = gmail.search(
    EmailQuery()
    .from_sender("boss@company.com")
    .is_unread()
    .limit(10)
)

# Process results
for msg in messages:
    print(f"From: {msg.sender}, Subject: {msg.subject}")
    if msg.has_attachments():
        msg.download_attachments("downloads/")
```

---

## Essential Patterns

### 1. Email Operations (Gmail Focus)

Complete Gmail integration with advanced features:

```python
from xlibrary.communication import CommManager, EmailQuery, SortOrder

comm = CommManager()
gmail = comm.gmail(credentials_path="credentials.json")

# Advanced email search
query = (EmailQuery()
    .from_sender("client@company.com")
    .subject_contains("invoice")
    .has_attachment()
    .date_range("2024-01-01", "2024-12-31")
    .is_unread()
    .sort_by("date", SortOrder.DESC)
    .limit(50)
)

messages = gmail.search(query)

# Smart email processing
for message in messages:
    print(f"ðŸ“§ {message.subject}")
    print(f"   From: {message.sender}")
    print(f"   Date: {message.date}")
    print(f"   Attachments: {len(message.attachments)}")

    # Automated actions
    if "urgent" in message.subject.lower():
        message.mark_as_important()
        message.add_label("Urgent")

    # Download PDF attachments
    for attachment in message.attachments:
        if attachment.filename.endswith('.pdf'):
            attachment.save(f"pdfs/{attachment.filename}")

    message.mark_as_read()
```

### 2. Email Composition and Sending

Professional email creation with templates and formatting:

```python
from xlibrary.communication import CommManager

comm = CommManager()
gmail = comm.gmail(credentials_path="credentials.json")

# Simple email
simple_message = gmail.compose()
simple_message.to("colleague@company.com")
simple_message.subject("Meeting Reminder")
simple_message.body("Don't forget about our 3 PM meeting today.")
simple_message.send()

# Rich HTML email with attachments
rich_message = gmail.compose()
rich_message.to(["team@company.com", "manager@company.com"])
rich_message.cc("hr@company.com")
rich_message.subject("Q4 Report - Please Review")

html_body = """
<html>
<body>
    <h2>Q4 Performance Report</h2>
    <p>Dear Team,</p>
    <p>Please find attached the Q4 performance report for review.</p>
    <ul>
        <li><strong>Revenue:</strong> $2.5M (+15% YoY)</li>
        <li><strong>New Clients:</strong> 45</li>
        <li><strong>Customer Satisfaction:</strong> 4.8/5</li>
    </ul>
    <p>Best regards,<br>Management Team</p>
</body>
</html>
"""

rich_message.html_body(html_body)
rich_message.attach("q4_report.pdf")
rich_message.attach("charts.xlsx")

# Schedule for later
from datetime import datetime, timedelta
send_time = datetime.now() + timedelta(hours=2)
rich_message.schedule(send_time)

result = rich_message.send()
print(f"Email scheduled: {result.scheduled_for}")
```

### 3. Multi-Channel Communication

Unified messaging across email, SMS, and other channels:

```python
from xlibrary.communication import CommManager

# Configure multiple providers
comm = CommManager()

# Email
gmail = comm.gmail(credentials_path="gmail_creds.json")

# SMS (requires Twilio account)
sms = comm.sms(
    provider="twilio",
    account_sid="your_twilio_sid",
    auth_token="your_twilio_token",
    from_number="+1234567890"
)

# Send same message via multiple channels
def send_urgent_notification(message, contacts):
    """Send urgent notification via multiple channels."""
    results = {}

    for contact in contacts:
        # Email notification
        email_msg = gmail.compose()
        email_msg.to(contact.email)
        email_msg.subject("ðŸš¨ URGENT: " + message.subject)
        email_msg.body(message.body)
        results[f"{contact.name}_email"] = email_msg.send()

        # SMS notification (if phone available)
        if contact.phone:
            sms_text = f"URGENT: {message.subject}\n{message.body[:140]}..."
            results[f"{contact.name}_sms"] = sms.send(contact.phone, sms_text)

    return results

# Usage
from xlibrary.communication import Contact, CommunicationMessage

contacts = [
    Contact("John Doe", "john@company.com", "+1234567890"),
    Contact("Jane Smith", "jane@company.com", "+0987654321")
]

urgent_msg = CommunicationMessage(
    subject="Server Outage Detected",
    body="Production server is experiencing issues. Please check immediately."
)

notification_results = send_urgent_notification(urgent_msg, contacts)
```

### 4. Automated Email Processing

Set up intelligent email automation:

```python
from xlibrary.communication import CommManager, EmailQuery

class EmailAutomationManager:
    def __init__(self):
        self.comm = CommManager()
        self.gmail = self.comm.gmail(credentials_path="credentials.json")
        self.processing_rules = []

    def add_processing_rule(self, condition, action):
        """Add automated processing rule."""
        self.processing_rules.append({
            'condition': condition,
            'action': action
        })

    def process_inbox(self):
        """Process inbox according to rules."""
        # Get unread messages
        unread_messages = self.gmail.search(
            EmailQuery().is_unread().limit(100)
        )

        for message in unread_messages:
            for rule in self.processing_rules:
                if self._message_matches_condition(message, rule['condition']):
                    self._execute_action(message, rule['action'])

    def _message_matches_condition(self, message, condition):
        """Check if message matches rule condition."""
        if condition['type'] == 'sender':
            return message.sender == condition['value']
        elif condition['type'] == 'subject_contains':
            return condition['value'].lower() in message.subject.lower()
        elif condition['type'] == 'has_attachment':
            return message.has_attachments()
        # Add more conditions as needed
        return False

    def _execute_action(self, message, action):
        """Execute action on message."""
        if action['type'] == 'forward':
            forward_msg = self.gmail.compose()
            forward_msg.to(action['to'])
            forward_msg.subject(f"FWD: {message.subject}")
            forward_msg.body(f"Forwarded message:\n\n{message.body}")
            forward_msg.send()

        elif action['type'] == 'add_label':
            message.add_label(action['label'])

        elif action['type'] == 'mark_important':
            message.mark_as_important()

        elif action['type'] == 'download_attachments':
            message.download_attachments(action['directory'])

        message.mark_as_read()

# Setup automation
automation = EmailAutomationManager()

# Rule 1: Forward invoices to accounting
automation.add_processing_rule(
    condition={'type': 'sender', 'value': 'billing@vendor.com'},
    action={'type': 'forward', 'to': 'accounting@company.com'}
)

# Rule 2: Label urgent messages
automation.add_processing_rule(
    condition={'type': 'subject_contains', 'value': 'urgent'},
    action={'type': 'add_label', 'label': 'Priority'}
)

# Rule 3: Download attachments from HR
automation.add_processing_rule(
    condition={'type': 'sender', 'value': 'hr@company.com'},
    action={'type': 'download_attachments', 'directory': 'hr_documents/'}
)

# Process inbox
automation.process_inbox()
```

### 5. Contact and Address Book Management

Unified contact management across communication channels:

```python
from xlibrary.communication import CommManager, Contact

class ContactManager:
    def __init__(self):
        self.comm = CommManager()
        self.contacts = {}
        self.groups = {}

    def add_contact(self, name, email, phone=None, **kwargs):
        """Add new contact."""
        contact = Contact(
            name=name,
            email=email,
            phone=phone,
            **kwargs
        )
        self.contacts[email] = contact
        return contact

    def create_group(self, group_name, contact_emails):
        """Create contact group."""
        group_contacts = [self.contacts[email] for email in contact_emails if email in self.contacts]
        self.groups[group_name] = group_contacts
        return group_contacts

    def send_to_group(self, group_name, subject, message, channel='email'):
        """Send message to entire group."""
        if group_name not in self.groups:
            raise ValueError(f"Group {group_name} not found")

        results = {}
        group_contacts = self.groups[group_name]

        if channel == 'email':
            gmail = self.comm.gmail(credentials_path="credentials.json")

            # Send to all contacts in group
            recipients = [contact.email for contact in group_contacts]

            group_message = gmail.compose()
            group_message.to(recipients)
            group_message.subject(subject)
            group_message.body(message)

            result = group_message.send()
            results['email'] = result

        elif channel == 'sms':
            sms = self.comm.sms(provider="twilio", **sms_config)

            for contact in group_contacts:
                if contact.phone:
                    result = sms.send(contact.phone, f"{subject}\n{message}")
                    results[f"sms_{contact.name}"] = result

        return results

# Usage
contact_mgr = ContactManager()

# Add contacts
contact_mgr.add_contact("John Doe", "john@company.com", "+1234567890")
contact_mgr.add_contact("Jane Smith", "jane@company.com", "+0987654321")
contact_mgr.add_contact("Bob Johnson", "bob@company.com")

# Create groups
contact_mgr.create_group("team_leads", [
    "john@company.com",
    "jane@company.com"
])

contact_mgr.create_group("all_staff", [
    "john@company.com",
    "jane@company.com",
    "bob@company.com"
])

# Send to group
results = contact_mgr.send_to_group(
    "team_leads",
    "Weekly Team Meeting",
    "Don't forget about our weekly team meeting tomorrow at 10 AM.",
    channel='email'
)
```

---

## Common Use Cases

### 1. Customer Support Email Management

```python
from xlibrary.communication import CommManager, EmailQuery
from datetime import datetime, timedelta

class CustomerSupportManager:
    def __init__(self):
        self.comm = CommManager()
        self.gmail = self.comm.gmail(credentials_path="support_gmail.json")

    def process_support_tickets(self):
        """Process incoming support tickets."""

        # Get new support emails
        support_emails = self.gmail.search(
            EmailQuery()
            .to_recipient("support@company.com")
            .is_unread()
            .sort_by("date", SortOrder.ASC)
            .limit(50)
        )

        for email in support_emails:
            # Classify urgency
            urgency = self._classify_urgency(email)

            # Auto-assign based on content
            assignee = self._auto_assign_ticket(email)

            # Create ticket and respond
            ticket_id = self._create_ticket(email, urgency, assignee)
            self._send_acknowledgment(email, ticket_id)

            # Label and organize
            email.add_label(f"Priority-{urgency}")
            email.add_label(f"Assigned-{assignee}")
            email.mark_as_read()

    def _classify_urgency(self, email):
        """Classify email urgency automatically."""
        urgent_keywords = ['urgent', 'emergency', 'critical', 'down', 'broken']
        high_keywords = ['important', 'asap', 'soon', 'problem', 'issue']

        content = f"{email.subject} {email.body}".lower()

        if any(word in content for word in urgent_keywords):
            return 'urgent'
        elif any(word in content for word in high_keywords):
            return 'high'
        else:
            return 'normal'

    def _auto_assign_ticket(self, email):
        """Auto-assign ticket based on content."""
        content = f"{email.subject} {email.body}".lower()

        if any(word in content for word in ['billing', 'payment', 'invoice']):
            return 'billing_team'
        elif any(word in content for word in ['technical', 'bug', 'error', 'api']):
            return 'tech_team'
        elif any(word in content for word in ['account', 'login', 'password']):
            return 'account_team'
        else:
            return 'general_support'

    def _send_acknowledgment(self, original_email, ticket_id):
        """Send auto-acknowledgment to customer."""
        response = self.gmail.compose()
        response.to(original_email.sender)
        response.subject(f"Re: {original_email.subject} [Ticket #{ticket_id}]")

        response.body(f"""
Dear {original_email.sender_name},

Thank you for contacting our support team. We have received your request and created ticket #{ticket_id}.

We will respond to your inquiry within 24 hours. For urgent matters, please call our support hotline at 1-800-SUPPORT.

Best regards,
Customer Support Team
""")

        response.send()

# Usage
support_mgr = CustomerSupportManager()
support_mgr.process_support_tickets()
```

### 2. Email Newsletter Campaign

```python
from xlibrary.communication import CommManager, Contact
import csv
from datetime import datetime

class NewsletterCampaign:
    def __init__(self):
        self.comm = CommManager()
        self.gmail = self.comm.gmail(credentials_path="marketing_gmail.json")
        self.subscribers = []

    def load_subscribers_from_csv(self, csv_file):
        """Load subscriber list from CSV file."""
        with open(csv_file, 'r') as file:
            reader = csv.DictReader(file)
            for row in reader:
                contact = Contact(
                    name=row.get('name', ''),
                    email=row['email'],
                    subscription_date=row.get('subscription_date'),
                    preferences=row.get('preferences', '').split(',')
                )
                self.subscribers.append(contact)

    def create_newsletter(self, template_file, subject, **template_vars):
        """Create newsletter from template."""
        with open(template_file, 'r') as file:
            template_content = file.read()

        # Replace template variables
        for key, value in template_vars.items():
            template_content = template_content.replace(f"{{{key}}}", str(value))

        return template_content

    def send_campaign(self, subject, content, batch_size=50):
        """Send newsletter campaign in batches."""
        total_subscribers = len(self.subscribers)
        sent_count = 0
        failed_count = 0

        # Send in batches to respect rate limits
        for i in range(0, total_subscribers, batch_size):
            batch = self.subscribers[i:i + batch_size]

            print(f"Sending batch {i//batch_size + 1}: {len(batch)} emails")

            for subscriber in batch:
                try:
                    # Personalize content
                    personalized_content = content.replace(
                        '{subscriber_name}',
                        subscriber.name or 'Valued Subscriber'
                    )

                    # Create email
                    newsletter = self.gmail.compose()
                    newsletter.to(subscriber.email)
                    newsletter.subject(subject)
                    newsletter.html_body(personalized_content)

                    # Add unsubscribe link
                    unsubscribe_link = f"https://company.com/unsubscribe?email={subscriber.email}"
                    newsletter.add_header("List-Unsubscribe", f"<{unsubscribe_link}>")

                    result = newsletter.send()

                    if result.success:
                        sent_count += 1
                    else:
                        failed_count += 1
                        print(f"Failed to send to {subscriber.email}: {result.error}")

                except Exception as e:
                    failed_count += 1
                    print(f"Error sending to {subscriber.email}: {e}")

            # Pause between batches
            time.sleep(10)

        print(f"Campaign complete: {sent_count} sent, {failed_count} failed")
        return {'sent': sent_count, 'failed': failed_count}

# Usage
campaign = NewsletterCampaign()
campaign.load_subscribers_from_csv('subscribers.csv')

newsletter_content = campaign.create_newsletter(
    'newsletter_template.html',
    'Monthly Company Update - March 2024',
    month='March',
    year='2024',
    company_news='We launched our new product line!',
    upcoming_events='Join us at Tech Conference 2024'
)

results = campaign.send_campaign(
    'Monthly Company Update - March 2024',
    newsletter_content,
    batch_size=25
)
```

### 3. Lead Nurturing Email Sequence

```python
from xlibrary.communication import CommManager
from datetime import datetime, timedelta
import threading
import time

class LeadNurturingSequence:
    def __init__(self):
        self.comm = CommManager()
        self.gmail = self.comm.gmail(credentials_path="sales_gmail.json")
        self.sequences = {}
        self.active_leads = {}

    def create_sequence(self, sequence_name, email_templates, delays):
        """Create a nurturing email sequence."""
        self.sequences[sequence_name] = {
            'templates': email_templates,
            'delays': delays  # Days between emails
        }

    def add_lead_to_sequence(self, lead_email, lead_name, sequence_name):
        """Add lead to nurturing sequence."""
        if sequence_name not in self.sequences:
            raise ValueError(f"Sequence {sequence_name} not found")

        lead_data = {
            'email': lead_email,
            'name': lead_name,
            'sequence': sequence_name,
            'current_step': 0,
            'started_at': datetime.now(),
            'next_send': datetime.now()
        }

        self.active_leads[lead_email] = lead_data

        # Start processing this lead
        threading.Thread(
            target=self._process_lead_sequence,
            args=(lead_email,),
            daemon=True
        ).start()

    def _process_lead_sequence(self, lead_email):
        """Process individual lead through sequence."""
        lead = self.active_leads[lead_email]
        sequence = self.sequences[lead['sequence']]

        while lead['current_step'] < len(sequence['templates']):
            # Wait until it's time to send next email
            while datetime.now() < lead['next_send']:
                time.sleep(3600)  # Check every hour

            # Send current email in sequence
            template = sequence['templates'][lead['current_step']]

            try:
                self._send_sequence_email(lead, template)
                lead['current_step'] += 1

                # Schedule next email
                if lead['current_step'] < len(sequence['templates']):
                    days_delay = sequence['delays'][lead['current_step'] - 1]
                    lead['next_send'] = datetime.now() + timedelta(days=days_delay)

            except Exception as e:
                print(f"Failed to send sequence email to {lead_email}: {e}")
                break

        # Mark sequence complete
        lead['completed_at'] = datetime.now()
        print(f"Lead {lead_email} completed nurturing sequence")

    def _send_sequence_email(self, lead, template):
        """Send individual email in sequence."""
        # Load template content
        with open(f"templates/{template}", 'r') as file:
            content = file.read()

        # Personalize content
        content = content.replace('{lead_name}', lead['name'])
        content = content.replace('{lead_email}', lead['email'])

        # Extract subject from template (first line)
        lines = content.split('\n')
        subject = lines[0].replace('Subject: ', '')
        body = '\n'.join(lines[2:])  # Skip subject and empty line

        # Send email
        email = self.gmail.compose()
        email.to(lead['email'])
        email.subject(subject)
        email.html_body(body)

        result = email.send()

        if not result.success:
            raise Exception(result.error)

# Usage
nurturing = LeadNurturingSequence()

# Create welcome sequence
nurturing.create_sequence(
    'welcome_series',
    templates=['welcome_day0.html', 'tips_day3.html', 'case_study_day7.html', 'demo_day14.html'],
    delays=[3, 4, 7]  # Days between emails
)

# Add leads to sequence
new_leads = [
    ('john.prospect@company.com', 'John Prospect'),
    ('jane.lead@startup.com', 'Jane Lead'),
    ('bob.potential@corp.com', 'Bob Potential')
]

for email, name in new_leads:
    nurturing.add_lead_to_sequence(email, name, 'welcome_series')

print("Lead nurturing sequences started!")
```

### 4. Email Analytics and Reporting

```python
from xlibrary.communication import CommManager, EmailQuery
from datetime import datetime, timedelta
from collections import defaultdict
import json

class EmailAnalytics:
    def __init__(self):
        self.comm = CommManager()
        self.gmail = self.comm.gmail(credentials_path="analytics_gmail.json")

    def generate_email_report(self, days_back=30):
        """Generate comprehensive email analytics report."""

        # Date range for analysis
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days_back)

        print(f"ðŸ“Š Generating email report for {start_date.date()} to {end_date.date()}")

        # Get all emails in date range
        all_emails = self.gmail.search(
            EmailQuery()
            .date_range(start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d'))
            .limit(1000)
        )

        # Analyze emails
        report = {
            'period': {'start': start_date.isoformat(), 'end': end_date.isoformat()},
            'summary': self._analyze_summary(all_emails),
            'senders': self._analyze_senders(all_emails),
            'recipients': self._analyze_recipients(all_emails),
            'subjects': self._analyze_subjects(all_emails),
            'attachments': self._analyze_attachments(all_emails),
            'time_patterns': self._analyze_time_patterns(all_emails)
        }

        return report

    def _analyze_summary(self, emails):
        """Generate summary statistics."""
        total_emails = len(emails)
        sent_emails = [e for e in emails if e.is_sent_by_me()]
        received_emails = [e for e in emails if not e.is_sent_by_me()]

        with_attachments = [e for e in emails if e.has_attachments()]
        unread_emails = [e for e in emails if e.is_unread()]

        return {
            'total_emails': total_emails,
            'sent': len(sent_emails),
            'received': len(received_emails),
            'with_attachments': len(with_attachments),
            'unread': len(unread_emails),
            'read_rate': (total_emails - len(unread_emails)) / total_emails if total_emails > 0 else 0
        }

    def _analyze_senders(self, emails):
        """Analyze email senders."""
        sender_stats = defaultdict(int)

        for email in emails:
            if not email.is_sent_by_me():
                sender_stats[email.sender] += 1

        # Top 10 senders
        top_senders = sorted(sender_stats.items(), key=lambda x: x[1], reverse=True)[:10]

        return {
            'unique_senders': len(sender_stats),
            'top_senders': [{'email': sender, 'count': count} for sender, count in top_senders]
        }

    def _analyze_time_patterns(self, emails):
        """Analyze email time patterns."""
        hourly_counts = defaultdict(int)
        daily_counts = defaultdict(int)

        for email in emails:
            hour = email.date.hour
            day = email.date.strftime('%A')

            hourly_counts[hour] += 1
            daily_counts[day] += 1

        return {
            'busiest_hour': max(hourly_counts.items(), key=lambda x: x[1])[0],
            'busiest_day': max(daily_counts.items(), key=lambda x: x[1])[0],
            'hourly_distribution': dict(hourly_counts),
            'daily_distribution': dict(daily_counts)
        }

    def save_report(self, report, filename):
        """Save report to JSON file."""
        with open(filename, 'w') as file:
            json.dump(report, file, indent=2, default=str)

# Usage
analytics = EmailAnalytics()

# Generate 30-day report
report = analytics.generate_email_report(days_back=30)

print(f"ðŸ“ˆ Email Report Summary:")
print(f"   Total Emails: {report['summary']['total_emails']}")
print(f"   Sent: {report['summary']['sent']}")
print(f"   Received: {report['summary']['received']}")
print(f"   Read Rate: {report['summary']['read_rate']:.1%}")
print(f"   Busiest Day: {report['time_patterns']['busiest_day']}")
print(f"   Busiest Hour: {report['time_patterns']['busiest_hour']}:00")

# Save detailed report
analytics.save_report(report, f"email_report_{datetime.now().strftime('%Y%m%d')}.json")
```

---

## Error Handling Patterns

### Safe Communication Operations

```python
from xlibrary.communication import (
    CommManager, CommunicationError, AuthenticationError,
    MessageError, ProviderError
)

def safe_email_operations(gmail_credentials_path):
    """Robust email operations with comprehensive error handling."""

    try:
        comm = CommManager()
        gmail = comm.gmail(credentials_path=gmail_credentials_path)

        # Test connection
        profile = gmail.get_profile()
        print(f"âœ… Connected as: {profile['email']}")

        # Safe message sending
        message = gmail.compose()
        message.to("test@example.com")
        message.subject("Test Message")
        message.body("This is a test message.")

        result = message.send()

        if result.success:
            print(f"âœ… Message sent: {result.message_id}")
        else:
            print(f"âŒ Send failed: {result.error}")

    except AuthenticationError:
        print("âŒ Authentication failed. Check credentials file.")
        print("   Make sure Gmail API is enabled and credentials are valid.")

    except MessageError as e:
        print(f"âŒ Message error: {e}")
        if "quota" in str(e).lower():
            print("   Suggestion: Check API quota limits")

    except ProviderError as e:
        print(f"âŒ Provider error: {e}")
        if e.error_code == "RATE_LIMITED":
            print(f"   Retry after: {e.retry_after} seconds")

    except CommunicationError as e:
        print(f"âŒ Communication error: {e}")

    except Exception as e:
        print(f"âŒ Unexpected error: {e}")

# Usage with error handling
safe_email_operations("gmail_credentials.json")
```

---

## Best Practices

### 1. **Authentication Management**
```python
# Store credentials securely
comm = CommManager()
gmail = comm.gmail(
    credentials_path="~/.xlibrary/gmail_creds.json",  # Secure location
    scopes=['https://www.googleapis.com/auth/gmail.modify']
)
```

### 2. **Rate Limiting**
```python
# Respect provider rate limits
comm = CommManager(
    rate_limit_strategy="adaptive",
    max_requests_per_minute=100
)
```

### 3. **Batch Operations**
```python
# Use batch operations for efficiency
emails = gmail.search(EmailQuery().limit(50))
with gmail.batch_mode():
    for email in emails:
        email.mark_as_read()  # Batched operation
```

### 4. **Error Recovery**
```python
# Implement retry logic
@retry(max_attempts=3, delay=5)
def send_important_email(message):
    return message.send()
```

---

## Troubleshooting

### Common Issues

**Gmail authentication fails:**
```python
# Check credentials file exists and is valid
import os
if not os.path.exists("gmail_credentials.json"):
    print("Credentials file missing. Download from Google Cloud Console.")
```

**Rate limit exceeded:**
```python
# Use exponential backoff
import time
try:
    result = gmail.send_message(message)
except ProviderError as e:
    if e.error_code == "RATE_LIMITED":
        time.sleep(e.retry_after)
        result = gmail.send_message(message)  # Retry
```

**Attachment issues:**
```python
# Check attachment size and type
for attachment in message.attachments:
    if attachment.size > 25 * 1024 * 1024:  # 25MB Gmail limit
        print(f"Attachment too large: {attachment.filename}")
```

---

## Next Steps

Ready for advanced communication workflows?

- **[Detailed User Guide](06.04%20Chapter%206%20-%20Communication%20Manager%20-%20User%20Guide%20-%20Detailed.md)** - Comprehensive patterns and enterprise workflows
- **[Chapter 7: Encryption Manager](07.01%20Chapter%207%20-%20Encryption%20Manager%20-%20Design%20-%20Overview.md)** - Security and encryption systems
- **[Design Documentation](06.01%20Chapter%206%20-%20Communication%20Manager%20-%20Design%20-%20Overview.md)** - Architectural details

**You're now ready to build powerful communication systems with xlibrary!** ðŸ“§