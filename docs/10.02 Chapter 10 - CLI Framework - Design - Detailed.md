# Chapter 10: CLI Framework - Design - Detailed

> **üñ•Ô∏è ADVANCED CLI ARCHITECTURE**
> Deep dive into the sophisticated argument parsing algorithms, plugin architecture, interactive systems, and enterprise-grade features that power xlibrary's CLI Framework.

## Table of Contents

- [Core Architecture](#core-architecture)
- [Advanced Argument Parsing](#advanced-argument-parsing)
- [Interactive Systems](#interactive-systems)
- [Plugin Architecture](#plugin-architecture)
- [Rich Output Formatting](#rich-output-formatting)
- [Configuration Management](#configuration-management)
- [Enterprise Integration](#enterprise-integration)
- [Performance Optimization](#performance-optimization)

---

## Core Architecture

### System Overview

The CLI Framework implements a sophisticated multi-layered architecture designed for enterprise-grade command-line applications:

```python
from typing import Dict, List, Optional, Any, Callable, Union
from dataclasses import dataclass, field
from enum import Enum
import asyncio
import threading
import sys
import os
from abc import ABC, abstractmethod
import inspect
import functools

class CLIFrameworkCore:
    """Core architecture for the CLI Framework system."""

    def __init__(self, app_name: str, version: str, config: Optional[Dict[str, Any]] = None):
        self.app_name = app_name
        self.version = version
        self.config = config or {}

        # Core components
        self._argument_parser = None
        self._command_registry = None
        self._interaction_manager = None
        self._plugin_manager = None
        self._output_formatter = None
        self._config_manager = None

        # Runtime state
        self.context = CLIContext()
        self.execution_stack = []
        self.middleware = []

        # Initialize subsystems
        self._initialize_subsystems()

    def _initialize_subsystems(self) -> None:
        """Initialize all CLI subsystem components."""

        # Argument parsing subsystem
        self._argument_parser = ArgumentParserEngine(
            app_name=self.app_name,
            auto_completion=self.config.get("auto_completion", True),
            type_validation=self.config.get("type_validation", True)
        )

        # Command registry subsystem
        self._command_registry = CommandRegistryEngine(
            namespace_support=self.config.get("namespace_support", True),
            dynamic_loading=self.config.get("dynamic_loading", False)
        )

        # Interactive management subsystem
        self._interaction_manager = InteractionManagerEngine(
            rich_prompts=self.config.get("rich_prompts", True),
            color_support=self.config.get("color_support", True)
        )

        # Plugin management subsystem
        if self.config.get("plugin_system", False):
            self._plugin_manager = PluginManagerEngine(
                plugin_directories=self.config.get("plugin_directories", []),
                hot_reload=self.config.get("plugin_hot_reload", False)
            )

        # Output formatting subsystem
        self._output_formatter = OutputFormatterEngine(
            color_support=self.config.get("color_support", True),
            rich_formatting=self.config.get("rich_formatting", True),
            unicode_support=self.config.get("unicode_support", True)
        )

        # Configuration management subsystem
        self._config_manager = ConfigManagerEngine(
            app_name=self.app_name,
            config_file=self.config.get("config_file"),
            profile_support=self.config.get("profile_support", True)
        )

@dataclass
class CLIContext:
    """Runtime context for CLI execution."""

    command_path: List[str] = field(default_factory=list)
    arguments: Dict[str, Any] = field(default_factory=dict)
    options: Dict[str, Any] = field(default_factory=dict)
    environment: Dict[str, str] = field(default_factory=dict)
    user_data: Dict[str, Any] = field(default_factory=dict)
    execution_id: str = ""
    debug_mode: bool = False

@dataclass
class CommandDefinition:
    """Comprehensive command definition."""

    name: str
    function: Callable
    description: str = ""
    arguments: List['ArgumentDefinition'] = field(default_factory=list)
    options: List['OptionDefinition'] = field(default_factory=list)
    subcommands: Dict[str, 'CommandDefinition'] = field(default_factory=dict)
    middleware: List[Callable] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    requires_auth: bool = False
    requires_config: bool = False
    hidden: bool = False

@dataclass
class ArgumentDefinition:
    """Command argument definition."""

    name: str
    type: Any = str
    required: bool = True
    nargs: Union[int, str] = 1
    choices: Optional[List[Any]] = None
    validator: Optional[Callable] = None
    help: str = ""
    metavar: Optional[str] = None

@dataclass
class OptionDefinition:
    """Command option definition."""

    names: List[str]
    type: Any = str
    required: bool = False
    default: Any = None
    help: str = ""
    is_flag: bool = False
    is_multiple: bool = False
    envvar: Optional[str] = None
    validator: Optional[Callable] = None
    completion_function: Optional[Callable] = None

class CLIMiddleware(ABC):
    """Base class for CLI middleware."""

    @abstractmethod
    def before_command(self, context: CLIContext) -> CLIContext:
        """Execute before command."""
        pass

    @abstractmethod
    def after_command(self, context: CLIContext, result: Any) -> Any:
        """Execute after command."""
        pass

    @abstractmethod
    def on_error(self, context: CLIContext, error: Exception) -> None:
        """Handle command errors."""
        pass
```

---

## Advanced Argument Parsing

### Sophisticated Parsing Engine

The argument parser implements advanced algorithms for complex argument handling:

```python
import re
import shlex
from typing import Pattern, Match
from collections import OrderedDict

class ArgumentParserEngine:
    """Advanced argument parsing with intelligent type conversion and validation."""

    def __init__(self, app_name: str, auto_completion: bool = True, type_validation: bool = True):
        self.app_name = app_name
        self.auto_completion = auto_completion
        self.type_validation = type_validation

        # Parsing components
        self.type_registry = TypeRegistry()
        self.validator_registry = ValidatorRegistry()
        self.completion_engine = CompletionEngine() if auto_completion else None

        # Parsing state
        self.registered_commands = {}
        self.global_options = []
        self.parsing_context = None

    def parse_arguments(self, args: List[str], command_def: CommandDefinition) -> ParseResult:
        """Parse command-line arguments with advanced validation."""

        parse_result = ParseResult(
            command=command_def.name,
            success=False
        )

        try:
            # Initialize parsing context
            self.parsing_context = ParsingContext(
                args=args,
                command_def=command_def,
                position=0
            )

            # Parse global options first
            self._parse_global_options(self.parsing_context)

            # Parse command-specific arguments and options
            self._parse_command_arguments(self.parsing_context)
            self._parse_command_options(self.parsing_context)

            # Validate required arguments
            self._validate_required_arguments(self.parsing_context)

            # Validate argument types
            if self.type_validation:
                self._validate_argument_types(self.parsing_context)

            # Build final result
            parse_result.success = True
            parse_result.arguments = self.parsing_context.parsed_arguments
            parse_result.options = self.parsing_context.parsed_options
            parse_result.remaining_args = self.parsing_context.remaining_args

        except ArgumentParsingError as e:
            parse_result.error = e
            parse_result.suggestions = self._generate_suggestions(e, command_def)

        return parse_result

    def _parse_command_arguments(self, context: ParsingContext):
        """Parse positional arguments for command."""

        for arg_def in context.command_def.arguments:
            if context.position >= len(context.args):
                if arg_def.required:
                    raise ArgumentParsingError(f"Missing required argument: {arg_def.name}")
                break

            # Parse argument based on nargs
            if isinstance(arg_def.nargs, int):
                if arg_def.nargs == 1:
                    value = self._parse_single_argument(context.args[context.position], arg_def)
                    context.parsed_arguments[arg_def.name] = value
                    context.position += 1
                else:
                    # Multiple fixed arguments
                    values = []
                    for _ in range(arg_def.nargs):
                        if context.position >= len(context.args):
                            if arg_def.required:
                                raise ArgumentParsingError(f"Insufficient arguments for {arg_def.name}")
                            break

                        value = self._parse_single_argument(context.args[context.position], arg_def)
                        values.append(value)
                        context.position += 1

                    context.parsed_arguments[arg_def.name] = values

            elif arg_def.nargs == '*':
                # Zero or more arguments
                values = []
                while context.position < len(context.args) and not self._is_option(context.args[context.position]):
                    value = self._parse_single_argument(context.args[context.position], arg_def)
                    values.append(value)
                    context.position += 1

                context.parsed_arguments[arg_def.name] = values

            elif arg_def.nargs == '+':
                # One or more arguments
                values = []
                if context.position >= len(context.args):
                    raise ArgumentParsingError(f"At least one argument required for {arg_def.name}")

                while context.position < len(context.args) and not self._is_option(context.args[context.position]):
                    value = self._parse_single_argument(context.args[context.position], arg_def)
                    values.append(value)
                    context.position += 1

                context.parsed_arguments[arg_def.name] = values

            elif arg_def.nargs == '?':
                # Optional argument
                if context.position < len(context.args) and not self._is_option(context.args[context.position]):
                    value = self._parse_single_argument(context.args[context.position], arg_def)
                    context.parsed_arguments[arg_def.name] = value
                    context.position += 1
                else:
                    context.parsed_arguments[arg_def.name] = None

    def _parse_command_options(self, context: ParsingContext):
        """Parse options for command."""

        # Build option lookup map
        option_map = {}
        for option_def in context.command_def.options:
            for name in option_def.names:
                option_map[name] = option_def

        # Parse remaining arguments as options
        while context.position < len(context.args):
            arg = context.args[context.position]

            if not self._is_option(arg):
                # Not an option, add to remaining args
                context.remaining_args.append(arg)
                context.position += 1
                continue

            # Parse option
            option_name, option_value = self._split_option(arg)

            if option_name not in option_map:
                raise ArgumentParsingError(f"Unknown option: {option_name}")

            option_def = option_map[option_name]

            if option_def.is_flag:
                # Flag option
                context.parsed_options[option_def.names[0]] = True
                context.position += 1
            else:
                # Value option
                if option_value is not None:
                    # Value provided with = syntax
                    parsed_value = self._parse_option_value(option_value, option_def)
                else:
                    # Value in next argument
                    context.position += 1
                    if context.position >= len(context.args):
                        raise ArgumentParsingError(f"Missing value for option: {option_name}")

                    parsed_value = self._parse_option_value(context.args[context.position], option_def)

                # Handle multiple values
                if option_def.is_multiple:
                    if option_def.names[0] not in context.parsed_options:
                        context.parsed_options[option_def.names[0]] = []
                    context.parsed_options[option_def.names[0]].append(parsed_value)
                else:
                    context.parsed_options[option_def.names[0]] = parsed_value

                context.position += 1

    def _parse_single_argument(self, value: str, arg_def: ArgumentDefinition) -> Any:
        """Parse single argument with type conversion and validation."""

        # Type conversion
        if arg_def.type != str:
            try:
                if hasattr(arg_def.type, 'convert'):
                    # Custom type with convert method
                    converted_value = arg_def.type.convert(value)
                elif callable(arg_def.type):
                    # Built-in type or callable
                    converted_value = arg_def.type(value)
                else:
                    converted_value = value
            except (ValueError, TypeError) as e:
                raise ArgumentParsingError(f"Invalid type for argument {arg_def.name}: {str(e)}")
        else:
            converted_value = value

        # Choice validation
        if arg_def.choices and converted_value not in arg_def.choices:
            raise ArgumentParsingError(
                f"Invalid choice for {arg_def.name}: {converted_value}. "
                f"Valid choices: {', '.join(map(str, arg_def.choices))}"
            )

        # Custom validation
        if arg_def.validator:
            try:
                if not arg_def.validator(converted_value):
                    raise ArgumentParsingError(f"Validation failed for argument {arg_def.name}")
            except Exception as e:
                raise ArgumentParsingError(f"Validation error for {arg_def.name}: {str(e)}")

        return converted_value

    def _parse_option_value(self, value: str, option_def: OptionDefinition) -> Any:
        """Parse option value with type conversion."""

        # Type conversion similar to arguments
        if option_def.type != str:
            try:
                if hasattr(option_def.type, 'convert'):
                    converted_value = option_def.type.convert(value)
                elif callable(option_def.type):
                    converted_value = option_def.type(value)
                else:
                    converted_value = value
            except (ValueError, TypeError) as e:
                raise ArgumentParsingError(f"Invalid type for option {option_def.names[0]}: {str(e)}")
        else:
            converted_value = value

        # Custom validation
        if option_def.validator:
            try:
                if not option_def.validator(converted_value):
                    raise ArgumentParsingError(f"Validation failed for option {option_def.names[0]}")
            except Exception as e:
                raise ArgumentParsingError(f"Validation error for {option_def.names[0]}: {str(e)}")

        return converted_value

    def _is_option(self, arg: str) -> bool:
        """Check if argument is an option."""
        return arg.startswith('-') and len(arg) > 1 and not arg.lstrip('-').isdigit()

    def _split_option(self, arg: str) -> tuple:
        """Split option into name and value."""
        if '=' in arg:
            name, value = arg.split('=', 1)
            return name, value
        else:
            return arg, None

    def _generate_suggestions(self, error: 'ArgumentParsingError', command_def: CommandDefinition) -> List[str]:
        """Generate helpful suggestions for parsing errors."""

        suggestions = []

        if "Unknown option" in str(error):
            # Suggest similar options
            unknown_option = str(error).split(': ')[1]
            similar_options = self._find_similar_options(unknown_option, command_def)
            if similar_options:
                suggestions.append(f"Did you mean: {', '.join(similar_options)}")

        elif "Missing required argument" in str(error):
            # Show command usage
            suggestions.append(f"Usage: {self._generate_usage_string(command_def)}")

        elif "Invalid choice" in str(error):
            # Already included in error message
            pass

        return suggestions

    def _find_similar_options(self, unknown_option: str, command_def: CommandDefinition) -> List[str]:
        """Find similar options using string distance."""

        available_options = []
        for option_def in command_def.options:
            available_options.extend(option_def.names)

        # Simple similarity check (could use Levenshtein distance)
        similar = []
        for option in available_options:
            if self._string_similarity(unknown_option, option) > 0.6:
                similar.append(option)

        return similar[:3]  # Return top 3 suggestions

    def _string_similarity(self, s1: str, s2: str) -> float:
        """Calculate string similarity (simplified)."""
        if not s1 or not s2:
            return 0.0

        # Simple character-based similarity
        common_chars = len(set(s1) & set(s2))
        total_chars = len(set(s1) | set(s2))

        return common_chars / total_chars if total_chars > 0 else 0.0

class TypeRegistry:
    """Registry for custom argument types."""

    def __init__(self):
        self.types = {}
        self._register_builtin_types()

    def _register_builtin_types(self):
        """Register built-in CLI types."""

        # File type
        class FileType:
            def __init__(self, mode='r'):
                self.mode = mode

            def convert(self, value):
                try:
                    return open(value, self.mode)
                except IOError as e:
                    raise ValueError(f"Cannot open file '{value}': {e}")

        self.register_type('file', FileType)

        # Path type
        class PathType:
            def __init__(self, exists=False, dir_okay=True, file_okay=True):
                self.exists = exists
                self.dir_okay = dir_okay
                self.file_okay = file_okay

            def convert(self, value):
                from pathlib import Path
                path = Path(value)

                if self.exists and not path.exists():
                    raise ValueError(f"Path '{value}' does not exist")

                if path.exists():
                    if path.is_file() and not self.file_okay:
                        raise ValueError(f"Path '{value}' is a file but files not allowed")
                    if path.is_dir() and not self.dir_okay:
                        raise ValueError(f"Path '{value}' is a directory but directories not allowed")

                return path

        self.register_type('path', PathType)

        # Choice type
        class ChoiceType:
            def __init__(self, choices, case_sensitive=True):
                self.choices = choices
                self.case_sensitive = case_sensitive

            def convert(self, value):
                if self.case_sensitive:
                    if value not in self.choices:
                        raise ValueError(f"Invalid choice: {value}")
                    return value
                else:
                    for choice in self.choices:
                        if value.lower() == choice.lower():
                            return choice
                    raise ValueError(f"Invalid choice: {value}")

        self.register_type('choice', ChoiceType)

        # Integer range type
        class IntRangeType:
            def __init__(self, min_val=None, max_val=None):
                self.min_val = min_val
                self.max_val = max_val

            def convert(self, value):
                try:
                    int_val = int(value)
                except ValueError:
                    raise ValueError(f"'{value}' is not a valid integer")

                if self.min_val is not None and int_val < self.min_val:
                    raise ValueError(f"Value {int_val} is less than minimum {self.min_val}")

                if self.max_val is not None and int_val > self.max_val:
                    raise ValueError(f"Value {int_val} is greater than maximum {self.max_val}")

                return int_val

        self.register_type('int_range', IntRangeType)

    def register_type(self, name: str, type_class: type):
        """Register custom type."""
        self.types[name] = type_class

    def get_type(self, name: str, **kwargs):
        """Get type instance."""
        if name in self.types:
            return self.types[name](**kwargs)
        raise ValueError(f"Unknown type: {name}")

@dataclass
class ParsingContext:
    """Context for argument parsing process."""

    args: List[str]
    command_def: CommandDefinition
    position: int = 0
    parsed_arguments: Dict[str, Any] = field(default_factory=dict)
    parsed_options: Dict[str, Any] = field(default_factory=dict)
    remaining_args: List[str] = field(default_factory=list)

@dataclass
class ParseResult:
    """Result of argument parsing."""

    command: str
    success: bool
    arguments: Dict[str, Any] = field(default_factory=dict)
    options: Dict[str, Any] = field(default_factory=dict)
    remaining_args: List[str] = field(default_factory=list)
    error: Optional['ArgumentParsingError'] = None
    suggestions: List[str] = field(default_factory=list)

class ArgumentParsingError(Exception):
    """Exception raised during argument parsing."""

    def __init__(self, message: str, argument: str = None, suggestion: str = None):
        super().__init__(message)
        self.message = message
        self.argument = argument
        self.suggestion = suggestion
```

---

## Interactive Systems

### Advanced Prompt Management

Sophisticated interactive prompt system with validation and rich formatting:

```python
import sys
import termios
import tty
from typing import Any, List, Dict, Callable, Optional, Union
import re
from enum import Enum

class InteractionManagerEngine:
    """Advanced interactive prompt and workflow management."""

    def __init__(self, rich_prompts: bool = True, color_support: bool = True):
        self.rich_prompts = rich_prompts
        self.color_support = color_support

        # Interactive components
        self.prompt_engine = PromptEngine(rich_prompts, color_support)
        self.menu_engine = MenuEngine(color_support)
        self.form_engine = FormEngine(rich_prompts, color_support)
        self.wizard_engine = WizardEngine(self)

    def create_prompt(self, prompt_config: 'PromptConfig') -> 'InteractivePrompt':
        """Create interactive prompt with advanced features."""

        return InteractivePrompt(
            config=prompt_config,
            engine=self.prompt_engine
        )

    def create_menu(self, menu_config: 'MenuConfig') -> 'InteractiveMenu':
        """Create interactive menu with navigation."""

        return InteractiveMenu(
            config=menu_config,
            engine=self.menu_engine
        )

    def create_form(self, form_config: 'FormConfig') -> 'InteractiveForm':
        """Create interactive form with validation."""

        return InteractiveForm(
            config=form_config,
            engine=self.form_engine
        )

    def create_wizard(self, wizard_config: 'WizardConfig') -> 'InteractiveWizard':
        """Create multi-step interactive wizard."""

        return InteractiveWizard(
            config=wizard_config,
            engine=self.wizard_engine
        )

class PromptEngine:
    """Advanced prompt engine with type validation and completion."""

    def __init__(self, rich_prompts: bool, color_support: bool):
        self.rich_prompts = rich_prompts
        self.color_support = color_support
        self.input_validators = {}
        self.completion_providers = {}

    def prompt(self, prompt_config: 'PromptConfig') -> Any:
        """Execute interactive prompt with validation."""

        prompt_text = self._format_prompt_text(prompt_config)

        while True:
            try:
                # Get raw input
                if prompt_config.hide_input:
                    raw_value = self._get_hidden_input(prompt_text)
                else:
                    raw_value = self._get_input_with_completion(prompt_text, prompt_config)

                # Handle empty input
                if not raw_value and prompt_config.default is not None:
                    raw_value = str(prompt_config.default)

                # Type conversion
                if prompt_config.type and prompt_config.type != str:
                    if hasattr(prompt_config.type, 'convert'):
                        converted_value = prompt_config.type.convert(raw_value)
                    else:
                        converted_value = prompt_config.type(raw_value)
                else:
                    converted_value = raw_value

                # Validation
                if prompt_config.validator:
                    if not prompt_config.validator(converted_value):
                        self._show_validation_error("Invalid input. Please try again.")
                        continue

                # Additional validation checks
                if prompt_config.required and not converted_value:
                    self._show_validation_error("This field is required.")
                    continue

                return converted_value

            except (ValueError, TypeError) as e:
                self._show_validation_error(f"Invalid input: {str(e)}")
                continue
            except KeyboardInterrupt:
                raise CLIInterruptError("User interrupted input")

    def _format_prompt_text(self, config: 'PromptConfig') -> str:
        """Format prompt text with colors and styling."""

        prompt_parts = []

        if config.prefix:
            prompt_parts.append(config.prefix)

        prompt_parts.append(config.text)

        if config.choices:
            choices_text = f" [{'/'.join(map(str, config.choices))}]"
            prompt_parts.append(choices_text)

        if config.default is not None:
            default_text = f" (default: {config.default})"
            if self.color_support:
                default_text = self._colorize(default_text, 'dim')
            prompt_parts.append(default_text)

        prompt_text = ''.join(prompt_parts)

        if not prompt_text.endswith((' ', ':')):
            prompt_text += ': '

        return prompt_text

    def _get_input_with_completion(self, prompt_text: str, config: 'PromptConfig') -> str:
        """Get input with auto-completion support."""

        if config.completion_function and self._supports_completion():
            return self._get_input_with_readline_completion(prompt_text, config)
        else:
            return input(prompt_text)

    def _get_input_with_readline_completion(self, prompt_text: str, config: 'PromptConfig') -> str:
        """Get input with readline-based completion."""

        try:
            import readline

            # Setup completion
            original_completer = readline.get_completer()
            readline.set_completer(
                lambda text, state: self._completion_generator(text, state, config.completion_function)
            )
            readline.parse_and_bind("tab: complete")

            try:
                return input(prompt_text)
            finally:
                readline.set_completer(original_completer)

        except ImportError:
            # Readline not available, fallback to regular input
            return input(prompt_text)

    def _completion_generator(self, text: str, state: int, completion_func: Callable) -> Optional[str]:
        """Generate completions for readline."""

        if state == 0:
            # First call - generate completions
            self._completion_matches = completion_func(text)

        if state < len(self._completion_matches):
            return self._completion_matches[state]
        else:
            return None

    def _get_hidden_input(self, prompt_text: str) -> str:
        """Get hidden input (for passwords)."""

        try:
            import getpass
            return getpass.getpass(prompt_text)
        except:
            # Fallback for environments without getpass
            return input(prompt_text)

    def _show_validation_error(self, message: str):
        """Show validation error message."""

        if self.color_support:
            colored_message = self._colorize(f"Error: {message}", 'red')
        else:
            colored_message = f"Error: {message}"

        print(colored_message, file=sys.stderr)

    def _colorize(self, text: str, color: str) -> str:
        """Apply color to text."""

        color_codes = {
            'red': '\033[31m',
            'green': '\033[32m',
            'yellow': '\033[33m',
            'blue': '\033[34m',
            'magenta': '\033[35m',
            'cyan': '\033[36m',
            'white': '\033[37m',
            'dim': '\033[2m',
            'bold': '\033[1m',
            'reset': '\033[0m'
        }

        if color in color_codes:
            return f"{color_codes[color]}{text}{color_codes['reset']}"
        return text

    def _supports_completion(self) -> bool:
        """Check if completion is supported."""

        try:
            import readline
            return True
        except ImportError:
            return False

class MenuEngine:
    """Interactive menu system with keyboard navigation."""

    def __init__(self, color_support: bool):
        self.color_support = color_support

    def show_menu(self, menu_config: 'MenuConfig') -> Any:
        """Display and handle interactive menu."""

        if menu_config.style == MenuStyle.SIMPLE:
            return self._show_simple_menu(menu_config)
        elif menu_config.style == MenuStyle.NUMBERED:
            return self._show_numbered_menu(menu_config)
        elif menu_config.style == MenuStyle.CHECKBOX:
            return self._show_checkbox_menu(menu_config)
        elif menu_config.style == MenuStyle.NAVIGATION:
            return self._show_navigation_menu(menu_config)
        else:
            return self._show_simple_menu(menu_config)

    def _show_simple_menu(self, config: 'MenuConfig') -> Any:
        """Show simple choice menu."""

        if config.title:
            print(self._format_title(config.title))

        for i, choice in enumerate(config.choices, 1):
            choice_text = choice[1] if isinstance(choice, tuple) else str(choice)
            print(f"{i}. {choice_text}")

        while True:
            try:
                choice_input = input("\nSelect option: ")
                choice_index = int(choice_input) - 1

                if 0 <= choice_index < len(config.choices):
                    choice = config.choices[choice_index]
                    return choice[0] if isinstance(choice, tuple) else choice
                else:
                    print("Invalid choice. Please try again.")

            except ValueError:
                print("Please enter a number.")
            except KeyboardInterrupt:
                raise CLIInterruptError("Menu selection cancelled")

    def _show_checkbox_menu(self, config: 'MenuConfig') -> List[Any]:
        """Show checkbox-style multi-select menu."""

        selected = set()

        if config.title:
            print(self._format_title(config.title))

        while True:
            # Clear screen (simplified)
            print("\033[H\033[J", end='')

            if config.title:
                print(self._format_title(config.title))

            for i, choice in enumerate(config.choices, 1):
                choice_text = choice[1] if isinstance(choice, tuple) else str(choice)
                choice_value = choice[0] if isinstance(choice, tuple) else choice

                checkbox = "‚òë" if choice_value in selected else "‚òê"
                print(f"{i}. {checkbox} {choice_text}")

            print("\nPress number to toggle, Enter to finish, Ctrl+C to cancel")

            try:
                choice_input = input("Choice: ")

                if not choice_input:  # Enter pressed
                    break

                choice_index = int(choice_input) - 1

                if 0 <= choice_index < len(config.choices):
                    choice = config.choices[choice_index]
                    choice_value = choice[0] if isinstance(choice, tuple) else choice

                    if choice_value in selected:
                        selected.remove(choice_value)
                    else:
                        selected.add(choice_value)
                else:
                    print("Invalid choice.")
                    input("Press Enter to continue...")

            except ValueError:
                print("Please enter a number.")
                input("Press Enter to continue...")
            except KeyboardInterrupt:
                raise CLIInterruptError("Menu selection cancelled")

        return list(selected)

    def _show_navigation_menu(self, config: 'MenuConfig') -> Any:
        """Show menu with keyboard navigation (arrow keys)."""

        current_index = 0

        # Check if we can use advanced terminal features
        if not self._supports_navigation():
            return self._show_simple_menu(config)

        try:
            # Put terminal in cbreak mode
            old_settings = termios.tcgetattr(sys.stdin)
            tty.cbreak(sys.stdin.fileno())

            while True:
                # Clear screen and show menu
                print("\033[H\033[J", end='')

                if config.title:
                    print(self._format_title(config.title))

                for i, choice in enumerate(config.choices):
                    choice_text = choice[1] if isinstance(choice, tuple) else str(choice)

                    if i == current_index:
                        # Highlight current choice
                        if self.color_support:
                            print(f"  ‚Üí {self._colorize(choice_text, 'cyan')}")
                        else:
                            print(f"  ‚Üí {choice_text}")
                    else:
                        print(f"    {choice_text}")

                print("\nUse arrow keys to navigate, Enter to select, Ctrl+C to cancel")

                # Get key input
                key = sys.stdin.read(1)

                if key == '\x1b':  # Escape sequence
                    key += sys.stdin.read(2)

                    if key == '\x1b[A':  # Up arrow
                        current_index = (current_index - 1) % len(config.choices)
                    elif key == '\x1b[B':  # Down arrow
                        current_index = (current_index + 1) % len(config.choices)

                elif key == '\r' or key == '\n':  # Enter
                    choice = config.choices[current_index]
                    return choice[0] if isinstance(choice, tuple) else choice

                elif key == '\x03':  # Ctrl+C
                    raise CLIInterruptError("Menu selection cancelled")

        finally:
            # Restore terminal settings
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)

    def _supports_navigation(self) -> bool:
        """Check if terminal supports keyboard navigation."""
        return sys.stdin.isatty() and hasattr(termios, 'tcgetattr')

    def _format_title(self, title: str) -> str:
        """Format menu title."""
        if self.color_support:
            return self._colorize(f"\n{title}\n{'-' * len(title)}", 'bold')
        else:
            return f"\n{title}\n{'-' * len(title)}"

    def _colorize(self, text: str, color: str) -> str:
        """Apply color to text (same as PromptEngine)."""
        # Implementation same as in PromptEngine
        pass

class MenuStyle(Enum):
    SIMPLE = "simple"
    NUMBERED = "numbered"
    CHECKBOX = "checkbox"
    NAVIGATION = "navigation"

@dataclass
class PromptConfig:
    """Configuration for interactive prompts."""

    text: str
    type: Any = str
    default: Any = None
    required: bool = False
    hide_input: bool = False
    choices: Optional[List[Any]] = None
    validator: Optional[Callable] = None
    completion_function: Optional[Callable] = None
    prefix: str = ""
    suffix: str = ""

@dataclass
class MenuConfig:
    """Configuration for interactive menus."""

    choices: List[Union[str, tuple]]
    title: Optional[str] = None
    style: MenuStyle = MenuStyle.SIMPLE
    allow_multiple: bool = False
    show_indices: bool = True

@dataclass
class FormConfig:
    """Configuration for interactive forms."""

    fields: List['FormField']
    title: Optional[str] = None
    submit_text: str = "Submit"
    cancel_text: str = "Cancel"

@dataclass
class FormField:
    """Individual form field configuration."""

    name: str
    label: str
    type: Any = str
    default: Any = None
    required: bool = False
    validator: Optional[Callable] = None
    help_text: Optional[str] = None

@dataclass
class WizardConfig:
    """Configuration for multi-step wizards."""

    steps: List['WizardStep']
    title: str
    allow_back: bool = True
    show_progress: bool = True

@dataclass
class WizardStep:
    """Individual wizard step."""

    name: str
    title: str
    form: FormConfig
    condition: Optional[Callable] = None  # Skip step if condition returns False

class InteractivePrompt:
    """High-level interactive prompt interface."""

    def __init__(self, config: PromptConfig, engine: PromptEngine):
        self.config = config
        self.engine = engine

    def execute(self) -> Any:
        """Execute the prompt."""
        return self.engine.prompt(self.config)

class InteractiveMenu:
    """High-level interactive menu interface."""

    def __init__(self, config: MenuConfig, engine: MenuEngine):
        self.config = config
        self.engine = engine

    def execute(self) -> Any:
        """Execute the menu."""
        return self.engine.show_menu(self.config)

class InteractiveForm:
    """High-level interactive form interface."""

    def __init__(self, config: FormConfig, engine: FormEngine):
        self.config = config
        self.engine = engine

    def execute(self) -> Dict[str, Any]:
        """Execute the form."""
        return self.engine.show_form(self.config)

class FormEngine:
    """Form handling engine."""

    def __init__(self, rich_prompts: bool, color_support: bool):
        self.prompt_engine = PromptEngine(rich_prompts, color_support)
        self.color_support = color_support

    def show_form(self, config: FormConfig) -> Dict[str, Any]:
        """Display and handle interactive form."""

        if config.title:
            print(self._format_title(config.title))

        form_data = {}

        for field in config.fields:
            prompt_config = PromptConfig(
                text=field.label,
                type=field.type,
                default=field.default,
                required=field.required,
                validator=field.validator
            )

            if field.help_text:
                if self.color_support:
                    help_text = self._colorize(f"  ({field.help_text})", 'dim')
                else:
                    help_text = f"  ({field.help_text})"
                print(help_text)

            try:
                value = self.prompt_engine.prompt(prompt_config)
                form_data[field.name] = value
            except CLIInterruptError:
                raise

        return form_data

    def _format_title(self, title: str) -> str:
        """Format form title."""
        if self.color_support:
            return self._colorize(f"\n=== {title} ===\n", 'bold')
        else:
            return f"\n=== {title} ===\n"

    def _colorize(self, text: str, color: str) -> str:
        """Apply color to text."""
        # Same implementation as other engines
        pass

class CLIInterruptError(Exception):
    """Exception raised when user interrupts CLI interaction."""
    pass
```

---

## Plugin Architecture

### Dynamic Plugin Loading System

Advanced plugin system with dependency management and hot-reloading:

```python
import importlib
import importlib.util
import inspect
import sys
from pathlib import Path
from typing import Dict, List, Optional, Type, Any, Set
import threading
import time
import hashlib
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class PluginManagerEngine:
    """Advanced plugin management with hot-reloading and dependency resolution."""

    def __init__(self, plugin_directories: List[str] = None, hot_reload: bool = False):
        self.plugin_directories = [Path(d) for d in (plugin_directories or [])]
        self.hot_reload = hot_reload

        # Plugin management state
        self.loaded_plugins = {}
        self.plugin_registry = PluginRegistry()
        self.dependency_resolver = PluginDependencyResolver()
        self.plugin_interfaces = {}

        # Hot reload support
        self.file_watcher = None
        self.plugin_checksums = {}

        if hot_reload:
            self._setup_hot_reload()

    def register_interface(self, interface_name: str, base_class: Type):
        """Register plugin interface."""
        self.plugin_interfaces[interface_name] = base_class

    def discover_plugins(self) -> Dict[str, 'PluginInfo']:
        """Discover available plugins in configured directories."""

        discovered = {}

        for plugin_dir in self.plugin_directories:
            if not plugin_dir.exists():
                continue

            # Look for Python files
            for plugin_file in plugin_dir.rglob("*.py"):
                if plugin_file.name.startswith("_"):
                    continue  # Skip private files

                plugin_info = self._analyze_plugin_file(plugin_file)
                if plugin_info:
                    discovered[plugin_info.name] = plugin_info

            # Look for plugin packages
            for plugin_package in plugin_dir.iterdir():
                if plugin_package.is_dir() and (plugin_package / "__init__.py").exists():
                    plugin_info = self._analyze_plugin_package(plugin_package)
                    if plugin_info:
                        discovered[plugin_info.name] = plugin_info

        return discovered

    def load_plugin(self, plugin_name: str, plugin_path: Optional[str] = None) -> Optional['PluginInstance']:
        """Load plugin by name or path."""

        # Check if already loaded
        if plugin_name in self.loaded_plugins:
            return self.loaded_plugins[plugin_name]

        # Find plugin
        if plugin_path:
            plugin_info = self._create_plugin_info_from_path(plugin_name, plugin_path)
        else:
            discovered = self.discover_plugins()
            if plugin_name not in discovered:
                raise PluginNotFoundError(f"Plugin not found: {plugin_name}")
            plugin_info = discovered[plugin_name]

        try:
            # Load plugin dependencies first
            self._load_plugin_dependencies(plugin_info)

            # Load the plugin module
            plugin_module = self._load_plugin_module(plugin_info)

            # Create plugin instance
            plugin_instance = self._create_plugin_instance(plugin_info, plugin_module)

            # Initialize plugin
            plugin_instance.initialize()

            # Store loaded plugin
            self.loaded_plugins[plugin_name] = plugin_instance

            # Track checksums for hot reload
            if self.hot_reload:
                self.plugin_checksums[plugin_name] = self._calculate_plugin_checksum(plugin_info)

            return plugin_instance

        except Exception as e:
            raise PluginLoadError(f"Failed to load plugin {plugin_name}: {str(e)}")

    def unload_plugin(self, plugin_name: str):
        """Unload plugin and cleanup resources."""

        if plugin_name not in self.loaded_plugins:
            raise PluginNotFoundError(f"Plugin not loaded: {plugin_name}")

        plugin_instance = self.loaded_plugins[plugin_name]

        try:
            # Cleanup plugin
            plugin_instance.cleanup()

            # Remove from loaded plugins
            del self.loaded_plugins[plugin_name]

            # Remove checksum
            if plugin_name in self.plugin_checksums:
                del self.plugin_checksums[plugin_name]

        except Exception as e:
            raise PluginUnloadError(f"Failed to unload plugin {plugin_name}: {str(e)}")

    def reload_plugin(self, plugin_name: str):
        """Reload plugin (unload and load again)."""

        if plugin_name in self.loaded_plugins:
            # Store plugin info before unloading
            plugin_info = self.loaded_plugins[plugin_name].plugin_info

            # Unload
            self.unload_plugin(plugin_name)

            # Load again
            self.load_plugin(plugin_name, str(plugin_info.path))

    def get_plugins_by_interface(self, interface_name: str) -> List['PluginInstance']:
        """Get all loaded plugins implementing specific interface."""

        if interface_name not in self.plugin_interfaces:
            raise ValueError(f"Unknown interface: {interface_name}")

        base_class = self.plugin_interfaces[interface_name]
        matching_plugins = []

        for plugin_instance in self.loaded_plugins.values():
            if isinstance(plugin_instance.plugin_object, base_class):
                matching_plugins.append(plugin_instance)

        return matching_plugins

    def _analyze_plugin_file(self, plugin_file: Path) -> Optional['PluginInfo']:
        """Analyze Python file to extract plugin information."""

        try:
            # Read file content
            with open(plugin_file, 'r', encoding='utf-8') as f:
                content = f.read()

            # Parse AST to extract plugin metadata
            import ast
            tree = ast.parse(content)

            plugin_classes = []
            plugin_metadata = {}

            for node in ast.walk(tree):
                # Look for plugin classes
                if isinstance(node, ast.ClassDef):
                    for base in node.bases:
                        if isinstance(base, ast.Name) and base.id.endswith('Plugin'):
                            plugin_classes.append(node.name)

                # Look for plugin metadata
                elif isinstance(node, ast.Assign):
                    for target in node.targets:
                        if isinstance(target, ast.Name) and target.id.startswith('__plugin_'):
                            # Extract metadata
                            metadata_key = target.id[10:]  # Remove '__plugin_' prefix
                            if isinstance(node.value, ast.Constant):
                                plugin_metadata[metadata_key] = node.value.value
                            elif isinstance(node.value, (ast.Str, ast.Num)):
                                plugin_metadata[metadata_key] = node.value.s if hasattr(node.value, 's') else node.value.n

            if plugin_classes:
                return PluginInfo(
                    name=plugin_metadata.get('name', plugin_file.stem),
                    version=plugin_metadata.get('version', '1.0.0'),
                    description=plugin_metadata.get('description', ''),
                    author=plugin_metadata.get('author', ''),
                    dependencies=plugin_metadata.get('dependencies', []),
                    plugin_classes=plugin_classes,
                    path=plugin_file,
                    type=PluginType.FILE
                )

        except Exception as e:
            # Ignore files that can't be parsed
            pass

        return None

    def _analyze_plugin_package(self, plugin_package: Path) -> Optional['PluginInfo']:
        """Analyze plugin package to extract information."""

        init_file = plugin_package / "__init__.py"
        if not init_file.exists():
            return None

        # Analyze __init__.py for plugin info
        plugin_info = self._analyze_plugin_file(init_file)
        if plugin_info:
            plugin_info.path = plugin_package
            plugin_info.type = PluginType.PACKAGE

        return plugin_info

    def _load_plugin_dependencies(self, plugin_info: 'PluginInfo'):
        """Load plugin dependencies."""

        for dependency in plugin_info.dependencies:
            if dependency not in self.loaded_plugins:
                # Try to load dependency
                discovered = self.discover_plugins()
                if dependency in discovered:
                    self.load_plugin(dependency)
                else:
                    raise PluginDependencyError(f"Plugin dependency not found: {dependency}")

    def _load_plugin_module(self, plugin_info: 'PluginInfo'):
        """Load plugin module."""

        if plugin_info.type == PluginType.FILE:
            # Load from file
            spec = importlib.util.spec_from_file_location(
                plugin_info.name, plugin_info.path
            )
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                return module
        elif plugin_info.type == PluginType.PACKAGE:
            # Load from package
            sys.path.insert(0, str(plugin_info.path.parent))
            try:
                module = importlib.import_module(plugin_info.path.name)
                return module
            finally:
                sys.path.pop(0)

        raise PluginLoadError(f"Cannot load plugin module: {plugin_info.name}")

    def _create_plugin_instance(self, plugin_info: 'PluginInfo', module) -> 'PluginInstance':
        """Create plugin instance."""

        # Find plugin class in module
        plugin_class = None
        for class_name in plugin_info.plugin_classes:
            if hasattr(module, class_name):
                plugin_class = getattr(module, class_name)
                break

        if not plugin_class:
            raise PluginLoadError(f"No plugin class found in {plugin_info.name}")

        # Create instance
        plugin_object = plugin_class()

        return PluginInstance(
            plugin_info=plugin_info,
            plugin_object=plugin_object,
            plugin_module=module
        )

    def _setup_hot_reload(self):
        """Setup file system watching for hot reload."""

        class PluginFileHandler(FileSystemEventHandler):
            def __init__(self, plugin_manager):
                self.plugin_manager = plugin_manager

            def on_modified(self, event):
                if event.is_directory:
                    return

                file_path = Path(event.src_path)
                if file_path.suffix == '.py':
                    # Check if this is a loaded plugin
                    plugin_name = self.plugin_manager._find_plugin_by_path(file_path)
                    if plugin_name:
                        self.plugin_manager._trigger_reload(plugin_name)

        self.file_watcher = Observer()
        handler = PluginFileHandler(self)

        for plugin_dir in self.plugin_directories:
            if plugin_dir.exists():
                self.file_watcher.schedule(handler, str(plugin_dir), recursive=True)

        self.file_watcher.start()

    def _find_plugin_by_path(self, file_path: Path) -> Optional[str]:
        """Find plugin name by file path."""

        for plugin_name, plugin_instance in self.loaded_plugins.items():
            if plugin_instance.plugin_info.path == file_path:
                return plugin_name
            elif (plugin_instance.plugin_info.type == PluginType.PACKAGE and
                  file_path.is_relative_to(plugin_instance.plugin_info.path)):
                return plugin_name

        return None

    def _trigger_reload(self, plugin_name: str):
        """Trigger plugin reload after file change."""

        # Debounce rapid file changes
        time.sleep(0.1)

        try:
            # Check if plugin actually changed
            plugin_instance = self.loaded_plugins.get(plugin_name)
            if plugin_instance:
                new_checksum = self._calculate_plugin_checksum(plugin_instance.plugin_info)
                old_checksum = self.plugin_checksums.get(plugin_name)

                if new_checksum != old_checksum:
                    print(f"Reloading plugin: {plugin_name}")
                    self.reload_plugin(plugin_name)

        except Exception as e:
            print(f"Failed to reload plugin {plugin_name}: {str(e)}")

    def _calculate_plugin_checksum(self, plugin_info: 'PluginInfo') -> str:
        """Calculate checksum for plugin files."""

        hasher = hashlib.md5()

        if plugin_info.type == PluginType.FILE:
            with open(plugin_info.path, 'rb') as f:
                hasher.update(f.read())
        elif plugin_info.type == PluginType.PACKAGE:
            for py_file in plugin_info.path.rglob("*.py"):
                with open(py_file, 'rb') as f:
                    hasher.update(f.read())

        return hasher.hexdigest()

class PluginType(Enum):
    FILE = "file"
    PACKAGE = "package"

@dataclass
class PluginInfo:
    """Information about discovered plugin."""

    name: str
    version: str
    description: str
    author: str
    dependencies: List[str]
    plugin_classes: List[str]
    path: Path
    type: PluginType

@dataclass
class PluginInstance:
    """Instance of loaded plugin."""

    plugin_info: PluginInfo
    plugin_object: Any
    plugin_module: Any

    def initialize(self):
        """Initialize plugin."""
        if hasattr(self.plugin_object, 'initialize'):
            self.plugin_object.initialize()

    def cleanup(self):
        """Cleanup plugin resources."""
        if hasattr(self.plugin_object, 'cleanup'):
            self.plugin_object.cleanup()

class PluginRegistry:
    """Registry for managing plugin metadata and discovery."""

    def __init__(self):
        self.registered_plugins = {}
        self.plugin_categories = {}

    def register_plugin_category(self, category: str, description: str):
        """Register plugin category."""
        self.plugin_categories[category] = description

    def get_plugins_by_category(self, category: str) -> List[PluginInfo]:
        """Get plugins in specific category."""
        return [plugin for plugin in self.registered_plugins.values()
                if plugin.metadata.get('category') == category]

class PluginDependencyResolver:
    """Resolve plugin dependencies."""

    def __init__(self):
        self.dependency_graph = {}

    def resolve_dependencies(self, plugin_names: List[str]) -> List[str]:
        """Resolve dependencies and return load order."""

        # Build dependency graph
        self._build_dependency_graph(plugin_names)

        # Topological sort
        return self._topological_sort()

    def _build_dependency_graph(self, plugin_names: List[str]):
        """Build dependency graph."""
        # Implementation for building dependency graph
        pass

    def _topological_sort(self) -> List[str]:
        """Perform topological sort of dependencies."""
        # Implementation for topological sorting
        pass

# Plugin base classes
class Plugin(ABC):
    """Base class for all plugins."""

    def __init__(self):
        self.name = "unknown"
        self.version = "1.0.0"
        self.description = ""

    @abstractmethod
    def initialize(self):
        """Initialize plugin."""
        pass

    def cleanup(self):
        """Cleanup plugin resources."""
        pass

    def get_commands(self) -> List[Callable]:
        """Get commands provided by plugin."""
        return []

    def get_hooks(self) -> Dict[str, Callable]:
        """Get hooks provided by plugin."""
        return {}

# Exception classes
class PluginError(Exception):
    """Base exception for plugin errors."""
    pass

class PluginNotFoundError(PluginError):
    """Exception raised when plugin is not found."""
    pass

class PluginLoadError(PluginError):
    """Exception raised when plugin fails to load."""
    pass

class PluginUnloadError(PluginError):
    """Exception raised when plugin fails to unload."""
    pass

class PluginDependencyError(PluginError):
    """Exception raised for dependency issues."""
    pass
```

---

## Next Steps

Continue your CLI Framework mastery:

- **[User Guide Overview](10.03%20Chapter%2010%20-%20CLI%20Framework%20-%20User%20Guide%20-%20Overview.md)** - Quick start guide for CLI development
- **[User Guide Detailed](10.04%20Chapter%2010%20-%20CLI%20Framework%20-%20User%20Guide%20-%20Detailed.md)** - Advanced CLI patterns and enterprise applications

**The CLI Framework's detailed architecture demonstrates xlibrary's commitment to sophisticated, enterprise-ready command-line application development.** üñ•Ô∏è