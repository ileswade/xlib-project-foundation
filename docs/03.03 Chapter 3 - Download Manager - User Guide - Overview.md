# Chapter 3: Download Manager - User Guide Overview

> **üöÄ QUICK START GUIDE**
> Get up and running with the Download Manager in 5 minutes. Essential patterns for downloading from YouTube, social media, and general web content.

## 5-Minute Quick Start

### Installation
```bash
# Install download pillar
pip install xlibrary[download]
```

### Basic Usage

```python
from xlibrary.download import get_video, get_audio, get_transcript, DownloadManager

# Simple convenience functions
video_file = get_video("https://youtube.com/watch?v=dQw4w9WgXcQ")
audio_file = get_audio("https://youtube.com/watch?v=dQw4w9WgXcQ", output_dir="~/Music")
transcript_file = get_transcript("https://youtube.com/watch?v=dQw4w9WgXcQ", output_dir="~/Documents")

print(f"Downloaded video: {video_file}")
print(f"Downloaded audio: {audio_file}")
print(f"Downloaded transcript: {transcript_file}")

# Enterprise queue system
dm = DownloadManager(default_output_dir="~/Downloads", max_concurrent=3)
task_id = dm.add_download("https://vimeo.com/123456789")
dm.start_queue()  # Process downloads automatically
```

---

## Essential Patterns

### 1. Convenience Functions (Simple)

Perfect for one-off downloads:

```python
from xlibrary.download import get_video, get_audio, get_transcript, get_content

# Download video in best quality
video = get_video("https://youtube.com/watch?v=xyz")

# Download audio only
audio = get_audio("https://youtube.com/watch?v=xyz", quality="320k")

# Download transcript only (perfect for YouTube videos!)
transcript = get_transcript("https://youtube.com/watch?v=xyz", languages=["en", "es"])

# Download any web content
content = get_content("https://example.com/file.zip")

# Get video info without downloading
from xlibrary.download import get_info
info = get_info("https://youtube.com/watch?v=xyz")
print(f"Title: {info['title']}, Duration: {info['duration']}")
```

### 2. Download Manager (Advanced)

For queue management and concurrent downloads:

```python
from xlibrary.download import DownloadManager, DownloadConfig

# Initialize manager
dm = DownloadManager(
    default_output_dir="~/Downloads",
    max_concurrent=5,
    queue_file="my_downloads.json"  # Persistent queue
)

# Add downloads to queue
task1 = dm.add_download("https://youtube.com/watch?v=abc")
task2 = dm.add_download("https://vimeo.com/123", priority=1)  # Higher priority

# Start processing queue
dm.start_queue()

# Monitor progress
print(f"Queue status: {dm.get_queue_status()}")
```

### 3. Configuration Options

Control download behavior:

```python
from xlibrary.download import DownloadConfig

# Video download configuration
video_config = DownloadConfig(
    quality="720p",           # Video quality
    format="mp4",            # Output format
    embed_subtitles=True,    # Include subtitles
    embed_metadata=True      # Include metadata
)

# Audio-only configuration
audio_config = DownloadConfig(
    audio_only=True,         # Extract audio only
    quality="320k",          # Audio quality
    format="mp3",           # Audio format
    normalize_audio=True     # Normalize volume
)

# Use configurations
dm = DownloadManager()
dm.add_download(url, config=video_config)
dm.add_download(url, config=audio_config)
```

### 4. Progress Tracking

Monitor download progress:

```python
def progress_callback(task_id, progress):
    percent = progress.percent
    speed = progress.download_speed
    eta = progress.eta
    print(f"Download {task_id}: {percent:.1f}% complete, {speed}, ETA: {eta}")

def completion_callback(task_id, result):
    if result.success:
        print(f"‚úÖ Download {task_id} completed: {result.local_path}")
    else:
        print(f"‚ùå Download {task_id} failed: {result.error}")

# Set up callbacks
dm = DownloadManager()
dm.set_progress_callback(progress_callback)
dm.set_completion_callback(completion_callback)

# Downloads will trigger callbacks
task_id = dm.add_download("https://youtube.com/watch?v=xyz")
dm.start_queue()
```

### 5. Batch Downloads

Download multiple items efficiently:

```python
from xlibrary.download import get_audio_batch

# Batch download with convenience function
urls = [
    "https://youtube.com/watch?v=abc",
    "https://youtube.com/watch?v=def",
    "https://youtube.com/watch?v=ghi"
]

results = get_audio_batch(urls, output_dir="~/Music", max_concurrent=3)
for url, result in results.items():
    print(f"URL: {url} -> {result}")

# Batch download with manager
dm = DownloadManager(max_concurrent=5)
task_ids = []

for url in urls:
    task_id = dm.add_download(url, config=DownloadConfig(audio_only=True))
    task_ids.append(task_id)

dm.start_queue()

# Wait for completion
dm.wait_for_completion()
```

---

## Common Use Cases

### 1. Enhanced Download Results with Rich Metadata

**What this example demonstrates:** How the Download Manager now provides comprehensive metadata about completed downloads, including performance metrics, format details, source information, and fallback attempts.

```python
from xlibrary.download import get_video, DownloadConfig

# Download with Mac-optimized settings
config = DownloadConfig.mac_optimized()  # Prioritizes MP4, H264 codec
result = get_video("https://youtube.com/watch?v=xyz", config=config)

# Rich metadata available after download
print("=== Download Summary ===")
print(f"Success: {result.success}")
print(f"Source: {result.source_domain}")  # "youtube" (clean domain)
print(f"Method: {result.method_used}")    # "yt-dlp"
print(f"Format: {result.actual_format}")  # "mp4"
print(f"Quality: {result.quality_selected}")  # "720p"
print(f"File size: {result.file_size_mb:.1f} MB")
print(f"Duration: {result.duration_formatted}")  # "03:45"
print(f"Download time: {result.download_time:.2f}s")
print(f"Speed: {result.download_speed_mbps:.2f} Mbps")
print(f"Uploader: {result.uploader}")
print(f"Fallbacks attempted: {len(result.fallback_attempts)}")

# Detailed technical info
print(f"Resolution: {result.resolution}")  # "1280x720"
print(f"Video codec: {result.codec_info.get('video')}")  # "h264"
print(f"Audio codec: {result.codec_info.get('audio')}")  # "aac"
print(f"FPS: {result.fps}")
print(f"Bitrate: {result.bitrate} kbps")

# Available formats that weren't used
print(f"Available formats: {result.available_formats}")
print(f"Available qualities: {result.available_qualities}")
```

### 2. Format Discovery and Platform Optimization

**What this example demonstrates:** How to query available formats before downloading and get platform-optimized recommendations for the best compatibility and performance.

```python
from xlibrary.download import get_available_formats, get_optimal_format

# Query what formats are available for a URL
formats = get_available_formats("https://youtube.com/watch?v=xyz")
print(f"Video formats: {formats['video_formats']}")      # ['mp4', 'webm', 'mkv']
print(f"Audio formats: {formats['audio_formats']}")      # ['mp3', 'm4a', 'webm']
print(f"Available qualities: {formats['qualities']}")    # ['1080p', '720p', '480p']
print(f"Subtitle languages: {formats['subtitle_languages']}")  # ['en', 'es', 'fr']
print(f"Video codecs: {formats['codecs']['video']}")     # ['h264', 'vp9', 'av01']
print(f"Audio codecs: {formats['codecs']['audio']}")     # ['aac', 'opus', 'mp3']

# Get optimal format for your platform
optimal_video = get_optimal_format("https://youtube.com/watch?v=xyz", "video", "mac")
print(f"Best video format for Mac: {optimal_video['format']}")     # "mp4"
print(f"Best quality for Mac: {optimal_video['quality']}")         # "720p"
print(f"Best codec for Mac: {optimal_video['codec']}")            # "h264"

optimal_audio = get_optimal_format("https://youtube.com/watch?v=xyz", "audio", "mac")
print(f"Best audio format for Mac: {optimal_audio['format']}")     # "mp3"

# Use the recommendations
from xlibrary.download import DownloadConfig, get_video
config = DownloadConfig(
    video_format=optimal_video['format'],
    quality=optimal_video['quality'],
    preferred_video_codecs=[optimal_video['codec']]
)
video_file = get_video("https://youtube.com/watch?v=xyz", config=config)
```

### 3. Transcript-Only Downloads (Perfect for YouTube!)

**What this example demonstrates:** How to download just transcripts/subtitles from YouTube videos without downloading the video or audio. This is perfect when you only need the text content for analysis, research, or accessibility purposes.

```python
from xlibrary.download import get_transcript, DownloadManager, DownloadConfig

def download_youtube_transcript(url, languages=["en"], output_dir="~/Transcripts"):
    """Download YouTube transcript only - no video or audio"""

    # Simple one-line transcript download
    transcript_path = get_transcript(
        url,
        output_dir=output_dir,
        languages=languages,
        timeout=60  # Transcripts download quickly
    )

    print(f"Transcript downloaded: {transcript_path}")
    return transcript_path

# Download transcript in multiple languages
transcript_en = download_youtube_transcript(
    "https://youtube.com/watch?v=dQw4w9WgXcQ",
    languages=["en"],
    output_dir="~/Research/Transcripts"
)

# Download transcript with fallback languages
transcript_multi = download_youtube_transcript(
    "https://youtube.com/watch?v=xyz",
    languages=["en", "es", "fr"],  # Will try English first, then Spanish, then French
    output_dir="~/Documents"
)

# Batch transcript downloads for research
def download_transcript_batch(video_urls, output_dir="~/Transcripts"):
    """Download transcripts from multiple YouTube videos"""
    dm = DownloadManager(max_concurrent=3)

    transcript_config = DownloadConfig(
        subtitle_languages=["en"],
        audio_only=False,  # Need video metadata for transcript extraction
        timeout=120
    )

    task_ids = []
    for url in video_urls:
        task_id = dm.add_download(url, output_dir, transcript_config)
        task_ids.append(task_id)

    dm.start_queue()
    return task_ids

# Usage for research or content analysis
research_urls = [
    "https://youtube.com/watch?v=video1",
    "https://youtube.com/watch?v=video2",
    "https://youtube.com/watch?v=video3"
]

transcript_tasks = download_transcript_batch(research_urls, "~/Research/YouTube_Transcripts")
print(f"Started {len(transcript_tasks)} transcript downloads")
```

### 2. YouTube Video Downloader

```python
from xlibrary.download import get_video, get_info

def download_youtube_video(url, quality="720p", output_dir="~/Downloads"):
    """Download YouTube video with specified quality"""

    # Get video info first
    info = get_info(url)
    print(f"Title: {info['title']}")
    print(f"Duration: {info['duration']}")
    print(f"Available qualities: {info['available_qualities']}")

    # Download video
    result = get_video(
        url,
        quality=quality,
        output_dir=output_dir,
        embed_metadata=True,
        embed_subtitles=True
    )

    return result

# Usage
video_path = download_youtube_video(
    "https://youtube.com/watch?v=dQw4w9WgXcQ",
    quality="1080p"
)
print(f"Downloaded: {video_path}")
```

### 2. Playlist Downloader

```python
from xlibrary.download import DownloadManager, DownloadConfig

def download_playlist(playlist_url, audio_only=False, max_items=None):
    """Download entire playlist or channel"""

    # Configuration for playlist
    config = DownloadConfig(
        audio_only=audio_only,
        quality="best" if not audio_only else "320k",
        format="mp4" if not audio_only else "mp3",
        max_downloads=max_items,
        download_archive="downloaded.txt",  # Track what's been downloaded
        ignore_errors=True  # Continue if individual items fail
    )

    dm = DownloadManager(
        default_output_dir="~/Playlists",
        max_concurrent=3
    )

    task_id = dm.add_download(playlist_url, config=config)
    dm.start_queue()

    return task_id

# Usage
playlist_task = download_playlist(
    "https://youtube.com/playlist?list=PLxxxx",
    audio_only=True,
    max_items=50
)
```

### 3. Social Media Content Downloader

```python
from xlibrary.download import DownloadManager, DownloadConfig

def download_social_media(urls, output_base="~/SocialMedia"):
    """Download content from various social media platforms"""

    dm = DownloadManager(max_concurrent=2)  # Be respectful to servers

    platform_configs = {
        'instagram.com': DownloadConfig(
            quality="best",
            embed_metadata=True,
            write_description=True
        ),
        'tiktok.com': DownloadConfig(
            quality="best",
            format="mp4"
        ),
        'twitter.com': DownloadConfig(
            quality="720p",
            embed_metadata=True
        )
    }

    task_ids = []

    for url in urls:
        # Determine platform and use appropriate config
        config = None
        for platform, platform_config in platform_configs.items():
            if platform in url:
                config = platform_config
                break

        if not config:
            config = DownloadConfig()  # Default config

        # Set platform-specific output directory
        platform_name = next((p.split('.')[0] for p in platform_configs.keys() if p in url), 'other')
        config.output_dir = f"{output_base}/{platform_name}"

        task_id = dm.add_download(url, config=config)
        task_ids.append(task_id)

    dm.start_queue()
    return task_ids

# Usage
social_urls = [
    "https://instagram.com/p/xxxxxx/",
    "https://tiktok.com/@user/video/xxxxxx",
    "https://twitter.com/user/status/xxxxxx"
]

tasks = download_social_media(social_urls)
```

### 4. Podcast/Audio Content Manager

```python
from xlibrary.download import DownloadManager, DownloadConfig
from pathlib import Path

class PodcastDownloader:
    def __init__(self, base_dir="~/Podcasts"):
        self.base_dir = Path(base_dir).expanduser()
        self.dm = DownloadManager(max_concurrent=2)

        # Podcast-optimized configuration
        self.config = DownloadConfig(
            audio_only=True,
            quality="128k",  # Good quality, reasonable size
            format="mp3",
            normalize_audio=True,
            embed_metadata=True,
            embed_artwork=True
        )

    def download_episode(self, url, podcast_name=None):
        """Download single podcast episode"""
        if podcast_name:
            output_dir = self.base_dir / podcast_name
        else:
            output_dir = self.base_dir / "General"

        config = self.config.copy()
        config.output_dir = str(output_dir)

        return self.dm.add_download(url, config=config)

    def download_feed(self, feed_url, max_episodes=10):
        """Download recent episodes from podcast feed"""
        config = self.config.copy()
        config.max_downloads = max_episodes
        config.download_archive = str(self.base_dir / "podcast_archive.txt")

        return self.dm.add_download(feed_url, config=config)

# Usage
podcast_dl = PodcastDownloader()

# Download specific episode
episode_task = podcast_dl.download_episode(
    "https://example.com/podcast/episode-123",
    podcast_name="My Favorite Podcast"
)

# Download recent episodes from feed
feed_task = podcast_dl.download_feed(
    "https://feeds.example.com/podcast.rss",
    max_episodes=5
)

podcast_dl.dm.start_queue()
```

### 5. Automated Download Monitor

```python
from xlibrary.download import DownloadManager, DownloadConfig
import time
import threading

class DownloadMonitor:
    def __init__(self):
        self.dm = DownloadManager(max_concurrent=3)
        self.dm.set_progress_callback(self.on_progress)
        self.dm.set_completion_callback(self.on_completion)
        self.dm.set_error_callback(self.on_error)

        self.stats = {
            'completed': 0,
            'failed': 0,
            'total_size': 0
        }

    def on_progress(self, task_id, progress):
        """Handle progress updates"""
        print(f"üì• {task_id}: {progress.percent:.1f}% "
              f"({progress.download_speed}) - ETA: {progress.eta}")

    def on_completion(self, task_id, result):
        """Handle completion"""
        self.stats['completed'] += 1
        self.stats['total_size'] += result.file_size or 0

        print(f"‚úÖ Completed: {task_id}")
        print(f"   File: {result.local_path}")
        print(f"   Size: {self._format_size(result.file_size)}")
        print(f"   Strategy: {result.strategy_used}")

    def on_error(self, task_id, error):
        """Handle errors"""
        self.stats['failed'] += 1
        print(f"‚ùå Failed: {task_id} - {error}")

    def add_download(self, url, **config_kwargs):
        """Add download with monitoring"""
        config = DownloadConfig(**config_kwargs)
        return self.dm.add_download(url, config=config)

    def start_monitoring(self):
        """Start download processing with monitoring"""
        self.dm.start_queue()

        # Status thread
        def status_thread():
            while self.dm.is_processing():
                time.sleep(10)
                queue_status = self.dm.get_queue_status()
                print(f"üìä Queue: {queue_status['active']} active, "
                      f"{queue_status['queued']} queued, "
                      f"{queue_status['completed']} completed")

        threading.Thread(target=status_thread, daemon=True).start()

    def _format_size(self, bytes_size):
        """Format file size"""
        if not bytes_size:
            return "Unknown"

        for unit in ['B', 'KB', 'MB', 'GB']:
            if bytes_size < 1024:
                return f"{bytes_size:.1f} {unit}"
            bytes_size /= 1024
        return f"{bytes_size:.1f} TB"

# Usage
monitor = DownloadMonitor()

# Add various downloads
monitor.add_download("https://youtube.com/watch?v=abc", quality="720p")
monitor.add_download("https://vimeo.com/123", audio_only=True)
monitor.add_download("https://example.com/file.zip")

# Start monitoring
monitor.start_monitoring()

# Let it run...
input("Press Enter to stop monitoring...")
```

---

## Error Handling Patterns

### Basic Error Handling

```python
from xlibrary.download import get_video, DownloadError, UnsupportedSourceError

try:
    video_path = get_video("https://youtube.com/watch?v=xyz")
    print(f"Success: {video_path}")

except UnsupportedSourceError as e:
    print(f"Source not supported: {e.url}")
    print(f"Supported sites: {e.supported_sites}")

except DownloadError as e:
    print(f"Download failed: {e}")
    if hasattr(e, 'fallback_attempts'):
        print("Fallback attempts:")
        for attempt in e.fallback_attempts:
            print(f"  - {attempt['strategy']}: {attempt['error']}")

except Exception as e:
    print(f"Unexpected error: {e}")
```

### Robust Download with Retries

```python
from xlibrary.download import DownloadManager, DownloadConfig

def robust_download(url, max_attempts=3, **config_kwargs):
    """Download with automatic retries"""

    config = DownloadConfig(
        max_retries=max_attempts,
        retry_delay=5,  # 5 second delay between retries
        **config_kwargs
    )

    dm = DownloadManager()
    task_id = dm.add_download(url, config=config)

    # Wait for completion
    while True:
        status = dm.get_task_status(task_id)
        if status.is_complete():
            if status.success:
                return status.result.local_path
            else:
                raise DownloadError(f"Download failed after {max_attempts} attempts: {status.result.error}")

        time.sleep(1)

# Usage
try:
    video_path = robust_download(
        "https://youtube.com/watch?v=xyz",
        max_attempts=5,
        quality="720p"
    )
    print(f"Downloaded: {video_path}")

except DownloadError as e:
    print(f"Could not download after retries: {e}")
```

---

## Best Practices

### 1. **Resource Management**
```python
# Use context manager for automatic cleanup
with DownloadManager(max_concurrent=3) as dm:
    task_id = dm.add_download(url)
    dm.start_queue()
    # Automatically stops queue and cleans up on exit
```

### 2. **Respectful Downloading**
```python
# Be respectful to servers
dm = DownloadManager(
    max_concurrent=2,  # Don't overwhelm servers
    rate_limit_mbps=5  # Limit bandwidth usage
)

# Add delays for social media
config = DownloadConfig(
    request_delay=2,  # 2 second delay between requests
    respect_robots_txt=True
)
```

### 3. **Storage Organization**
```python
# Organize downloads by source
config = DownloadConfig(
    output_template="%(uploader)s/%(title)s.%(ext)s",
    create_directories=True
)

# Archive downloaded items
config = DownloadConfig(
    download_archive="archive.txt",  # Track what's downloaded
    skip_duplicates=True
)
```

### 4. **Quality Selection**
```python
# Smart quality selection
config = DownloadConfig(
    quality="720p",           # Preferred quality
    fallback_quality="480p",  # Fallback if preferred not available
    max_file_size="500MB"     # Size limit
)
```

---

## Next Steps

Ready for advanced download management?

- **[Detailed User Guide](03.04%20Chapter%203%20-%20Download%20Manager%20-%20User%20Guide%20-%20Detailed.md)** - Comprehensive feature coverage
- **[Chapter 4: Files Manager](04.01%20Chapter%204%20-%20Files%20Manager%20-%20Design%20-%20Overview.md)** - Advanced file operations
- **[Design Documentation](03.01%20Chapter%203%20-%20Download%20Manager%20-%20Design%20-%20Overview.md)** - Architectural details

**You're now ready to download content from anywhere with xlibrary!** üéâ

---

## Troubleshooting

### Common Issues

**"No suitable downloader found" error:**
```python
from xlibrary.download import check_dependencies
check_dependencies()  # Shows what's available

# Install missing dependencies
# pip install yt-dlp youtube-dl
```

**Download stalls or fails:**
```python
# Increase timeout
config = DownloadConfig(
    timeout=300,  # 5 minute timeout
    max_retries=5
)

# Try different strategy
dm.download(url, force_strategy="http")
```

**Unsupported site:**
```python
from xlibrary.download import list_supported_sites
supported = list_supported_sites()
print(f"Supported sites: {len(supported)} total")
```