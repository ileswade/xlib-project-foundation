# Chapter 4: Files Manager - User Guide Overview

> **üöÄ QUICK START GUIDE**
> Get up and running with the Files Manager in 5 minutes. Essential patterns for file organization, deduplication, compression, and type detection.

## 5-Minute Quick Start

### Installation
```bash
# Install files pillar
pip install xlibrary[files]
```

### Basic Usage

```python
from xlibrary.files import FileManager

# Initialize manager
fm = FileManager()

# Detect file type
file_info = fm.detect_file_type("document.pdf")
print(f"Type: {file_info.file_type}, Size: {file_info.size}")

# Organize messy folder
result = fm.organize_by_file_type("/messy/downloads")
print(f"Organized {result.files_processed} files")

# Find and remove duplicates
duplicates = fm.find_duplicates("/photos")
fm.remove_duplicates(duplicates, keep='newest')

# Compress folder
fm.compress_folder("/source/folder", "/archive.zip")
```

---

## Essential Patterns

### 1. File Type Detection (Smart)

Perfect for understanding your files:

```python
from xlibrary.files import FileManager

fm = FileManager()

# Basic type detection
file_info = fm.detect_file_type("mystery_file.dat")
print(f"File type: {file_info.file_type}")
print(f"MIME type: {file_info.mime_type}")
print(f"Size: {file_info.size:,} bytes")

# Detect type mismatches (security check)
suspicious = fm.detect_file_type("document.exe")
if suspicious.is_type_mismatch:
    print("‚ö†Ô∏è Warning: File extension doesn't match content!")
    print(f"Claims to be: {suspicious.declared_type}")
    print(f"Actually is: {suspicious.actual_type}")

# Get comprehensive file info
info = fm.detect_file_type("/path/to/file.jpg")
print(f"Name: {info.name}")
print(f"Hidden: {info.is_hidden}")
print(f"Permissions: {info.permissions}")
print(f"Modified: {info.modified_time}")
print(f"MD5 hash: {info.hash_md5}")
```

### 2. Folder Organization (Automated)

For cleaning up messy directories:

```python
from xlibrary.files import FileManager

fm = FileManager()

# Organize by file type (creates folders automatically)
result = fm.organize_by_file_type("/messy/downloads")
print(f"‚úÖ Organized {result.files_processed} files")
print(f"Created folders: {', '.join([f.name for f in result.folders_created])}")

# Custom organization rules
def organize_by_date_and_type(file_info):
    """Organize by year and file type."""
    year = file_info.modified_time.year
    file_type = file_info.file_type.value.title()
    return f"{year}/{file_type}"

result = fm.organize_by_rule("/photos", organize_by_date_and_type)

# Collapse nested folders (flatten structure)
result = fm.collapse_folders("/deep/nested/structure")
print(f"Moved {result.files_processed} files to root level")
```

### 3. Duplicate Detection (Advanced)

Find and manage duplicate files:

```python
from xlibrary.files import FileManager

fm = FileManager()

# Find duplicates by content hash
duplicates = fm.find_duplicates("/photos", methods=['hash'])

for group in duplicates:
    print(f"\nFound {len(group.files)} duplicates:")
    print(f"Size: {group.size:,} bytes each")
    print(f"Wasted space: {group.wasted_space:,} bytes")

    for file_info in group.files:
        print(f"  - {file_info.path}")

# Remove duplicates (keep newest)
removed = fm.remove_duplicates(duplicates, keep='newest')
print(f"Freed up {removed.space_recovered:,} bytes")

# Interactive duplicate removal
def user_choice_callback(group):
    print(f"\nDuplicate group with {len(group.files)} files:")
    for i, file_info in enumerate(group.files):
        print(f"{i+1}. {file_info.path} ({file_info.modified_time})")

    choice = input("Keep which file? (1-N, or 's' to skip): ")
    if choice.lower() == 's':
        return None
    return int(choice) - 1

fm.remove_duplicates_interactive(duplicates, callback=user_choice_callback)
```

### 4. Compression Operations

Archive and compress folders:

```python
from xlibrary.files import FileManager

fm = FileManager()

# Simple folder compression
result = fm.compress_folder("/source/folder", "/backup.zip")
print(f"Compressed {result.files_compressed} files")
print(f"Original: {result.original_size:,} bytes")
print(f"Compressed: {result.compressed_size:,} bytes")
print(f"Compression: {result.compression_ratio:.1%}")

# Compression with progress tracking
def progress_callback(current, total, message):
    percent = (current / total) * 100
    print(f"Progress: {percent:.1f}% - {message}")

result = fm.compress_folder(
    "/large/folder",
    "/archive.tar.gz",
    format="tar.gz",
    progress_callback=progress_callback
)

# Extract archive
result = fm.extract_archive("/backup.zip", "/restore/location")
print(f"Extracted {result.files_extracted} files")
```

### 5. Batch File Operations

Handle multiple files efficiently:

```python
from xlibrary.files import FileManager

fm = FileManager()

# Get list of files to process
files_to_process = list(Path("/large/folder").rglob("*.txt"))

# Process in batches with progress
def batch_callback(current, total, message):
    print(f"Processing {current}/{total}: {message}")

def convert_operation(file_path):
    # Your custom operation here
    return fm.detect_file_type(file_path)

result = fm.batch_process_files(
    files_to_process,
    operation=convert_operation,
    progress_callback=batch_callback
)

print(f"Processed {result.successful_operations}/{result.total_files} files")
if result.failed_operations:
    print("Failed files:")
    for failure in result.failed_operations:
        print(f"  - {failure['file']}: {failure['error']}")
```

---

## Common Use Cases

### 1. Clean Up Downloads Folder

```python
from xlibrary.files import FileManager
from pathlib import Path

def cleanup_downloads(downloads_path="~/Downloads"):
    """Clean and organize downloads folder."""
    fm = FileManager()
    downloads = Path(downloads_path).expanduser()

    print("üßπ Cleaning up Downloads folder...")

    # Step 1: Remove duplicates
    print("Finding duplicates...")
    duplicates = fm.find_duplicates(downloads, methods=['hash'])
    if duplicates:
        removed = fm.remove_duplicates(duplicates, keep='newest')
        print(f"‚úÖ Removed duplicates, freed {removed.space_recovered:,} bytes")

    # Step 2: Organize by file type
    print("Organizing files...")
    result = fm.organize_by_file_type(downloads)
    print(f"‚úÖ Organized {result.files_processed} files into {len(result.folders_created)} folders")

    # Step 3: Remove empty folders
    print("Cleaning empty folders...")
    empty_result = fm.remove_empty_folders(downloads)
    print(f"‚úÖ Removed {empty_result.folders_removed} empty folders")

    return result

# Usage
cleanup_result = cleanup_downloads()
```

### 2. Photo Library Management

```python
from xlibrary.files import FileManager
from pathlib import Path

class PhotoManager:
    def __init__(self, photos_dir="~/Pictures"):
        self.fm = FileManager()
        self.photos_dir = Path(photos_dir).expanduser()

    def organize_by_date(self):
        """Organize photos by date taken."""
        def date_rule(file_info):
            if file_info.file_type.name != 'IMAGE':
                return "Other"

            # Use modification date as proxy for date taken
            date = file_info.modified_time
            return f"{date.year}/{date.month:02d}-{date.strftime('%B')}"

        result = self.fm.organize_by_rule(self.photos_dir, date_rule)
        return result

    def find_similar_photos(self):
        """Find potentially duplicate or similar photos."""
        duplicates = self.fm.find_duplicates(
            self.photos_dir,
            methods=['hash', 'fuzzy']  # Include fuzzy matching
        )
        return duplicates

    def create_yearly_archives(self):
        """Create yearly archives of photos."""
        current_year = datetime.now().year

        for year in range(2020, current_year):
            year_folder = self.photos_dir / str(year)
            if year_folder.exists():
                archive_path = self.photos_dir.parent / f"Photos_{year}.zip"
                result = self.fm.compress_folder(year_folder, archive_path)
                print(f"Created {archive_path}: {result.files_compressed} photos")

# Usage
photo_manager = PhotoManager()
photo_manager.organize_by_date()
similar_photos = photo_manager.find_similar_photos()
```

### 3. Large File Finder and Manager

```python
from xlibrary.files import FileManager
from pathlib import Path

def find_large_files(directory, size_threshold_mb=100):
    """Find and analyze large files in directory."""
    fm = FileManager(large_file_threshold=size_threshold_mb * 1024 * 1024)

    large_files = []
    total_size = 0

    for file_path in Path(directory).rglob('*'):
        if file_path.is_file():
            file_info = fm.detect_file_type(file_path)

            if file_info.size > fm.large_file_threshold:
                large_files.append(file_info)
                total_size += file_info.size

    # Sort by size (largest first)
    large_files.sort(key=lambda f: f.size, reverse=True)

    print(f"Found {len(large_files)} files larger than {size_threshold_mb}MB")
    print(f"Total size: {total_size / (1024**3):.2f} GB")
    print("\nLargest files:")

    for i, file_info in enumerate(large_files[:10]):  # Top 10
        size_mb = file_info.size / (1024**2)
        print(f"{i+1:2d}. {file_info.name} - {size_mb:.1f} MB ({file_info.file_type.value})")

    return large_files

# Usage
large_files = find_large_files("/Users/username", size_threshold_mb=50)

# Compress large files
fm = FileManager()
for file_info in large_files[:5]:  # Compress top 5
    if file_info.file_type.name in ['VIDEO', 'DOCUMENT']:
        archive_path = file_info.path.with_suffix('.zip')
        fm.compress_file(file_info.path, archive_path)
```

### 4. Folder Structure Analysis

```python
from xlibrary.files import FileManager

def analyze_folder_structure(directory):
    """Get comprehensive folder statistics."""
    fm = FileManager()

    stats = fm.get_folder_stats(directory)

    print(f"üìä Folder Analysis: {directory}")
    print(f"Total files: {stats.total_files:,}")
    print(f"Total directories: {stats.total_directories:,}")
    print(f"Total size: {stats.total_size / (1024**3):.2f} GB")
    print(f"Hidden files: {stats.hidden_files_count}")
    print(f"Empty files: {stats.empty_files_count}")
    print(f"Large files (>100MB): {stats.large_files_count}")

    print("\nüìÅ File types:")
    for file_type, count in stats.file_type_counts.items():
        print(f"  {file_type.value.title()}: {count:,} files")

    print("\nüìÑ Extensions:")
    top_extensions = sorted(
        stats.extension_counts.items(),
        key=lambda x: x[1],
        reverse=True
    )[:10]

    for ext, count in top_extensions:
        ext_display = ext or "(no extension)"
        print(f"  {ext_display}: {count:,} files")

    return stats

# Usage
stats = analyze_folder_structure("/Users/username/Documents")
```

### 5. File System Maintenance

```python
from xlibrary.files import FileManager
from datetime import datetime, timedelta

class FileSystemMaintenance:
    def __init__(self, base_directory):
        self.fm = FileManager()
        self.base_dir = Path(base_directory)

    def cleanup_old_files(self, days_old=365):
        """Remove files older than specified days."""
        cutoff_date = datetime.now() - timedelta(days=days_old)
        old_files = []

        for file_path in self.base_dir.rglob('*'):
            if file_path.is_file():
                file_info = self.fm.detect_file_type(file_path)
                if file_info.modified_time < cutoff_date:
                    old_files.append(file_path)

        print(f"Found {len(old_files)} files older than {days_old} days")

        # Safe removal with confirmation
        if old_files:
            response = input("Remove these files? (y/n): ")
            if response.lower() == 'y':
                for file_path in old_files:
                    try:
                        file_path.unlink()
                        print(f"Removed: {file_path}")
                    except Exception as e:
                        print(f"Failed to remove {file_path}: {e}")

    def find_broken_files(self):
        """Find files that might be corrupted."""
        broken_files = []

        for file_path in self.base_dir.rglob('*'):
            if file_path.is_file():
                try:
                    file_info = self.fm.detect_file_type(file_path)

                    # Check for zero-byte files
                    if file_info.size == 0:
                        broken_files.append({
                            'path': file_path,
                            'issue': 'Zero bytes',
                            'severity': 'high'
                        })

                    # Check for type mismatches
                    if file_info.is_type_mismatch:
                        broken_files.append({
                            'path': file_path,
                            'issue': f'Extension mismatch: claims {file_info.declared_type}, actually {file_info.actual_type}',
                            'severity': 'medium'
                        })

                except Exception as e:
                    broken_files.append({
                        'path': file_path,
                        'issue': f'Read error: {str(e)}',
                        'severity': 'high'
                    })

        return broken_files

    def maintenance_report(self):
        """Generate comprehensive maintenance report."""
        print("üîß File System Maintenance Report")
        print("=" * 40)

        # Basic stats
        stats = self.fm.get_folder_stats(self.base_dir)
        print(f"Total files: {stats.total_files:,}")
        print(f"Total size: {stats.total_size / (1024**3):.2f} GB")

        # Duplicates
        duplicates = self.fm.find_duplicates(self.base_dir)
        if duplicates:
            total_wasted = sum(group.wasted_space for group in duplicates)
            print(f"Duplicate groups: {len(duplicates)}")
            print(f"Wasted space: {total_wasted / (1024**2):.1f} MB")

        # Broken files
        broken = self.find_broken_files()
        if broken:
            print(f"Potentially broken files: {len(broken)}")
            for item in broken[:5]:  # Show first 5
                print(f"  - {item['path']}: {item['issue']}")

        print("\n‚úÖ Maintenance scan complete")

# Usage
maintenance = FileSystemMaintenance("/Users/username/Documents")
maintenance.maintenance_report()
maintenance.cleanup_old_files(days_old=730)  # 2 years
```

---

## Error Handling Patterns

### Safe Operations with Dry Run

```python
from xlibrary.files import FileManager, FileManagerError

fm = FileManager()

# Always test operations first
try:
    result = fm.organize_by_file_type("/important/files", dry_run=True)

    print(f"Dry run results:")
    print(f"Would process: {result.files_processed} files")
    print(f"Would create: {len(result.planned_operations)} operations")

    if result.success:
        # Execute for real
        confirm = input("Proceed with actual operation? (y/n): ")
        if confirm.lower() == 'y':
            actual_result = fm.organize_by_file_type("/important/files")
            print(f"‚úÖ Organized {actual_result.files_processed} files")

except FileManagerError as e:
    print(f"‚ùå Operation failed: {e}")
    if e.rollback_available:
        rollback = input("Attempt rollback? (y/n): ")
        if rollback.lower() == 'y':
            fm.rollback_operation(e.operation_id)
```

### Robust Error Handling

```python
from xlibrary.files import FileManager, FileManagerError

def safe_file_operation(operation_func, *args, **kwargs):
    """Wrapper for safe file operations with error handling."""
    try:
        return operation_func(*args, **kwargs)

    except FileManagerError as e:
        print(f"File Manager Error: {e}")
        return None

    except PermissionError:
        print("Permission denied. Try running with appropriate privileges.")
        return None

    except OSError as e:
        print(f"System error: {e}")
        return None

    except Exception as e:
        print(f"Unexpected error: {e}")
        return None

# Usage
fm = FileManager()
result = safe_file_operation(fm.organize_by_file_type, "/protected/folder")
if result:
    print("Operation completed successfully")
```

---

## Best Practices

### 1. **Always Use Dry Run First**
```python
# Test before executing
result = fm.operation(path, dry_run=True)
if result.success:
    actual_result = fm.operation(path)
```

### 2. **Progress Tracking for Long Operations**
```python
def progress_tracker(current, total, message):
    percent = (current / total) * 100
    print(f"[{percent:5.1f}%] {message}")

fm.long_operation(path, progress_callback=progress_tracker)
```

### 3. **Safe Duplicate Removal**
```python
# Keep backups when removing duplicates
duplicates = fm.find_duplicates(path)
backup_removed = fm.remove_duplicates(duplicates, keep='newest', backup=True)
```

### 4. **Memory Management for Large Operations**
```python
# Use batch processing for large directories
fm = FileManager(chunk_size=1024*1024)  # 1MB chunks
result = fm.process_large_directory(path, batch_size=100)
```

---

## Troubleshooting

### Common Issues

**"Permission denied" errors:**
```python
# Check file permissions first
file_info = fm.detect_file_type(path)
if not file_info.is_writable:
    print("File is not writable, check permissions")
```

**Memory issues with large folders:**
```python
# Use streaming mode for large directories
fm = FileManager()
result = fm.process_large_directory(path, use_streaming=True)
```

**Type detection fails:**
```python
# Check if magic library is available
from xlibrary.files.core.manager import MAGIC_AVAILABLE
if not MAGIC_AVAILABLE:
    print("Install python-magic for better file type detection")
    # pip install python-magic
```

---

## Next Steps

Ready for advanced file management?

- **[Detailed User Guide](04.04%20Chapter%204%20-%20Files%20Manager%20-%20User%20Guide%20-%20Detailed.md)** - Comprehensive feature coverage
- **[Chapter 5: Media Manager](05.01%20Chapter%205%20-%20Media%20Manager%20-%20Design%20-%20Overview.md)** - Media processing and manipulation
- **[Design Documentation](04.01%20Chapter%204%20-%20Files%20Manager%20-%20Design%20-%20Overview.md)** - Architectural details

**You're now ready to manage files like a pro with xlibrary!** üéâ