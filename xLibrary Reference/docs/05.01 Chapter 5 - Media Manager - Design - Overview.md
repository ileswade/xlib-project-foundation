# Chapter 5: Media Manager - Design Overview

> **ðŸŽ¬ PROFESSIONAL MEDIA PROCESSING SYSTEM**
> The Media Manager provides enterprise-grade video and image processing with advanced watermarking, precise timestamp control, frame-accurate editing, and professional workflow integration.

## Quick Review

### What is the Media Manager?

The Media Manager is xlibrary's comprehensive media processing pillar that handles professional video editing, intelligent watermarking, image processing, and format conversion with enterprise-grade reliability. It provides frame-accurate video trimming, resolution-adaptive watermarking, and integrated FFmpeg workflows for production environments.

**Core Concept**: Professional media processing with adaptive watermarking and precise control

```python
from xlibrary.media import MediaManager, WatermarkConfig, WatermarkPosition

# Initialize manager
mm = MediaManager()

# Frame-accurate video trimming with flexible timestamps
result = mm.trim_video(
    "source.mp4",
    start_time="2:30.5",        # 2 minutes 30.5 seconds
    end_time="f5400",           # Frame 5400
    output_path="trimmed.mp4"
)

# Intelligent watermarking with auto-scaling
watermark_config = WatermarkConfig(
    watermark_path="logo.png",
    position=WatermarkPosition.BOTTOM_RIGHT,
    auto_scale=True,
    opacity=0.8
)

result = mm.watermark_video("video.mp4", watermark_config, "branded.mp4")
```

### Key Design Innovations

#### 1. **Master Watermark System**
Single high-resolution watermark approach with intelligent scaling:

```python
# One master watermark scales to all resolutions
watermark_config = WatermarkConfig(
    watermark_path="master_logo_4K.png",  # High-res master
    position=WatermarkPosition.BOTTOM_RIGHT,
    max_width_percent=0.20,               # 20% of video width
    scale_factor=1.0,                     # Auto-adapts to resolution
    maintain_aspect_ratio=True
)

# Automatically scales for different video resolutions
result_720p = mm.watermark_video("video_720p.mp4", watermark_config)  # Scales to 720p
result_4K = mm.watermark_video("video_4K.mp4", watermark_config)      # Scales to 4K
```

#### 2. **Flexible Timestamp System**
Multiple timestamp format support with frame accuracy:

```python
# Multiple timestamp formats supported
mm.trim_video("video.mp4", start_time="2:30.5")      # Minutes:seconds.milliseconds
mm.trim_video("video.mp4", start_time="f5400")       # Frame number
mm.trim_video("video.mp4", start_time="150.75")      # Seconds with decimals
mm.trim_video("video.mp4", start_time="02:30:15.5")  # Hours:minutes:seconds.ms

# Advanced timestamp parsing
from xlibrary.media.utils import parse_timestamp

timestamp = parse_timestamp("2:30.5", fps=30)
print(f"Frame: {timestamp.frame}, Seconds: {timestamp.seconds}")
```

#### 3. **Advanced Watermark Animations**
Sophisticated watermark animation system:

```python
# Animated watermarks with precise control
animated_config = WatermarkConfig(
    watermark_path="animated_logo.png",
    position=WatermarkPosition.TOP_LEFT,
    animation=WatermarkAnimation.FADE_IN_OUT,
    animation_duration=5.0,               # 5 second animation
    animation_start_time=10.0,            # Start at 10 seconds
    animation_end_time=60.0,              # End at 60 seconds
    opacity=0.9
)

result = mm.watermark_video("content.mp4", animated_config, "branded.mp4")
```

#### 4. **Professional Video Processing**
FFmpeg integration with advanced controls:

```python
# Professional video processing
processing_config = ProcessingConfig(
    quality="high",                       # Encoding quality
    hardware_acceleration=True,           # GPU acceleration
    preserve_metadata=True,               # Keep original metadata
    audio_codec="aac",                    # Audio codec
    video_codec="h264"                    # Video codec
)

mm = MediaManager(config=processing_config)

# Extract thumbnails at precise moments
thumbnails = mm.extract_thumbnails(
    "video.mp4",
    times=["0:30", "2:15.5", "f7200"],   # Multiple timestamp formats
    output_dir="thumbnails/"
)
```

### Architecture Highlights

#### Core Components
- **MediaManager**: Main orchestrator for all media operations
- **WatermarkEngine**: Advanced watermarking with animation support
- **AnimationEngine**: Complex watermark animation processing
- **TimeStampParser**: Multi-format timestamp parsing and conversion
- **FFmpegIntegration**: Professional video processing pipeline

#### Watermarking System
- **Master Watermark Approach**: Single high-res source scales to all outputs
- **Resolution Detection**: Automatic video resolution analysis
- **Adaptive Scaling**: Intelligent scaling based on target resolution
- **Position Calculation**: Precise positioning with margin controls
- **Transparency Handling**: Advanced alpha channel processing

#### Timestamp Processing
- **Multi-Format Support**: HH:MM:SS.ms, frame numbers, seconds
- **Frame Accuracy**: Precise frame-level positioning
- **FPS Detection**: Automatic frame rate detection
- **Format Conversion**: Seamless conversion between formats
- **Validation System**: Comprehensive timestamp validation

### Design Philosophy

#### 1. **Professional Quality**
Enterprise-grade processing with frame-perfect accuracy:

```python
# Frame-accurate trimming
result = mm.trim_video(
    "master.mp4",
    start_time="f1500",         # Exact frame 1500
    end_time="f4800",           # Exact frame 4800
    preserve_quality=True       # Lossless where possible
)

# Quality preservation settings
config = ProcessingConfig(
    video_codec="prores",       # Professional codec
    bitrate="50M",              # High bitrate
    color_space="rec709",       # Broadcast standard
    preserve_metadata=True      # Keep all metadata
)
```

#### 2. **Adaptive Intelligence**
Smart processing that adapts to content characteristics:

```python
# Intelligent watermark scaling
watermark_config = WatermarkConfig(
    watermark_path="logo.png",
    auto_scale=True,                    # Enable intelligent scaling
    resolution_thresholds={             # Custom scaling rules
        "320p": {"scale": 0.8, "opacity": 0.7},
        "720p": {"scale": 1.0, "opacity": 0.8},
        "1080p": {"scale": 1.2, "opacity": 0.8},
        "4K": {"scale": 1.5, "opacity": 0.9}
    }
)

# Auto-detects resolution and applies appropriate settings
result = mm.watermark_video("video.mp4", watermark_config)
```

#### 3. **Batch Processing**
Efficient handling of large media sets:

```python
# Batch watermark application
videos = ["video1.mp4", "video2.mp4", "video3.mp4"]

def progress_callback(current, total, filename):
    print(f"Processing {current}/{total}: {filename}")

results = mm.batch_watermark(
    video_paths=videos,
    watermark_config=watermark_config,
    output_directory="branded_videos/",
    progress_callback=progress_callback
)
```

#### 4. **Platform Integration**
Deep integration with system capabilities:

```python
# macOS thumbnail generation
result = mm.create_video_thumbnail(
    "video.mp4",
    timestamp="2:30",
    size=(1920, 1080),
    set_as_icon=True,           # Set as Finder icon (macOS)
    optimize_for_preview=True   # Optimize for Quick Look
)

# System integration
if result.success:
    # Automatically appears in Finder with custom thumbnail
    print(f"Thumbnail set for: {result.output_path}")
```

### Performance Characteristics

- **Hardware Acceleration**: GPU-accelerated processing where available
- **Memory Efficient**: Streaming processing for large files
- **Parallel Processing**: Multi-threaded operations for batch work
- **Cache System**: Intelligent caching of frequently used assets
- **Progress Tracking**: Real-time progress for long operations

### Integration Points

The Media Manager integrates with other xlibrary pillars:

- **Download Manager**: Process downloaded video content
- **Files Manager**: Organize processed media files
- **Config Manager**: Store watermark templates and processing presets
- **Pipeline Manager**: Media processing as automated pipeline stages
- **AI Manager**: AI-powered content analysis and tagging

### Error Handling Strategy

Comprehensive error handling with graceful degradation:

```python
try:
    result = mm.watermark_video("video.mp4", watermark_config)
    if result.success:
        print(f"Watermarked video: {result.output_path}")
    else:
        print(f"Watermarking failed: {result.error}")
        # Fallback processing options available

except FFmpegNotFoundError:
    print("FFmpeg not installed. Install with: brew install ffmpeg")

except UnsupportedFormatError as e:
    print(f"Format not supported: {e.format}")
    # Automatic format conversion options

except WatermarkError as e:
    print(f"Watermark processing failed: {e}")
    if e.fallback_available:
        # Try simpler watermarking approach
        simple_result = mm.simple_watermark(video_path, watermark_path)
```

### Watermarking Architecture

#### Resolution-Adaptive System
```python
class ResolutionAdapter:
    """Adapts watermark to target video resolution."""

    RESOLUTION_PROFILES = {
        "320p": {"max_size": 64, "opacity": 0.7, "margin": 10},
        "480p": {"max_size": 96, "opacity": 0.75, "margin": 15},
        "720p": {"max_size": 128, "opacity": 0.8, "margin": 20},
        "1080p": {"max_size": 192, "opacity": 0.8, "margin": 25},
        "1440p": {"max_size": 256, "opacity": 0.85, "margin": 30},
        "4K": {"max_size": 384, "opacity": 0.9, "margin": 40},
        "8K": {"max_size": 512, "opacity": 0.95, "margin": 50}
    }

    def adapt_watermark(self, video_resolution, master_watermark):
        """Adapt master watermark to target resolution."""
        profile = self._get_profile(video_resolution)

        adapted_watermark = self._scale_watermark(
            master_watermark,
            max_size=profile["max_size"],
            opacity=profile["opacity"]
        )

        return adapted_watermark, profile["margin"]
```

#### Animation System
```python
class WatermarkAnimator:
    """Handles complex watermark animations."""

    def create_fade_in_out(self, watermark, duration, video_fps):
        """Create fade-in/fade-out animation."""
        frames = []
        total_frames = int(duration * video_fps)

        fade_frames = total_frames // 4  # 25% fade in/out

        for frame_num in range(total_frames):
            if frame_num < fade_frames:
                # Fade in
                opacity = frame_num / fade_frames
            elif frame_num > total_frames - fade_frames:
                # Fade out
                opacity = (total_frames - frame_num) / fade_frames
            else:
                # Full opacity
                opacity = 1.0

            frame = self._apply_opacity(watermark, opacity)
            frames.append(frame)

        return frames
```

### Timestamp System Architecture

#### Multi-Format Parser
```python
class TimeStampParser:
    """Advanced timestamp parsing with multiple format support."""

    TIMESTAMP_PATTERNS = {
        "hms": r"^(\d{1,2}):(\d{1,2}):(\d{1,2})(?:\.(\d+))?$",      # HH:MM:SS.ms
        "ms": r"^(\d{1,2}):(\d{1,2})(?:\.(\d+))?$",                 # MM:SS.ms
        "frame": r"^f(\d+)$",                                       # f1234
        "seconds": r"^(\d+(?:\.\d+)?)$"                            # 123.45
    }

    def parse(self, timestamp_str, video_fps=30):
        """Parse timestamp into TimeStamp object."""
        for format_name, pattern in self.TIMESTAMP_PATTERNS.items():
            match = re.match(pattern, timestamp_str)
            if match:
                return self._parse_format(format_name, match, video_fps)

        raise TimestampError(f"Unsupported timestamp format: {timestamp_str}")

    def _parse_format(self, format_name, match, fps):
        """Parse specific timestamp format."""
        if format_name == "frame":
            frame_number = int(match.group(1))
            seconds = frame_number / fps
            return TimeStamp(frame_number, seconds, fps)

        elif format_name == "seconds":
            seconds = float(match.group(1))
            frame_number = int(seconds * fps)
            return TimeStamp(frame_number, seconds, fps)

        # ... other format handling
```

### Professional Video Processing

#### FFmpeg Integration
```python
class FFmpegProcessor:
    """Professional video processing with FFmpeg."""

    def __init__(self):
        self.ffmpeg_path = self._find_ffmpeg()
        if not self.ffmpeg_path:
            raise FFmpegNotFoundError("FFmpeg not found. Install with: brew install ffmpeg")

    def trim_video_precise(self, input_path, start_time, end_time, output_path):
        """Frame-accurate video trimming."""

        # Convert timestamps to precise format
        start_seconds = self._timestamp_to_seconds(start_time)
        end_seconds = self._timestamp_to_seconds(end_time)

        # Build FFmpeg command for precise cutting
        cmd = [
            self.ffmpeg_path,
            "-i", input_path,
            "-ss", str(start_seconds),           # Seek to start
            "-to", str(end_seconds),             # End time
            "-c", "copy",                        # Stream copy (lossless)
            "-avoid_negative_ts", "make_zero",   # Handle timestamp issues
            "-y",                                # Overwrite output
            output_path
        ]

        return self._execute_ffmpeg(cmd)

    def apply_watermark_advanced(self, video_path, watermark_data, output_path):
        """Apply watermark with advanced blending."""

        # Create temporary watermark file
        temp_watermark = self._create_temp_watermark(watermark_data)

        cmd = [
            self.ffmpeg_path,
            "-i", video_path,
            "-i", temp_watermark,
            "-filter_complex",
            f"[1:v]scale={watermark_data.scaled_size}[watermark];"
            f"[0:v][watermark]overlay={watermark_data.position}:enable='between(t,{watermark_data.start_time},{watermark_data.end_time})'",
            "-c:a", "copy",                      # Copy audio without re-encoding
            "-y",
            output_path
        ]

        try:
            return self._execute_ffmpeg(cmd)
        finally:
            # Cleanup temporary files
            if temp_watermark.exists():
                temp_watermark.unlink()
```

---

## Next Steps

- **[Detailed Design Discussion](05.02%20Chapter%205%20-%20Media%20Manager%20-%20Design%20-%20Detailed.md)** - Deep dive into watermarking algorithms, animation systems, and FFmpeg integration
- **[User Guide Overview](05.03%20Chapter%205%20-%20Media%20Manager%20-%20User%20Guide%20-%20Overview.md)** - Quick start guide for video and image processing
- **[User Guide Detailed](05.04%20Chapter%205%20-%20Media%20Manager%20-%20User%20Guide%20-%20Detailed.md)** - Comprehensive media processing workflows

**The Media Manager represents xlibrary's commitment to professional-grade media processing with intelligent automation.** ðŸŽ¬