# Chapter 5: Media Manager - User Guide Overview

> **üöÄ QUICK START GUIDE**
> Get up and running with the Media Manager in 5 minutes. Essential patterns for video processing, watermarking, timestamp handling, and professional media workflows.

## 5-Minute Quick Start

### Installation
```bash
# Install media pillar
pip install xlibrary[media]

# For advanced video processing, ensure FFmpeg is installed
brew install ffmpeg  # macOS
# or apt install ffmpeg  # Linux
# or download from https://ffmpeg.org/ for Windows
```

### Basic Usage

```python
from xlibrary.media import MediaManager, WatermarkConfig, WatermarkPosition

# Initialize manager
mm = MediaManager()

# Video trimming with flexible timestamps
result = mm.trim_video(
    "input.mp4",
    start_time="2:30.5",        # 2 minutes 30.5 seconds
    end_time="f5400",           # Frame 5400
    output_path="trimmed.mp4"
)

# Smart watermarking
watermark_config = WatermarkConfig(
    watermark_path="logo.png",
    position=WatermarkPosition.BOTTOM_RIGHT,
    auto_scale=True,
    opacity=0.8
)

result = mm.watermark_video("video.mp4", watermark_config, "branded.mp4")

# Extract thumbnails
thumbnails = mm.extract_thumbnails(
    "video.mp4",
    times=["0:30", "2:15.5", "f7200"],
    output_dir="thumbnails/"
)
```

---

## Essential Patterns

### 1. Flexible Timestamp Formats (Universal)

Work with any timestamp format seamlessly:

```python
from xlibrary.media import MediaManager
from xlibrary.media.utils import parse_timestamp

mm = MediaManager()

# All these timestamp formats work
formats = [
    "2:30.5",          # Minutes:seconds.milliseconds
    "01:23:45.678",    # Hours:minutes:seconds.milliseconds
    "f5400",           # Frame number (frame 5400)
    "150.75",          # Decimal seconds
    "01:23:45:12",     # SMPTE timecode (HH:MM:SS:FF)
    "123456ms"         # Milliseconds
]

for timestamp in formats:
    result = mm.trim_video(
        "source.mp4",
        start_time=timestamp,
        end_time="f10800",  # Mix formats freely
        output_path=f"clip_{timestamp.replace(':', '-')}.mp4"
    )

    print(f"‚úÖ Created clip with timestamp: {timestamp}")

# Parse and convert timestamps
timestamp_obj = parse_timestamp("2:30.5", fps=30)
print(f"Frame: {timestamp_obj.frame}, Seconds: {timestamp_obj.seconds}")

# Convert between formats
from xlibrary.media.utils import timestamp_to_frame, frame_to_timestamp
frame_num = timestamp_to_frame("2:30.5", fps=30)  # Get frame number
time_str = frame_to_timestamp(4575, fps=30)        # Convert frame to time
```

### 2. Master Watermark System (Intelligent)

One watermark file scales to all video resolutions:

```python
from xlibrary.media import MediaManager, WatermarkConfig, WatermarkPosition

mm = MediaManager()

# Create master watermark config (works for any resolution)
watermark_config = WatermarkConfig(
    watermark_path="master_logo_4K.png",      # High-resolution master
    position=WatermarkPosition.BOTTOM_RIGHT,
    max_width_percent=0.20,                   # 20% of video width
    opacity=0.8,
    auto_scale=True                           # Automatically adapts
)

# Apply to videos of different resolutions
videos = [
    "video_720p.mp4",
    "video_1080p.mp4",
    "video_4K.mp4"
]

for video in videos:
    result = mm.watermark_video(video, watermark_config, f"branded_{video}")
    print(f"‚úÖ Watermarked {video} - auto-scaled to match resolution")

# Custom scaling rules for different resolutions
advanced_config = WatermarkConfig(
    watermark_path="logo.png",
    position=WatermarkPosition.TOP_RIGHT,
    resolution_scaling={
        "720p": {"scale": 0.8, "opacity": 0.7},
        "1080p": {"scale": 1.0, "opacity": 0.8},
        "4K": {"scale": 1.5, "opacity": 0.9}
    }
)
```

### 3. Animated Watermarks (Professional)

Add dynamic watermark animations:

```python
from xlibrary.media import MediaManager, WatermarkConfig, WatermarkAnimation

mm = MediaManager()

# Fade in/out animation
fade_config = WatermarkConfig(
    watermark_path="animated_logo.png",
    position=WatermarkPosition.CENTER,
    animation=WatermarkAnimation.FADE_IN_OUT,
    animation_duration=5.0,           # 5-second animation cycle
    animation_start_time=10.0,        # Start at 10 seconds
    animation_end_time=60.0,          # End at 60 seconds
    opacity=0.9
)

result = mm.watermark_video("content.mp4", fade_config, "animated_brand.mp4")

# Scrolling credits-style animation
credits_config = WatermarkConfig(
    watermark_path="credits_text.png",
    animation=WatermarkAnimation.CREDITS_ROLL,
    animation_duration=15.0,          # 15-second scroll
    animation_start_time=0.0,         # Start immediately
    position=WatermarkPosition.BOTTOM_CENTER
)

result = mm.watermark_video("video.mp4", credits_config, "with_credits.mp4")

# Pulsing logo animation
pulse_config = WatermarkConfig(
    watermark_path="logo.png",
    position=WatermarkPosition.TOP_LEFT,
    animation=WatermarkAnimation.PULSE,
    animation_duration=0.0,           # Entire video duration
    pulse_frequency=1.0,              # 1 pulse per second
    pulse_amplitude=0.2               # 20% size variation
)
```

### 4. Professional Video Processing

Advanced video operations with quality control:

```python
from xlibrary.media import MediaManager, ProcessingConfig

# Professional processing configuration
config = ProcessingConfig(
    video_codec="h264",
    quality="high",                   # High quality encoding
    hardware_acceleration=True,       # Use GPU if available
    preserve_metadata=True,           # Keep original metadata
    audio_codec="aac"
)

mm = MediaManager(config=config)

# Frame-accurate trimming
result = mm.trim_video(
    "master.mp4",
    start_time="f1500",              # Exact frame 1500
    end_time="f4800",                # Exact frame 4800
    output_path="precise_clip.mp4",
    preserve_quality=True            # Lossless where possible
)

# Extract thumbnails at precise moments
thumbnails = mm.extract_thumbnails(
    "video.mp4",
    times=["0:00", "1:30", "3:00", "4:30"],
    size=(1920, 1080),               # Full HD thumbnails
    output_dir="thumbnails/",
    format="png"
)

# Batch processing with progress tracking
def progress_callback(current, total, filename):
    percent = (current / total) * 100
    print(f"Processing {current}/{total} ({percent:.1f}%): {filename}")

video_list = ["video1.mp4", "video2.mp4", "video3.mp4"]
results = mm.batch_watermark(
    video_paths=video_list,
    watermark_config=watermark_config,
    output_directory="branded_videos/",
    progress_callback=progress_callback
)
```

### 5. Image Processing and Optimization

Advanced image processing capabilities:

```python
from xlibrary.media import MediaManager
from xlibrary.media.core.types import ImageFormat

mm = MediaManager()

# Image format conversion with optimization
result = mm.convert_image(
    "photo.jpg",
    output_path="optimized.webp",
    target_format=ImageFormat.WEBP,
    quality=85,
    optimize=True
)

# Batch image processing
image_files = ["img1.jpg", "img2.png", "img3.tiff"]

results = mm.batch_convert_images(
    image_paths=image_files,
    target_format=ImageFormat.JPEG,
    output_directory="converted/",
    quality=90,
    resize_max_dimension=2048  # Resize large images
)

# Smart image optimization
for image_path in image_files:
    result = mm.optimize_image(
        image_path,
        max_size_mb=2.0,          # Maximum 2MB file size
        max_dimension=1920,       # Maximum 1920px width/height
        quality_target=85         # Target quality
    )
    print(f"Optimized {image_path}: {result.original_size}MB ‚Üí {result.optimized_size}MB")
```

---

## Common Use Cases

### 1. YouTube Content Creation Workflow

```python
from xlibrary.media import MediaManager, WatermarkConfig, WatermarkPosition
from pathlib import Path

def youtube_workflow(video_path, channel_logo):
    """Complete YouTube video processing workflow."""
    mm = MediaManager()
    video_path = Path(video_path)

    print("üé¨ Starting YouTube workflow...")

    # Step 1: Trim intro/outro
    print("‚úÇÔ∏è Trimming video...")
    trimmed = mm.trim_video(
        video_path,
        start_time="0:05",        # Skip 5-second intro
        end_time="-0:03",         # Remove last 3 seconds
        output_path=video_path.with_stem(f"{video_path.stem}_trimmed")
    )

    # Step 2: Add channel watermark
    print("üè∑Ô∏è Adding watermark...")
    watermark_config = WatermarkConfig(
        watermark_path=channel_logo,
        position=WatermarkPosition.BOTTOM_RIGHT,
        max_width_percent=0.15,   # 15% of video width
        opacity=0.7,
        auto_scale=True
    )

    watermarked = mm.watermark_video(
        trimmed.output_path,
        watermark_config,
        video_path.with_stem(f"{video_path.stem}_branded")
    )

    # Step 3: Create thumbnails for different timestamps
    print("üì∏ Creating thumbnails...")
    thumbnail_times = ["0:30", "2:00", "5:00"]  # Key moments
    thumbnails = mm.extract_thumbnails(
        watermarked.output_path,
        times=thumbnail_times,
        size=(1920, 1080),
        output_dir=f"thumbnails_{video_path.stem}/",
        format="png"
    )

    print("‚úÖ YouTube workflow complete!")
    return {
        'final_video': watermarked.output_path,
        'thumbnails': thumbnails,
        'processing_time': watermarked.processing_time
    }

# Usage
result = youtube_workflow("raw_content.mp4", "channel_logo.png")
print(f"Final video: {result['final_video']}")
```

### 2. Social Media Content Optimizer

```python
from xlibrary.media import MediaManager, WatermarkConfig, WatermarkPosition

class SocialMediaOptimizer:
    def __init__(self):
        self.mm = MediaManager()

        # Platform specifications
        self.platform_specs = {
            'instagram': {
                'square': {'width': 1080, 'height': 1080},
                'story': {'width': 1080, 'height': 1920},
                'feed': {'width': 1080, 'height': 1080}
            },
            'tiktok': {
                'vertical': {'width': 1080, 'height': 1920}
            },
            'twitter': {
                'landscape': {'width': 1200, 'height': 675},
                'square': {'width': 1200, 'height': 1200}
            },
            'youtube': {
                'shorts': {'width': 1080, 'height': 1920},
                'thumbnail': {'width': 1280, 'height': 720}
            }
        }

    def create_social_versions(self, video_path, logo_path, platforms):
        """Create optimized versions for different social platforms."""
        results = {}

        for platform in platforms:
            print(f"üì± Creating {platform} versions...")

            if platform == 'instagram':
                # Square version for Instagram feed
                square_config = WatermarkConfig(
                    watermark_path=logo_path,
                    position=WatermarkPosition.TOP_RIGHT,
                    max_width_percent=0.12,
                    opacity=0.8
                )

                square_result = self.mm.resize_and_watermark(
                    video_path,
                    target_resolution=(1080, 1080),
                    watermark_config=square_config,
                    output_path=f"instagram_square_{Path(video_path).stem}.mp4",
                    crop_mode="center"
                )

                # Story version (vertical)
                story_result = self.mm.resize_and_watermark(
                    video_path,
                    target_resolution=(1080, 1920),
                    watermark_config=square_config,
                    output_path=f"instagram_story_{Path(video_path).stem}.mp4",
                    crop_mode="center"
                )

                results[platform] = {
                    'square': square_result,
                    'story': story_result
                }

            elif platform == 'tiktok':
                # Vertical format for TikTok
                tiktok_config = WatermarkConfig(
                    watermark_path=logo_path,
                    position=WatermarkPosition.BOTTOM_LEFT,
                    max_width_percent=0.15,
                    opacity=0.9
                )

                tiktok_result = self.mm.resize_and_watermark(
                    video_path,
                    target_resolution=(1080, 1920),
                    watermark_config=tiktok_config,
                    output_path=f"tiktok_{Path(video_path).stem}.mp4",
                    crop_mode="center"
                )

                results[platform] = {'vertical': tiktok_result}

        return results

# Usage
optimizer = SocialMediaOptimizer()
results = optimizer.create_social_versions(
    "content.mp4",
    "brand_logo.png",
    ['instagram', 'tiktok']
)

for platform, versions in results.items():
    print(f"{platform.title()} versions created:")
    for format_name, result in versions.items():
        print(f"  - {format_name}: {result.output_path}")
```

### 3. Podcast Video Creation

```python
from xlibrary.media import MediaManager, WatermarkConfig, WatermarkPosition

def create_podcast_video(audio_path, background_image, podcast_logo):
    """Convert podcast audio to video with static background and animated logo."""

    mm = MediaManager()

    # Step 1: Create video from audio + static background
    print("üéß Creating video from podcast audio...")
    video_result = mm.create_video_from_audio(
        audio_path=audio_path,
        background_image=background_image,
        output_path="podcast_base_video.mp4",
        video_codec="h264",
        quality="high"
    )

    # Step 2: Add animated podcast logo
    print("üéµ Adding animated podcast branding...")
    logo_config = WatermarkConfig(
        watermark_path=podcast_logo,
        position=WatermarkPosition.CENTER,
        animation=WatermarkAnimation.FADE_IN_OUT,
        animation_duration=10.0,      # 10-second fade cycle
        animation_start_time=5.0,     # Start after 5 seconds
        max_width_percent=0.25,       # 25% of video width
        opacity=0.9
    )

    branded_result = mm.watermark_video(
        video_result.output_path,
        logo_config,
        "podcast_final.mp4"
    )

    # Step 3: Create chapters/segments if needed
    print("üìö Creating chapter thumbnails...")
    chapter_times = ["0:00", "15:00", "30:00", "45:00"]  # Every 15 minutes
    thumbnails = mm.extract_thumbnails(
        branded_result.output_path,
        times=chapter_times,
        output_dir="podcast_chapters/",
        size=(1280, 720)
    )

    return {
        'video_path': branded_result.output_path,
        'chapter_thumbnails': thumbnails,
        'duration': branded_result.duration
    }

# Usage
podcast_result = create_podcast_video(
    "episode_001.mp3",
    "podcast_background.jpg",
    "podcast_logo.png"
)

print(f"Podcast video created: {podcast_result['video_path']}")
print(f"Duration: {podcast_result['duration']:.1f} seconds")
```

### 4. Training Video Production

```python
from xlibrary.media import MediaManager, WatermarkConfig, WatermarkPosition

class TrainingVideoProducer:
    def __init__(self):
        self.mm = MediaManager()

    def create_training_series(self, raw_videos, company_logo, intro_video=None):
        """Process training videos with consistent branding and structure."""

        processed_videos = []

        # Company watermark configuration
        brand_config = WatermarkConfig(
            watermark_path=company_logo,
            position=WatermarkPosition.BOTTOM_RIGHT,
            max_width_percent=0.12,
            opacity=0.7,
            auto_scale=True
        )

        for i, video_path in enumerate(raw_videos, 1):
            print(f"üéì Processing training video {i}/{len(raw_videos)}")

            # Step 1: Add intro if provided
            if intro_video:
                with_intro = self.mm.concatenate_videos(
                    [intro_video, video_path],
                    output_path=f"temp_with_intro_{i}.mp4"
                )
                working_video = with_intro.output_path
            else:
                working_video = video_path

            # Step 2: Add company branding
            branded = self.mm.watermark_video(
                working_video,
                brand_config,
                f"training_module_{i:02d}.mp4"
            )

            # Step 3: Create chapter markers every 5 minutes
            duration = self.mm.get_video_duration(branded.output_path)
            chapter_times = [f"{m}:00" for m in range(0, int(duration // 60), 5)]

            if len(chapter_times) > 1:
                thumbnails = self.mm.extract_thumbnails(
                    branded.output_path,
                    times=chapter_times,
                    output_dir=f"module_{i:02d}_chapters/",
                    size=(640, 360)
                )
            else:
                thumbnails = []

            processed_videos.append({
                'module_number': i,
                'video_path': branded.output_path,
                'duration': duration,
                'chapter_thumbnails': thumbnails,
                'chapter_count': len(chapter_times)
            })

            # Cleanup temporary files
            if intro_video and Path(working_video).exists():
                Path(working_video).unlink()

        return processed_videos

    def create_series_index(self, processed_videos):
        """Create an index video showing all modules."""

        # Extract first frame from each video for index
        index_frames = []
        for video_info in processed_videos:
            frame = self.mm.extract_frame(
                video_info['video_path'],
                timestamp="0:05",  # 5 seconds in
                output_path=f"index_frame_{video_info['module_number']}.png"
            )
            index_frames.append(frame.output_path)

        # Create montage/grid of all module previews
        # (This would require additional image processing capabilities)
        print("üìã Series index frames extracted")
        return index_frames

# Usage
producer = TrainingVideoProducer()

raw_training_videos = [
    "module_1_raw.mp4",
    "module_2_raw.mp4",
    "module_3_raw.mp4"
]

series_result = producer.create_training_series(
    raw_training_videos,
    "company_logo.png",
    intro_video="training_intro.mp4"
)

for module in series_result:
    print(f"Module {module['module_number']}: {module['video_path']}")
    print(f"  Duration: {module['duration']:.1f}s, Chapters: {module['chapter_count']}")
```

### 5. Live Stream Archive Processor

```python
from xlibrary.media import MediaManager, WatermarkConfig, WatermarkPosition

def process_stream_archive(stream_recording, highlights_timestamps, channel_info):
    """Process recorded live stream into highlights and full archive."""

    mm = MediaManager()

    print("üì∫ Processing live stream archive...")

    # Channel branding configuration
    channel_config = WatermarkConfig(
        watermark_path=channel_info['logo'],
        position=WatermarkPosition.TOP_LEFT,
        max_width_percent=0.1,
        opacity=0.8,
        animation=WatermarkAnimation.FADE_IN,
        animation_duration=3.0
    )

    results = {}

    # Step 1: Create branded full archive
    print("üè∑Ô∏è Adding channel branding to full archive...")
    full_archive = mm.watermark_video(
        stream_recording,
        channel_config,
        "stream_archive_branded.mp4"
    )
    results['full_archive'] = full_archive.output_path

    # Step 2: Extract highlights
    print("‚ú® Extracting highlights...")
    highlights = []

    for i, highlight in enumerate(highlights_timestamps, 1):
        highlight_clip = mm.trim_video(
            stream_recording,
            start_time=highlight['start'],
            end_time=highlight['end'],
            output_path=f"highlight_{i:02d}_{highlight['title']}.mp4"
        )

        # Add highlight-specific branding
        highlight_config = WatermarkConfig(
            watermark_path=channel_info['logo'],
            position=WatermarkPosition.BOTTOM_CENTER,
            max_width_percent=0.15,
            opacity=0.9,
            animation=WatermarkAnimation.PULSE,
            animation_duration=2.0
        )

        branded_highlight = mm.watermark_video(
            highlight_clip.output_path,
            highlight_config,
            f"highlight_branded_{i:02d}.mp4"
        )

        highlights.append({
            'title': highlight['title'],
            'path': branded_highlight.output_path,
            'duration': branded_highlight.duration
        })

    results['highlights'] = highlights

    # Step 3: Create highlight compilation
    if len(highlights) > 1:
        print("üé¨ Creating highlights compilation...")
        highlight_paths = [h['path'] for h in highlights]
        compilation = mm.concatenate_videos(
            highlight_paths,
            output_path="highlights_compilation.mp4",
            add_transitions=True
        )
        results['compilation'] = compilation.output_path

    # Step 4: Generate thumbnails for key moments
    print("üì∏ Generating thumbnails...")
    thumbnail_times = ["0:30"] + [h['start'] for h in highlights_timestamps[:5]]
    thumbnails = mm.extract_thumbnails(
        full_archive.output_path,
        times=thumbnail_times,
        output_dir="stream_thumbnails/",
        size=(1280, 720)
    )
    results['thumbnails'] = thumbnails

    return results

# Usage
highlights_data = [
    {'start': '15:30', 'end': '18:45', 'title': 'Epic_Moment_1'},
    {'start': '45:20', 'end': '47:10', 'title': 'Funny_Chat_Interaction'},
    {'start': '1:23:15', 'end': '1:25:30', 'title': 'Technical_Discussion'}
]

channel_data = {
    'logo': 'channel_logo.png',
    'name': 'Tech Stream Channel'
}

stream_results = process_stream_archive(
    "livestream_2024_01_15.mp4",
    highlights_data,
    channel_data
)

print("Stream processing complete!")
print(f"Full archive: {stream_results['full_archive']}")
print(f"Highlights created: {len(stream_results['highlights'])}")
if 'compilation' in stream_results:
    print(f"Compilation: {stream_results['compilation']}")
```

---

## Error Handling Patterns

### Safe Processing with Validation

```python
from xlibrary.media import MediaManager, MediaError, FFmpegNotFoundError

def safe_video_processing(video_path, watermark_path):
    """Robust video processing with comprehensive error handling."""

    try:
        mm = MediaManager()

        # Validate inputs
        if not Path(video_path).exists():
            print(f"‚ùå Video file not found: {video_path}")
            return None

        if not Path(watermark_path).exists():
            print(f"‚ùå Watermark file not found: {watermark_path}")
            return None

        # Analyze video first
        analysis = mm.analyze_video(video_path)
        print(f"üìä Video Analysis:")
        print(f"  Resolution: {analysis.resolution}")
        print(f"  Duration: {analysis.duration:.1f}s")
        print(f"  FPS: {analysis.fps}")

        # Configure watermark based on analysis
        watermark_config = WatermarkConfig(
            watermark_path=watermark_path,
            position=WatermarkPosition.BOTTOM_RIGHT,
            auto_scale=True,
            max_width_percent=0.2 if analysis.resolution.width >= 1920 else 0.25
        )

        # Process video
        result = mm.watermark_video(
            video_path,
            watermark_config,
            f"processed_{Path(video_path).name}"
        )

        if result.success:
            print(f"‚úÖ Processing successful: {result.output_path}")
            return result
        else:
            print(f"‚ùå Processing failed: {result.error}")
            return None

    except FFmpegNotFoundError:
        print("‚ùå FFmpeg not found. Install with: brew install ffmpeg")
        return None

    except MediaError as e:
        print(f"‚ùå Media processing error: {e}")
        return None

    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        return None

# Usage with error handling
result = safe_video_processing("input.mp4", "logo.png")
if result:
    print("Processing completed successfully!")
else:
    print("Processing failed - check errors above")
```

---

## Best Practices

### 1. **Quality Preservation**
```python
# Use appropriate settings for quality preservation
config = ProcessingConfig(
    video_codec="h264",
    quality_crf=23,        # Lower = better quality
    preserve_metadata=True,
    audio_codec="aac"
)
```

### 2. **Performance Optimization**
```python
# Enable hardware acceleration for large files
config = ProcessingConfig(
    hardware_acceleration=True,
    parallel_processing=True
)

# Use appropriate quality settings
mm = MediaManager(config=config)
```

### 3. **Resource Management**
```python
# Use context managers for cleanup
with MediaManager() as mm:
    result = mm.process_video(video_path)
    # Automatic cleanup on exit
```

### 4. **Format Compatibility**
```python
# Always check format compatibility
supported_formats = mm.get_supported_formats()
if Path(video_path).suffix.lower() in supported_formats['video']:
    # Process video
    pass
else:
    # Convert format first
    converted = mm.convert_format(video_path, target_format="mp4")
```

---

## Troubleshooting

### Common Issues

**FFmpeg not found:**
```bash
# macOS
brew install ffmpeg

# Linux
sudo apt install ffmpeg

# Windows - download from https://ffmpeg.org/
```

**Watermark not visible:**
```python
# Check watermark opacity and position
config = WatermarkConfig(
    watermark_path="logo.png",
    opacity=0.9,              # Increase opacity
    position=WatermarkPosition.BOTTOM_RIGHT,
    offset_x=50, offset_y=50  # Move away from edges
)
```

**Timestamp parsing errors:**
```python
from xlibrary.media.utils import validate_timestamp

# Validate timestamp before use
try:
    validate_timestamp("2:30.5", video_duration=300.0)
    # Timestamp is valid
except TimestampError as e:
    print(f"Invalid timestamp: {e}")
```

---

## Next Steps

Ready for advanced media processing?

- **[Detailed User Guide](05.04%20Chapter%205%20-%20Media%20Manager%20-%20User%20Guide%20-%20Detailed.md)** - Comprehensive workflows and examples
- **[Chapter 6: Communication Manager](06.01%20Chapter%206%20-%20Communication%20Manager%20-%20Design%20-%20Overview.md)** - Email and messaging systems
- **[Design Documentation](05.01%20Chapter%205%20-%20Media%20Manager%20-%20Design%20-%20Overview.md)** - Architectural details

**You're now ready to create professional media content with xlibrary!** üé¨