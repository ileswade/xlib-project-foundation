# Chapter 2: Config Manager - Detailed User Guide

> **📚 COMPREHENSIVE FEATURE REFERENCE**
> Complete coverage of all Config Manager features, advanced TOML patterns, encryption, schema validation, and production configurations.

## Table of Contents

- [Advanced TOML Configuration](#advanced-toml-configuration)
- [Schema Validation System](#schema-validation-system)
- [Environment Variables and Interpolation](#environment-variables-and-interpolation)
- [Encryption and Security](#encryption-and-security)
- [Hierarchical Configuration](#hierarchical-configuration)
- [Auto-Reload and File Watching](#auto-reload-and-file-watching)
- [Production Patterns](#production-patterns)
- [Integration Examples](#integration-examples)
- [Performance and Optimization](#performance-and-optimization)
- [Advanced Use Cases](#advanced-use-cases)

---

## Advanced TOML Configuration

### Complex Data Structures

**What this example demonstrates:** How to structure comprehensive application configuration using TOML's advanced features like arrays, inline tables, arrays of tables, and deeply nested sections. This pattern is ideal for enterprise applications that need to manage multiple databases, complex API configurations, and feature flags all in one organized file.

**Key concepts to notice:**
- Arrays for simple lists (`supported_languages`, `allowed_ips`)
- Inline tables for compact related settings (`database_primary`, `database_replica`)
- Arrays of tables (`[[databases]]`) for multiple similar configurations
- Deep nesting for logical grouping (`[api.authentication]`, `[logging.handlers]`)

TOML supports sophisticated configuration structures:

```toml
# app.toml - Complex configuration example

# Basic values
app_name = "Enterprise Application"
version = "2.1.0"
debug = false

# Arrays
supported_languages = ["en", "es", "fr", "de"]
allowed_ips = ["192.168.1.0/24", "10.0.0.0/8"]

# Inline tables
database_primary = { host = "db1.example.com", port = 5432, ssl = true }
database_replica = { host = "db2.example.com", port = 5432, ssl = true }

# Arrays of tables (multiple database connections)
[[databases]]
name = "primary"
host = "db-primary.example.com"
port = 5432
read_only = false
pool_size = 20

[[databases]]
name = "analytics"
host = "db-analytics.example.com"
port = 5432
read_only = true
pool_size = 5

[[databases]]
name = "cache"
host = "redis.example.com"
port = 6379
driver = "redis"

# Nested configuration sections
[api]
base_url = "https://api.example.com/v2"
timeout = 30.0

[api.authentication]
method = "oauth2"
client_id = "${OAUTH_CLIENT_ID}"
client_secret = "encrypted:FERNET:gAAAAABhZ2I..."

[api.rate_limiting]
enabled = true
requests_per_minute = 1000
burst_limit = 100

# Logging configuration
[logging]
level = "INFO"
format = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

[logging.handlers]
console = { class = "StreamHandler", level = "INFO" }
file = { class = "RotatingFileHandler", filename = "app.log", maxBytes = 10485760, backupCount = 5 }

# Feature flags
[features]
enable_analytics = true
enable_caching = true
experimental_ui = false
beta_features = ["advanced_search", "real_time_notifications"]
```

### Multi-line Strings and Raw Values

**What this example demonstrates:** How to handle complex string values like SQL queries, certificates, and configuration strings that span multiple lines or contain special characters. This is essential for database schemas, SSL certificates, regex patterns, and any configuration that needs to preserve exact formatting.

**Key concepts to notice:**
- Triple quotes (`"""`) for multi-line strings with escaping
- Triple single quotes (`'''`) for literal strings (no escaping needed)
- Perfect for SQL DDL, certificates, regex patterns, and connection strings

```toml
[database]
# Multi-line basic string
connection_string = """
postgresql://user:password@host:5432/database?
sslmode=require&
pool_max_conns=20&
pool_min_conns=5
"""

# Multi-line literal string (no escaping)
schema_sql = '''
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
'''

[security]
# Raw regex pattern (literal string)
password_pattern = '''(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}'''

# Multi-line certificate
ssl_certificate = """-----BEGIN CERTIFICATE-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAuGbKcHmUFa8QCf1nUHuM...
-----END CERTIFICATE-----"""
```

### Using Configuration

**What this example demonstrates:** How to programmatically access the complex TOML structures from the previous examples. Shows the different data access patterns for various TOML constructs and proper type conversion practices.

**Key concepts to notice:**
- Type-safe access with `type=bool`, `type=int`, etc.
- Dot notation for nested values (`api.authentication.method`)
- How arrays of tables become Python lists of dictionaries
- String processing for multi-line values (`.strip()`)

```python
from xlibrary.config import ConfigManager

config = ConfigManager("app.toml")

# Access complex structures
app_info = {
    'name': config.get("app_name"),
    'version': config.get("version"),
    'debug': config.get("debug", type=bool)
}

# Access arrays
languages = config.get("supported_languages", type=list)
allowed_ips = config.get("allowed_ips", type=list)

# Access inline tables
primary_db = config.get("database_primary", type=dict)
print(f"Primary DB: {primary_db['host']}:{primary_db['port']}")

# Access arrays of tables
databases = config.get("databases", type=list)
for db in databases:
    print(f"Database '{db['name']}': {db['host']}:{db['port']} (RO: {db.get('read_only', False)})")

# Access nested configurations
api_auth = config.get("api.authentication.method")
rate_limit = config.get("api.rate_limiting.requests_per_minute", type=int)

# Multi-line strings
connection_string = config.get("database.connection_string").strip()
ssl_cert = config.get("security.ssl_certificate")
```

---

## Schema Validation System

### Comprehensive Schema Definition

**What this example demonstrates:** How to build enterprise-grade configuration validation using schemas. This ensures your application never starts with invalid configuration, provides helpful error messages, and documents exactly what configuration values are expected.

**Key concepts to notice:**
- `required()` vs `optional()` fields with defaults
- Validation chains using `|` operator (`required(str) | pattern(r"regex")`)
- Range checking for numeric values (`range_check(1, 65535)`)
- Choice validation for enums (`choice(["basic", "oauth2", "jwt"])`)
- Wildcard patterns for dynamic sections (`"*"` for handler names)
- Custom validators for complex business logic

```python
from xlibrary.config import (
    ConfigManager, Schema, required, optional,
    range_check, pattern, choice, ValidationError
)

# Define comprehensive schema
app_schema = Schema({
    # Basic application settings
    "app_name": required(str) | pattern(r"^[a-zA-Z0-9_\s-]+$"),
    "version": required(str) | pattern(r"^\d+\.\d+\.\d+(-\w+)?$"),
    "debug": optional(bool, default=False),
    "supported_languages": optional(list, default=["en"]),

    # Database configuration
    "databases": required(list),  # Array of tables
    "database_primary": required(dict),  # Inline table

    # Nested configurations with validation
    "api": {
        "base_url": required(str) | pattern(r"^https?://"),
        "timeout": optional(float, default=30.0) | range_check(1.0, 300.0),

        "authentication": {
            "method": required(str) | choice(["basic", "oauth2", "jwt", "api_key"]),
            "client_id": required(str) | pattern(r"^[a-zA-Z0-9_-]+$"),
            "client_secret": required(str)  # Can be encrypted
        },

        "rate_limiting": {
            "enabled": optional(bool, default=True),
            "requests_per_minute": optional(int, default=1000) | range_check(1, 10000),
            "burst_limit": optional(int, default=100) | range_check(1, 1000)
        }
    },

    # Logging configuration
    "logging": {
        "level": optional(str, default="INFO") | choice(["DEBUG", "INFO", "WARNING", "ERROR"]),
        "format": optional(str, default="%(levelname)s: %(message)s"),

        "handlers": {
            "*": {  # Wildcard for dynamic handler names
                "class": required(str),
                "level": optional(str, default="INFO"),
                "filename": optional(str),
                "maxBytes": optional(int, default=10485760) | range_check(1024, 1073741824),
                "backupCount": optional(int, default=5) | range_check(1, 100)
            }
        }
    },

    # Feature flags with validation
    "features": {
        "enable_analytics": optional(bool, default=True),
        "enable_caching": optional(bool, default=True),
        "experimental_ui": optional(bool, default=False),
        "beta_features": optional(list, default=[])
    }
})

# Custom validators for complex logic
def validate_database_consistency(data):
    """Custom validator for database configuration consistency"""
    databases = data.get("databases", [])
    primary_db = data.get("database_primary", {})

    # Ensure primary database is defined in databases array
    primary_names = [db["name"] for db in databases if not db.get("read_only", False)]

    if not primary_names:
        return ValidationError("At least one non-read-only database must be defined")

    return None

# Add custom validator to schema
app_schema.add_custom_validator(validate_database_consistency)

# Use schema with configuration
try:
    config = ConfigManager("app.toml", schema=app_schema)
    print("✅ Configuration validation passed")

    # Access validated configuration
    app_name = config.get("app_name")  # Guaranteed to be valid string
    timeout = config.get("api.timeout", type=float)  # Guaranteed to be in range

except ValidationError as e:
    print("❌ Configuration validation failed:")
    for error in e.errors:
        print(f"  - {error.path}: {error.message}")
        if error.suggestion:
            print(f"    💡 {error.suggestion}")
```

### Advanced Validation Patterns

**What this example demonstrates:** How to create custom validators for domain-specific validation logic that goes beyond basic type checking. This shows building reusable validator classes that can validate database URLs, IP addresses, and other complex data types.

**Key concepts to notice:**
- Custom `Validator` classes with domain-specific logic
- Detailed error messages with helpful suggestions
- Validation of lists vs single values
- Using external libraries (like `ipaddress`) in validators
- Composable validators that can be reused across schemas

```python
from xlibrary.config import Schema, Validator

class DatabaseConnectionValidator(Validator):
    """Custom validator for database connection strings"""

    def validate(self, value, path=""):
        if not isinstance(value, str):
            return ValidationError(f"Database connection string must be string at '{path}'")

        # Check for required components
        if not value.startswith(("postgresql://", "mysql://", "sqlite:///")):
            return ValidationError(
                f"Unsupported database URL scheme at '{path}'",
                suggestion="Use postgresql://, mysql://, or sqlite:/// URL schemes"
            )

        return ValidationResult.success(value)

class IPAddressValidator(Validator):
    """Validates IP addresses and CIDR blocks"""

    def validate(self, value, path=""):
        import ipaddress

        if isinstance(value, list):
            # Validate list of IP addresses/ranges
            for i, ip in enumerate(value):
                try:
                    ipaddress.ip_network(ip, strict=False)
                except ValueError as e:
                    return ValidationError(
                        f"Invalid IP address/range '{ip}' at '{path}[{i}]': {e}",
                        suggestion="Use valid IP addresses or CIDR notation (e.g., '192.168.1.0/24')"
                    )
        else:
            try:
                ipaddress.ip_network(value, strict=False)
            except ValueError as e:
                return ValidationError(
                    f"Invalid IP address/range at '{path}': {e}",
                    suggestion="Use valid IP address or CIDR notation"
                )

        return ValidationResult.success(value)

# Use custom validators in schema
network_schema = Schema({
    "database": {
        "connection_string": required(str) | DatabaseConnectionValidator(),
    },
    "security": {
        "allowed_ips": required(list) | IPAddressValidator(),
        "blocked_ips": optional(list, default=[]) | IPAddressValidator()
    }
})

config = ConfigManager("network.toml", schema=network_schema)
```

---

## Environment Variables and Interpolation

### Advanced Variable Interpolation

**What this example demonstrates:** The powerful interpolation system that allows you to create dynamic configuration values using environment variables, other config values, function calls, and conditional logic. This addresses your specific need for root folder interpolation across multiple paths.

**Key concepts to notice:**
- `${ENV_VAR:default}` syntax for environment variables with fallbacks
- `${config.path}` for referencing other config values (perfect for your root folder use case!)
- Function calls like `${uuid()}`, `${now()}`, `${hostname()}`
- Conditional variables `${if:condition:true_value:false_value}`
- Math operations `${multiply:${cpu_count()}:2}`
- File content interpolation `${file:path/to/file}`

```toml
# Environment variables with defaults and transformations
[database]
host = "${DB_HOST:localhost}"
port = "${DB_PORT:5432}"
name = "${APP_NAME}_${ENVIRONMENT:development}"
url = "postgresql://${database.host}:${database.port}/${database.name}"

# Function calls in variables
[application]
instance_id = "${uuid()}"
startup_time = "${now()}"
hostname = "${hostname()}"
secret_key = "${base64_encode:${APP_SECRET_KEY:default-secret}}"

# Conditional variables
[features]
debug_mode = "${if:DEVELOPMENT:true:false}"
log_level = "${switch:ENVIRONMENT:development=DEBUG,staging=INFO,production=WARN:INFO}"

# Math operations
[performance]
worker_count = "${multiply:${cpu_count()}:2}"
memory_limit = "${add:${BASE_MEMORY:512}:${EXTRA_MEMORY:0}}"

# File content interpolation
[security]
ssl_certificate = "${file:certs/server.crt}"
private_key = "${file:certs/server.key}"
```

```python
from xlibrary.config import ConfigManager, EnvironmentResolver, FunctionResolver

# Create config with custom resolvers
config = ConfigManager("app.toml")

# Register custom function resolver with additional functions
function_resolver = FunctionResolver()
function_resolver.register_function("cpu_count", lambda: os.cpu_count())
function_resolver.register_function("multiply", lambda x, y: int(x) * int(y))
function_resolver.register_function("add", lambda x, y: int(x) + int(y))
function_resolver.register_function("file", lambda path: open(path).read().strip())

config.add_resolver(function_resolver)

# Access interpolated values
instance_id = config.get("application.instance_id")  # UUID
startup_time = config.get("application.startup_time")  # ISO timestamp
worker_count = config.get("performance.worker_count", type=int)  # CPU cores * 2
```

### Environment-Specific Configurations

**What this example demonstrates:** How to manage different configuration values across development, staging, and production environments using multiple TOML files that layer and merge together. This solves the problem of having one configuration that adapts to different deployment environments.

**Key concepts to notice:**
- Base configuration with common settings
- Environment-specific files that override base settings
- Hierarchical merging where later files take precedence
- Environment variable interpolation for production secrets
- Debug vs production feature toggles

```toml
# base.toml
app_name = "MyApp"
version = "1.0.0"

[database]
timeout = 30.0
pool_size = 5

[logging]
format = "%(asctime)s - %(levelname)s - %(message)s"

[features]
analytics = true

# development.toml
debug = true

[database]
host = "localhost"
name = "myapp_dev"

[logging]
level = "DEBUG"

[features]
debug_toolbar = true

# staging.toml
debug = false

[database]
host = "${STAGING_DB_HOST}"
name = "myapp_staging"

[logging]
level = "INFO"

# production.toml
debug = false

[database]
host = "${PROD_DB_HOST}"
name = "myapp_prod"
pool_size = 20

[logging]
level = "WARN"
file = "/var/log/myapp.log"

[features]
analytics = true
performance_monitoring = true
```

**What this code demonstrates:** A practical implementation of automatic environment detection and configuration file selection. This class automatically loads the right configuration files based on environment indicators, eliminating the need to manually specify environment settings.

**Key concepts to notice:**
- Automatic environment detection from multiple sources
- Dynamic config file selection based on environment
- File existence checking before loading configs
- Hierarchical loading: base → environment → local overrides

```python
import os
from xlibrary.config import ConfigManager

class EnvironmentConfigManager:
    """Environment-aware configuration manager"""

    def __init__(self, base_config="base.toml"):
        self.environment = self._detect_environment()

        config_files = [base_config]

        # Add environment-specific config if it exists
        env_config = f"{self.environment}.toml"
        if Path(env_config).exists():
            config_files.append(env_config)

        # Add local overrides if they exist
        local_config = "local.toml"
        if Path(local_config).exists():
            config_files.append(local_config)

        self.config = ConfigManager(config_files)

    def _detect_environment(self):
        """Detect current environment"""
        # Check explicit environment variable
        env = os.getenv("ENVIRONMENT") or os.getenv("ENV") or os.getenv("APP_ENV")
        if env:
            return env

        # Check for environment indicators
        if os.getenv("DEVELOPMENT") or Path(".env.development").exists():
            return "development"
        elif os.getenv("STAGING"):
            return "staging"
        elif os.getenv("PRODUCTION"):
            return "production"

        return "development"  # Default

    def get(self, key, **kwargs):
        """Get configuration value"""
        return self.config.get(key, **kwargs)

    def get_environment(self):
        """Get current environment"""
        return self.environment

# Usage
config_manager = EnvironmentConfigManager()
print(f"Environment: {config_manager.get_environment()}")
print(f"Debug mode: {config_manager.get('debug', type=bool, default=False)}")
print(f"Database: {config_manager.get('database.host')}")
```

---

## Encryption and Security

### Setting Up Encryption

**What this example demonstrates:** Three different approaches to providing encryption keys for sensitive configuration values. This shows how to securely handle API keys, passwords, and other secrets in configuration files.

**Key concepts to notice:**
- Environment variable approach for containerized deployments
- Key derivation from application name and user phrase
- File-based key storage for server deployments
- The encryption key is separate from the config file for security

```python
import os
from xlibrary.config import ConfigManager, derive_app_key

# Method 1: Use environment variable for encryption key
os.environ['CONFIG_ENCRYPTION_KEY'] = 'your-base64-encoded-32-byte-key'

config = ConfigManager(
    "app.toml",
    encryption_key=os.getenv('CONFIG_ENCRYPTION_KEY')
)

# Method 2: Derive key from application name
encryption_key = derive_app_key("myapp", user_key="my-secret-phrase")
config = ConfigManager("app.toml", encryption_key=encryption_key)

# Method 3: Use key file
with open("config.key", "rb") as key_file:
    encryption_key = key_file.read()

config = ConfigManager("app.toml", encryption_key=encryption_key)
```

### Encrypting Configuration Values

**What this example demonstrates:** How to encrypt sensitive values before putting them in configuration files. This shows the encryption process that converts plain text secrets into encrypted strings that are safe to store in version control.

**Key concepts to notice:**
- The `ConfigEncryption` class handles the encryption process
- Encrypted values have a specific format: `encrypted:FERNET:base64data`
- Original values are completely obscured in the config file
- Only someone with the encryption key can decrypt the values

```python
from xlibrary.config import ConfigEncryption
import os

# Create encryption instance
encryption_key = os.getenv('CONFIG_ENCRYPTION_KEY')
encryptor = ConfigEncryption(encryption_key)

# Encrypt sensitive values
api_secret = "super-secret-api-key"
encrypted_secret = encryptor.encrypt_value(api_secret)
print(f"Encrypted: {encrypted_secret}")
# Output: encrypted:FERNET:gAAAAABhZ2I...

database_password = "very-secret-password"
encrypted_password = encryptor.encrypt_value(database_password)
print(f"Encrypted: {encrypted_password}")
```

### Using Encrypted Configuration

**What this example demonstrates:** How encrypted configuration values look in TOML files and how they're transparently decrypted when accessed. Notice how sensitive values are stored as encrypted strings but accessed as plain text by your application.

**Key concepts to notice:**
- Mixed plain text and encrypted values in the same file
- The `encrypted:FERNET:` prefix identifies encrypted values
- Different services can have different encrypted values
- Public values (like client IDs) remain in plain text

```toml
# secure.toml
[api]
public_key = "pk_1234567890"
secret_key = "encrypted:FERNET:gAAAAABhZ2IwA..."

[database]
username = "myapp_user"
password = "encrypted:FERNET:gAAAAABhZ2IwB..."

[services]
stripe_secret = "encrypted:FERNET:gAAAAABhZ2IwC..."
sendgrid_api_key = "encrypted:FERNET:gAAAAABhZ2IwD..."

# OAuth credentials
[oauth]
client_id = "oauth_client_123"
client_secret = "encrypted:FERNET:gAAAAABhZ2IwE..."
```

```python
from xlibrary.config import ConfigManager

# Load encrypted configuration
config = ConfigManager(
    "secure.toml",
    encryption_key=os.getenv('CONFIG_ENCRYPTION_KEY')
)

# Values are automatically decrypted when accessed
api_secret = config.get("api.secret_key")  # Returns decrypted value
db_password = config.get("database.password")  # Returns decrypted value
stripe_secret = config.get("services.stripe_secret")  # Returns decrypted value

# Use decrypted values
print(f"API Secret: {api_secret[:10]}...")  # Show first 10 chars for verification
```

### Bulk Encryption Tool

```python
#!/usr/bin/env python3
"""Tool to encrypt configuration values in bulk"""

import sys
from pathlib import Path
from xlibrary.config import ConfigManager, ConfigEncryption

def encrypt_config_values(config_file, encryption_key, sensitive_keys):
    """Encrypt specified keys in configuration file"""

    # Load configuration
    config = ConfigManager(config_file)
    encryptor = ConfigEncryption(encryption_key)

    # Get raw config data
    data = config._data.copy()

    # Encrypt sensitive keys
    for key_path in sensitive_keys:
        try:
            current_value = config.get(key_path)
            if current_value and not encryptor._is_encrypted(current_value):
                encrypted_value = encryptor.encrypt_value(str(current_value))

                # Update value in data structure
                keys = key_path.split('.')
                current_dict = data
                for key in keys[:-1]:
                    current_dict = current_dict[key]
                current_dict[keys[-1]] = encrypted_value

                print(f"✅ Encrypted: {key_path}")
            else:
                print(f"⏭️  Skipped: {key_path} (already encrypted or empty)")

        except Exception as e:
            print(f"❌ Failed to encrypt {key_path}: {e}")

    return data

def main():
    if len(sys.argv) < 2:
        print("Usage: python encrypt_config.py config.toml")
        sys.exit(1)

    config_file = sys.argv[1]

    # Sensitive keys to encrypt
    sensitive_keys = [
        "api.secret_key",
        "database.password",
        "services.stripe_secret",
        "services.sendgrid_api_key",
        "oauth.client_secret"
    ]

    encryption_key = input("Enter encryption key (or press Enter to generate): ").strip()
    if not encryption_key:
        from xlibrary.config import derive_app_key
        encryption_key = derive_app_key("myapp")
        print(f"Generated encryption key: {encryption_key.decode()}")

    # Encrypt values
    encrypted_data = encrypt_config_values(config_file, encryption_key, sensitive_keys)

    # Write back to file
    backup_file = f"{config_file}.backup"
    Path(config_file).rename(backup_file)
    print(f"📄 Backup created: {backup_file}")

    # Write encrypted configuration (would need TOML writer)
    print(f"✅ Encrypted configuration ready")

if __name__ == "__main__":
    main()
```

---

## Advanced Use Cases

### Configuration Factory Pattern

**What this example demonstrates:** How to create specialized configuration managers for different types of applications using the factory pattern. This addresses your question about managing multiple applications by creating standardized config templates for different app types.

**Key concepts to notice:**
- Different schemas for different application types (web app vs worker vs client)
- Consistent patterns across different config types
- Encapsulated validation logic per application type
- Easy to extend with new application types

```python
from xlibrary.config import ConfigManager, Schema, required, optional

class ConfigFactory:
    """Factory for creating different types of configurations"""

    @staticmethod
    def create_web_app_config(config_file="webapp.toml"):
        """Create configuration for web applications"""
        schema = Schema({
            "app": {
                "name": required(str),
                "host": optional(str, default="0.0.0.0"),
                "port": optional(int, default=8000) | range_check(1, 65535),
                "debug": optional(bool, default=False)
            },
            "database": {
                "url": required(str),
                "pool_size": optional(int, default=10) | range_check(1, 100)
            }
        })

        return ConfigManager(config_file, schema=schema)

    @staticmethod
    def create_worker_config(config_file="worker.toml"):
        """Create configuration for background workers"""
        schema = Schema({
            "worker": {
                "processes": optional(int, default=4) | range_check(1, 32),
                "queue_url": required(str),
                "timeout": optional(int, default=300) | range_check(1, 3600)
            },
            "logging": {
                "level": optional(str, default="INFO") | choice(["DEBUG", "INFO", "WARNING", "ERROR"])
            }
        })

        return ConfigManager(config_file, schema=schema)

    @staticmethod
    def create_api_client_config(config_file="client.toml"):
        """Create configuration for API clients"""
        schema = Schema({
            "client": {
                "base_url": required(str) | pattern(r"^https?://"),
                "timeout": optional(float, default=30.0) | range_check(0.1, 300.0),
                "retries": optional(int, default=3) | range_check(0, 10)
            },
            "auth": {
                "api_key": required(str),
                "secret": optional(str)
            }
        })

        return ConfigManager(config_file, schema=schema, auto_reload=True)

# Usage
webapp_config = ConfigFactory.create_web_app_config()
worker_config = ConfigFactory.create_worker_config()
client_config = ConfigFactory.create_api_client_config()
```

### Configuration Manager Singleton

**What this example demonstrates:** How to create a single, shared configuration instance across your entire application using the singleton pattern. This ensures all parts of your application use the same configuration and supports auto-reload when config files change.

**Key concepts to notice:**
- Thread-safe singleton implementation with locking
- Single configuration instance shared across the application
- Automatic configuration reloading capability
- Lazy initialization pattern

```python
from xlibrary.config import ConfigManager
import threading

class ConfigSingleton:
    """Thread-safe configuration singleton"""

    _instance = None
    _lock = threading.Lock()

    def __new__(cls, *args, **kwargs):
        if not cls._instance:
            with cls._lock:
                if not cls._instance:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self, config_file="app.toml"):
        if not hasattr(self, '_initialized'):
            self.config = ConfigManager(config_file, auto_reload=True)
            self._initialized = True

    def get(self, key, **kwargs):
        return self.config.get(key, **kwargs)

    def reload(self):
        """Force configuration reload"""
        return self.config.reload()

# Usage - same instance across the application
config1 = ConfigSingleton()
config2 = ConfigSingleton()  # Same instance
assert config1 is config2

app_name = config1.get("app.name")

---

## Multi-Application Configuration Patterns

### Single TOML File for Multiple Applications

**What this example demonstrates:** How to organize multiple applications in one TOML file using sections, with root folder interpolation exactly as you requested for your text-to-speech script and other projects.

**Key benefits:**
- One file to manage instead of 10+ separate config files
- Shared root paths with interpolation across all your scripts
- Easy backup and synchronization of all configuration
- Clear organization by application

```toml
# ~/.config/xlibrary/multi-app-config.toml

# Shared settings used across applications
[shared]
user_home = "${HOME}"
projects_root = "${HOME}/my_projects"
backup_root = "${HOME}/backups"

# Text-to-Speech Application
[text_to_speech]
api_key = "encrypted:FERNET:tts_key_here..."
root_folder = "${shared.projects_root}/text_to_speech"
# All these paths use the root_folder - exactly what you wanted!
input_folder = "${text_to_speech.root_folder}/input"
output_folder = "${text_to_speech.root_folder}/output"
cache_folder = "${text_to_speech.root_folder}/cache"
temp_folder = "${text_to_speech.root_folder}/temp"
models_folder = "${text_to_speech.root_folder}/models"
backup_folder = "${shared.backup_root}/text_to_speech"

[text_to_speech.settings]
voice_model = "neural-voice-v2"
sample_rate = 44100
output_format = "mp3"

# AI Processing Scripts
[ai_processor]
api_key = "encrypted:FERNET:ai_key_here..."
root_folder = "${shared.projects_root}/ai_processing"
input_folder = "${ai_processor.root_folder}/input"
output_folder = "${ai_processor.root_folder}/output"
results_folder = "${ai_processor.root_folder}/results"
models_cache = "${ai_processor.root_folder}/models"
logs_folder = "${ai_processor.root_folder}/logs"

[ai_processor.settings]
model_provider = "claude"
max_tokens = 4000
temperature = 0.7

# Video Processing Scripts
[video_processor]
root_folder = "${shared.projects_root}/video_processing"
input_folder = "${video_processor.root_folder}/input"
output_folder = "${video_processor.root_folder}/output"
thumbnails_folder = "${video_processor.root_folder}/thumbnails"
temp_folder = "${video_processor.root_folder}/temp"

[video_processor.ffmpeg]
path = "/usr/local/bin/ffmpeg"
threads = 4
quality = "high"

# Data Analysis Scripts
[data_analysis]
api_key = "encrypted:FERNET:data_key_here..."
root_folder = "${shared.projects_root}/data_analysis"
input_folder = "${data_analysis.root_folder}/input"
output_folder = "${data_analysis.root_folder}/output"
cache_folder = "${data_analysis.root_folder}/cache"
reports_folder = "${data_analysis.root_folder}/reports"

# Database connections used by multiple apps
[database]
host = "${DB_HOST:localhost}"
port = "${DB_PORT:5432}"
name = "my_projects_db"
url = "postgresql://${database.host}:${database.port}/${database.name}"
```

### Using Multi-Application Configuration

```python
from xlibrary.config import ConfigManager
from pathlib import Path

class MultiAppConfigManager:
    """Configuration manager for multiple applications"""

    def __init__(self, config_file="~/.config/xlibrary/multi-app-config.toml"):
        self.config_path = Path(config_file).expanduser()
        self.config = ConfigManager(str(self.config_path))

    def get_app_config(self, app_name):
        """Get configuration for a specific application"""
        app_config = {}

        # Get all keys for this application
        for key in self.config._data.keys():
            if key == app_name or key.startswith(f"{app_name}."):
                value = self.config.get(key)
                app_config[key] = value

        return app_config

    def get_app_folders(self, app_name):
        """Get all folder paths for an application and ensure they exist"""
        folders = {}
        app_section = self.config.get(app_name, type=dict, default={})

        for key, value in app_section.items():
            if key.endswith('_folder'):
                folder_path = Path(value).expanduser()

                # Create folder if it doesn't exist (addresses your folder creation request!)
                folder_path.mkdir(parents=True, exist_ok=True)

                folders[key] = str(folder_path)
                print(f"✅ Ensured folder exists: {folders[key]}")

        return folders

# Usage examples for your specific scripts

# Text-to-Speech Script Usage
config_manager = MultiAppConfigManager()

# Get all TTS configuration
tts_config = config_manager.get_app_config("text_to_speech")
api_key = config_manager.config.get("text_to_speech.api_key")
voice_model = config_manager.config.get("text_to_speech.settings.voice_model")

# Get and create all folders for TTS
tts_folders = config_manager.get_app_folders("text_to_speech")
input_dir = tts_folders["input_folder"]
output_dir = tts_folders["output_folder"]
cache_dir = tts_folders["cache_folder"]

print(f"TTS Input: {input_dir}")
print(f"TTS Output: {output_dir}")

# AI Processing Script Usage
ai_config = config_manager.get_app_config("ai_processor")
ai_api_key = config_manager.config.get("ai_processor.api_key")
ai_folders = config_manager.get_app_folders("ai_processor")

print(f"AI Results: {ai_folders['results_folder']}")

# Video Processing Script Usage
video_folders = config_manager.get_app_folders("video_processor")
ffmpeg_path = config_manager.config.get("video_processor.ffmpeg.path")

print(f"Video Input: {video_folders['input_folder']}")
print(f"FFmpeg: {ffmpeg_path}")
```

### Recommended Configuration File Locations

**For single shared config file (addresses your question about where to put it):**

1. **`~/.config/xlibrary/config.toml`** - XDG standard location (Linux/macOS)
2. **`~/.xlibrary.toml`** - Simple dotfile in home directory
3. **`~/Documents/xlibrary-config.toml`** - Easy to remember location
4. **Project-specific:** `./config/xlibrary.toml` - In your projects folder

**Setting up the config path:**

```python
from pathlib import Path
import os

def find_config_file():
    """Find configuration file in standard locations"""
    possible_locations = [
        Path("./config/xlibrary.toml"),                    # Project-specific
        Path("~/.config/xlibrary/config.toml").expanduser(),  # XDG standard
        Path("~/.xlibrary.toml").expanduser(),             # Dotfile
        Path("~/Documents/xlibrary-config.toml").expanduser(), # Documents
    ]

    for location in possible_locations:
        if location.exists():
            print(f"✅ Found config at: {location}")
            return str(location)

    # Create default location if none found
    default_location = Path("~/.config/xlibrary/config.toml").expanduser()
    default_location.parent.mkdir(parents=True, exist_ok=True)
    print(f"📄 Creating default config at: {default_location}")
    return str(default_location)

# Use in your scripts
config_file = find_config_file()
config = ConfigManager(config_file)
```

This approach solves all your concerns:
- ✅ **One file for all applications** instead of 10+ separate files
- ✅ **Root folder interpolation** across multiple paths
- ✅ **Automatic folder creation** when accessing folder configs
- ✅ **Standard location** that's easy to remember and backup
- ✅ **Encrypted API keys** for different applications
- ✅ **Shared settings** across applications
```

**This comprehensive guide covers all major features of the Config Manager. You're now equipped to handle any configuration management scenario!** ⚙️

---

## Next Steps

- **[Chapter 3: Download Manager](03.01%20Chapter%203%20-%20Download%20Manager%20-%20Design%20-%20Overview.md)** - Advanced download capabilities
- **[Chapter 1: AI Manager](01.01%20Chapter%201%20-%20AI%20Manager%20-%20Design%20-%20Overview.md)** - AI provider abstraction
- **[Chapter 0: Introduction](00.00%20Chapter%200%20-%20Introduction.md)** - Library overview and architecture