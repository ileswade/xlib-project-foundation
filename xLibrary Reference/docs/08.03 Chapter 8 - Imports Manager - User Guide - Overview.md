# Chapter 8: Imports Manager - User Guide - Overview

> **ðŸ”„ QUICK START GUIDE**
> Get up and running with xlibrary's Imports Manager in 5 minutes. Master intelligent dependency resolution, security scanning, and enterprise package management with practical examples.

## Quick Setup

### 5-Minute Start

```bash
# Install with imports management
pip install xlibrary[imports]

# Verify installation
python -c "from xlibrary.imports import ImportManager; print('Ready!')"
```

### Basic Configuration

```python
from xlibrary.imports import ImportManager

# Simple setup
im = ImportManager()

# Enterprise setup
im = ImportManager({
    "security_level": "high",
    "corporate_registry": "https://pypi.company.com",
    "auto_install": False,
    "cache_enabled": True
})
```

---

## Essential Operations

### 1. Smart Import Management

**Dynamic imports with automatic dependency resolution:**

```python
from xlibrary.imports import ImportManager

im = ImportManager()

# Smart import - installs if missing
pandas = im.smart_import("pandas", min_version="1.5.0")
df = pandas.DataFrame({"a": [1, 2, 3]})

# Conditional imports
ml_backend = im.conditional_import({
    "cuda_available": "torch[cuda]>=2.0.0",
    "cpu_only": "torch>=2.0.0"
})

# Lazy imports - load only when accessed
numpy_lazy = im.lazy_import("numpy", ["array", "zeros"])
# numpy not loaded yet...
arr = numpy_lazy.array([1, 2, 3])  # Now numpy loads
```

### 2. Secure Package Installation

**Enterprise-grade security scanning:**

```python
# Security-first installation
result = im.install_package_secure(
    "requests>=2.28.0",
    scan_vulnerabilities=True,
    check_licenses=True,
    verify_signatures=True
)

if result.security_approved:
    import requests
    print("Package safely installed!")
else:
    print(f"Security issues: {result.security_issues}")

# Batch secure installation
packages = ["pandas>=1.5.0", "numpy>=1.20.0", "matplotlib>=3.5.0"]
results = im.batch_install_secure(
    packages,
    scan_all=True,
    progress_callback=lambda pkg, status: print(f"{pkg}: {status}")
)
```

### 3. Dependency Resolution

**Intelligent conflict resolution:**

```python
# Resolve complex dependencies
requirements = [
    "django>=4.0.0",
    "djangorestframework>=3.14.0",
    "celery>=5.2.0"
]

resolver = im.get_resolver()
resolution = resolver.resolve_dependencies(
    requirements,
    strategy="conservative",  # conservative, aggressive, latest
    allow_prereleases=False
)

if resolution.success:
    for package in resolution.install_order:
        print(f"Install {package.name}=={package.version}")
else:
    print(f"Conflicts: {resolution.conflicts}")
    # Get suggested resolutions
    for conflict in resolution.conflicts:
        print(f"Suggestion: {conflict.resolution_strategy}")
```

### 4. Package Discovery

**Automated requirements management:**

```python
# Auto-discover missing imports in your project
discovery = im.get_discovery_manager()

missing_imports = discovery.discover_missing_imports("./src")
for missing in missing_imports:
    print(f"Missing: {missing['import']} in {missing['file']}")
    print(f"Install: pip install {missing['suggestions'][0]}")

# Auto-generate requirements.txt
requirements = discovery.auto_generate_requirements("./project")
with open("requirements.txt", "w") as f:
    f.write(requirements["content"])

print(f"Generated {len(requirements['requirements'])} requirements")
```

---

## Common Use Cases

### Development Workflow

**Streamlined development experience:**

```python
# Enable development helpers
im.enable_import_suggestions(True)
im.enable_auto_fix(True)

# Development project setup
def setup_dev_environment(project_path: str):
    """Setup development environment with proper dependencies."""

    # Analyze project
    analysis = im.analyze_project(project_path)
    print(f"Found {len(analysis.imports)} imports")
    print(f"Missing {len(analysis.missing)} packages")

    # Install missing packages
    if analysis.missing:
        print("Installing missing packages...")
        for package in analysis.missing:
            im.install_package_safe(package.suggestion)

    # Check for updates
    updates = im.check_for_updates(analysis.installed)
    if updates:
        print(f"{len(updates)} packages can be updated")
        im.batch_update(updates, confirm=True)

    # Generate lock file
    im.create_lock_file(
        f"{project_path}/requirements.lock",
        include_hashes=True
    )

    print("Development environment ready!")

# Usage
setup_dev_environment("./my_project")
```

### CI/CD Integration

**Automated dependency management in pipelines:**

```python
# CI/CD pipeline integration
def ci_dependency_check():
    """Check dependencies in CI/CD pipeline."""

    # Verify all dependencies are secure
    security_report = im.security_scan_all()

    if security_report.critical_vulnerabilities:
        print("CRITICAL: Security vulnerabilities found!")
        for vuln in security_report.critical_vulnerabilities:
            print(f"  {vuln.package}: {vuln.vulnerability_id}")
        sys.exit(1)

    # Check license compliance
    license_report = im.check_license_compliance()
    if not license_report.all_compliant:
        print("WARNING: License compliance issues")
        for issue in license_report.issues:
            print(f"  {issue.package}: {issue.license} not approved")

    # Verify reproducible build
    lock_file_valid = im.verify_lock_file("requirements.lock")
    if not lock_file_valid:
        print("ERROR: Lock file is out of sync")
        sys.exit(1)

    print("All dependency checks passed!")

# Add to your CI script
if __name__ == "__main__":
    ci_dependency_check()
```

### Enterprise Usage

**Corporate policy compliance:**

```python
# Enterprise configuration
enterprise_config = {
    "corporate_registry": "https://pypi.company.com",
    "security_policies": {
        "require_approval_for": ["machine_learning", "database"],
        "blocked_licenses": ["GPL", "AGPL"],
        "max_vulnerabilities": {"critical": 0, "high": 0}
    },
    "approval_workflow": True
}

enterprise_im = ImportManager(enterprise_config)

# Request package approval
approval_request = enterprise_im.request_approval(
    "tensorflow>=2.10.0",
    justification="Machine learning model training",
    project="customer_analytics"
)

print(f"Approval request ID: {approval_request.request_id}")
print(f"Status: {approval_request.status}")

# Check approval status
status = enterprise_im.check_approval_status(approval_request.request_id)
if status.approved:
    enterprise_im.install_approved_package(approval_request.request_id)
```

---

## Performance Optimization

### Lazy Loading

**Optimize startup time with lazy imports:**

```python
# Create lazy import proxies
numpy_lazy = im.lazy_import("numpy")
pandas_lazy = im.lazy_import("pandas", ["DataFrame", "Series"])
sklearn_lazy = im.lazy_import("sklearn.ensemble", ["RandomForestClassifier"])

# Modules are not loaded yet - fast startup
print("Application started quickly!")

# Load only when needed
def run_analysis():
    # Now numpy loads
    arr = numpy_lazy.array([1, 2, 3, 4, 5])

    # Now pandas loads
    df = pandas_lazy.DataFrame({"values": arr})

    # Now sklearn loads
    model = sklearn_lazy.RandomForestClassifier()

    return model.fit(arr.reshape(-1, 1), [0, 1, 0, 1, 0])

# Only loads what you actually use
result = run_analysis()
```

### Caching

**Intelligent caching for better performance:**

```python
# Enable advanced caching
im = ImportManager({
    "cache_enabled": True,
    "cache_size_mb": 500,
    "cache_compression": True,
    "smart_preloading": True
})

# Preload commonly used packages
common_packages = ["requests", "json", "os", "sys", "pathlib"]
im.preload_packages(common_packages)

# Cache warming for project
im.warm_cache_for_project("./src")

# Performance monitoring
perf_stats = im.get_performance_stats()
print(f"Cache hit rate: {perf_stats.cache_hit_rate:.2%}")
print(f"Average import time: {perf_stats.avg_import_time:.3f}s")
```

### Batch Operations

**Process multiple packages efficiently:**

```python
# Batch processing
package_list = [
    "requests>=2.28.0",
    "pandas>=1.5.0",
    "numpy>=1.20.0",
    "matplotlib>=3.5.0",
    "seaborn>=0.11.0"
]

# Parallel installation
results = im.batch_install_parallel(
    package_list,
    max_workers=4,
    progress_callback=lambda pkg, progress: print(f"{pkg}: {progress}%")
)

# Check results
successful = [r for r in results if r.success]
failed = [r for r in results if not r.success]

print(f"Installed: {len(successful)}, Failed: {len(failed)}")
```

---

## Security Best Practices

### Vulnerability Scanning

**Comprehensive security analysis:**

```python
# Enable comprehensive security scanning
security_config = {
    "vulnerability_databases": ["osv", "safety", "snyk"],
    "malware_detection": True,
    "license_compliance": True,
    "code_analysis": True
}

im = ImportManager({"security": security_config})

# Scan specific package
scan_result = im.security_scan("requests==2.28.0")
print(f"Security score: {scan_result.security_score}/10")
print(f"Vulnerabilities: {len(scan_result.vulnerabilities)}")

# Continuous monitoring
im.enable_continuous_monitoring(
    scan_interval_hours=24,
    alert_on_new_vulnerabilities=True,
    email_alerts="security@company.com"
)
```

### Safe Installation

**Multi-layer security verification:**

```python
def install_with_verification(package_spec: str):
    """Install package with comprehensive security verification."""

    # Step 1: Pre-installation security scan
    security_scan = im.security_scan(package_spec)
    if security_scan.risk_level == "high":
        print(f"High security risk detected: {security_scan.risks}")
        return False

    # Step 2: License compliance check
    license_check = im.check_license(package_spec)
    if not license_check.approved:
        print(f"License not approved: {license_check.license}")
        return False

    # Step 3: Dependency analysis
    deps = im.analyze_dependencies(package_spec)
    suspicious_deps = [d for d in deps if d.risk_score > 7]
    if suspicious_deps:
        print(f"Suspicious dependencies: {[d.name for d in suspicious_deps]}")
        confirm = input("Continue? (y/N): ")
        if confirm.lower() != 'y':
            return False

    # Step 4: Install in isolated environment first
    with im.isolated_environment() as env:
        test_result = env.test_install(package_spec)
        if not test_result.success:
            print(f"Test installation failed: {test_result.error}")
            return False

    # Step 5: Final installation
    result = im.install_package(package_spec)
    return result.success

# Usage
success = install_with_verification("new-package>=1.0.0")
```

---

## Troubleshooting Guide

### Common Issues

**Quick solutions to frequent problems:**

```python
# Import troubleshooter
troubleshooter = im.get_troubleshooter()

try:
    import some_problematic_module
except ImportError as e:
    # Diagnose the issue
    diagnosis = troubleshooter.diagnose_import_error(
        module_name="some_problematic_module",
        error=e
    )

    print(f"Issue: {diagnosis.problem_type}")
    print(f"Solution: {diagnosis.recommended_solution}")

    # Auto-fix if possible
    if diagnosis.auto_fixable:
        print("Attempting auto-fix...")
        fix_result = troubleshooter.auto_fix(diagnosis)
        if fix_result.success:
            import some_problematic_module  # Try again
```

### Dependency Conflicts

**Resolve version conflicts:**

```python
# Conflict resolution
try:
    resolver = im.get_resolver()
    result = resolver.resolve_dependencies([
        "package-a>=1.0.0",
        "package-b>=2.0.0"  # Conflicts with package-a
    ])
except DependencyConflictError as e:
    print(f"Conflict detected: {e}")

    # Get resolution suggestions
    suggestions = resolver.get_conflict_resolutions(e.conflicts)

    for suggestion in suggestions:
        print(f"Option: {suggestion.description}")
        print(f"Changes: {suggestion.required_changes}")

        # Apply suggested resolution
        if input("Apply this solution? (y/N): ").lower() == 'y':
            resolver.apply_resolution(suggestion)
            break
```

### Performance Issues

**Optimize import performance:**

```python
# Performance analysis
analyzer = im.get_performance_analyzer()

# Analyze slow imports
slow_imports = analyzer.find_slow_imports(
    threshold_seconds=1.0,
    project_path="./src"
)

for slow_import in slow_imports:
    print(f"{slow_import.module}: {slow_import.load_time:.2f}s")
    print(f"Suggestions: {slow_import.optimization_suggestions}")

# Apply optimizations
optimizer = im.get_optimizer()
optimization_plan = optimizer.create_optimization_plan(slow_imports)

print(f"Estimated improvement: {optimization_plan.estimated_speedup:.1f}x")
optimizer.apply_optimizations(optimization_plan)
```

---

## Environment Management

### Virtual Environments

**Advanced environment isolation:**

```python
# Create project-specific environment
env_manager = im.get_environment_manager()

# Setup isolated environment
with env_manager.create_environment("ml_project") as env:
    # Install packages in isolation
    env.install("tensorflow>=2.10.0")
    env.install("scikit-learn>=1.0.0")

    # Import within environment
    tf = env.import_module("tensorflow")
    sklearn = env.import_module("sklearn")

    # Environment is automatically cleaned up

# Persistent environments
env = env_manager.create_persistent_environment(
    "data_science",
    requirements=["pandas", "numpy", "matplotlib", "jupyter"]
)

# Activate environment for current session
env_manager.activate(env)
```

### Containerized Imports

**Docker-based isolation:**

```python
# Container-based import isolation
container_manager = im.get_container_manager()

# Import from container
with container_manager.create_container("python:3.11-slim") as container:
    # Install in container
    container.install_package("scipy>=1.9.0")

    # Import from container
    scipy = container.import_module("scipy")

    # Use as normal
    result = scipy.optimize.minimize(lambda x: x**2, [1.0])
    print(f"Optimization result: {result.x}")
```

---

## Integration Examples

### FastAPI Project

**Web application dependency management:**

```python
from fastapi import FastAPI
from xlibrary.imports import ImportManager

# Configure for web application
web_im = ImportManager({
    "lazy_loading": True,    # Fast startup
    "security_level": "high", # Web security
    "cache_enabled": True     # Performance
})

app = FastAPI()

# Lazy load heavy dependencies
ml_models = web_im.lazy_import("my_ml_models")
database = web_im.lazy_import("sqlalchemy")

@app.get("/predict")
async def predict(data: dict):
    # ML model loads only when endpoint is called
    model = ml_models.get_prediction_model()
    return {"prediction": model.predict(data)}

@app.get("/data")
async def get_data():
    # Database loads only when needed
    db = database.create_engine("sqlite:///data.db")
    # ... database operations
```

### Data Science Notebook

**Jupyter notebook optimization:**

```python
# Notebook-optimized import manager
notebook_im = ImportManager({
    "interactive_mode": True,
    "auto_reload": True,
    "memory_optimization": True
})

# Smart imports for data science
pandas = notebook_im.smart_import("pandas", alias="pd")
numpy = notebook_im.smart_import("numpy", alias="np")
matplotlib = notebook_im.smart_import("matplotlib.pyplot", alias="plt")

# Auto-install missing packages in notebook
def safe_import(package, **kwargs):
    try:
        return notebook_im.smart_import(package, **kwargs)
    except ImportError:
        print(f"Installing {package}...")
        notebook_im.install_package(package)
        return notebook_im.smart_import(package, **kwargs)

# Usage in notebook cells
seaborn = safe_import("seaborn", alias="sns")
plotly = safe_import("plotly.express", alias="px")
```

---

## Next Steps

Ready to dive deeper? Continue with:

- **[Detailed User Guide](08.04%20Chapter%208%20-%20Imports%20Manager%20-%20User%20Guide%20-%20Detailed.md)** - Advanced workflows, enterprise patterns, and complex scenarios
- **[Chapter 9: Pipeline Manager](09.01%20Chapter%209%20-%20Pipeline%20Manager%20-%20Design%20-%20Overview.md)** - Data processing pipelines and workflow orchestration
- **[Chapter 10: CLI Framework](10.01%20Chapter%2010%20-%20CLI%20Framework%20-%20Design%20-%20Overview.md)** - Command-line interface development

**You now have the essential tools to manage Python dependencies intelligently and securely!** ðŸ”„