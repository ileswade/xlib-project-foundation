# Chapter 7: Encryption Manager - User Guide Overview

> **üöÄ QUICK START GUIDE**
> Get up and running with the Encryption Manager in 5 minutes. Essential patterns for secure encryption, digital signatures, key management, and cryptographic operations.

## 5-Minute Quick Start

### Installation
```bash
# Install encryption pillar
pip install xlibrary[encryption]
```

### Basic Usage

```python
from xlibrary.encryption import EncryptionManager, SymmetricAlgorithm

# Initialize encryption manager
em = EncryptionManager()

# Simple string encryption
encrypted = em.encrypt_string("confidential data", "secure_password")
decrypted = em.decrypt_string(encrypted, "secure_password")

# File encryption
em.encrypt_file("document.pdf", "document.pdf.enc", password="file_password")
em.decrypt_file("document.pdf.enc", "decrypted.pdf", password="file_password")

# Digital signatures
key_pair = em.generate_key_pair("rsa_2048", "my_signing_key")
signature = em.sign_data("important document", "my_signing_key")
is_valid = em.verify_signature("important document", signature, "my_signing_key")

# Secure hashing
hash_result = em.hash_data("data to hash", algorithm="sha256")
password_hash = em.hash_password("user_password")
```

---

## Essential Patterns

### 1. String and Data Encryption (Secure Defaults)

Encrypt sensitive strings and binary data with secure algorithms:

```python
from xlibrary.encryption import EncryptionManager, SymmetricAlgorithm

em = EncryptionManager()

# Simple string encryption (uses AES-256-GCM by default)
sensitive_data = "Social Security Number: 123-45-6789"
encrypted = em.encrypt_string(sensitive_data, "strong_password_2024!")
decrypted = em.decrypt_string(encrypted, "strong_password_2024!")

# Advanced encryption with algorithm selection
api_key = "sk_live_abc123xyz789"
encrypted_api_key = em.encrypt_string(
    api_key,
    password="master_password",
    algorithm=SymmetricAlgorithm.CHACHA20_POLY1305,  # High-performance alternative
    additional_data="api_keys_context"  # Authenticated additional data
)

# Binary data encryption
binary_data = b"Raw binary content with \x00 null bytes"
encrypted_binary = em.encrypt_data(binary_data, "binary_password")
decrypted_binary = em.decrypt_data(encrypted_binary, "binary_password")

# Batch encryption for multiple strings
sensitive_strings = [
    "Credit Card: 1234-5678-9012-3456",
    "API Token: abc123def456",
    "Database Password: super_secret_db_pass"
]

batch_results = em.batch_encrypt_strings(
    sensitive_strings,
    password="batch_encryption_key",
    algorithm=SymmetricAlgorithm.AES_256_GCM
)

# Decrypt batch results
for i, encrypted_item in enumerate(batch_results):
    decrypted = em.decrypt_string(encrypted_item, "batch_encryption_key")
    print(f"Item {i+1}: {decrypted}")
```

### 2. File Encryption (Enterprise Grade)

Secure file encryption with progress tracking and integrity verification:

```python
from xlibrary.encryption import EncryptionManager, SymmetricAlgorithm

em = EncryptionManager()

# Simple file encryption
em.encrypt_file("financial_report.xlsx", "financial_report.enc", password="file_secret_2024")
em.decrypt_file("financial_report.enc", "decrypted_report.xlsx", password="file_secret_2024")

# Advanced file encryption with options
def progress_callback(current, total, filename):
    percent = (current / total) * 100
    print(f"Encrypting {filename}: {percent:.1f}%")

encryption_result = em.encrypt_file(
    source_file="large_database.sql",
    output_file="large_database.enc",
    password="database_backup_key_2024",
    algorithm=SymmetricAlgorithm.AES_256_GCM,
    compress_before_encrypt=True,     # Compress for space efficiency
    verify_integrity=True,            # Add integrity verification
    progress_callback=progress_callback
)

print(f"Encryption completed:")
print(f"Original size: {encryption_result.original_size:,} bytes")
print(f"Encrypted size: {encryption_result.encrypted_size:,} bytes")
print(f"Compression ratio: {encryption_result.compression_ratio:.2%}")
print(f"Integrity hash: {encryption_result.integrity_hash}")

# Batch file encryption
files_to_encrypt = [
    "document1.pdf",
    "document2.docx",
    "spreadsheet.xlsx",
    "presentation.pptx"
]

batch_results = em.batch_encrypt_files(
    files_to_encrypt,
    output_directory="encrypted_files/",
    password="batch_file_password",
    preserve_extensions=False,  # All get .enc extension
    parallel_processing=True,   # Use multiple CPU cores
    progress_callback=progress_callback
)

# Check results
for filename, result in batch_results.items():
    if result.success:
        print(f"‚úÖ {filename} encrypted successfully")
    else:
        print(f"‚ùå {filename} failed: {result.error}")
```

### 3. Digital Signatures and PKI

Create and verify digital signatures with key management:

```python
from xlibrary.encryption import EncryptionManager, AsymmetricAlgorithm

em = EncryptionManager()

# Generate key pairs for different purposes
signing_keys = {
    "document_signing": em.generate_key_pair(AsymmetricAlgorithm.RSA_2048, "doc_signing"),
    "code_signing": em.generate_key_pair(AsymmetricAlgorithm.RSA_4096, "code_signing"),
    "email_signing": em.generate_key_pair(AsymmetricAlgorithm.ECDSA_P256, "email_signing")
}

# Sign important document
contract_text = """
CONFIDENTIAL CONTRACT AGREEMENT
Between: Company A and Company B
Terms: [detailed contract terms]
Signed on: 2024-01-15
"""

# Create digital signature
signature = em.sign_data(contract_text, "doc_signing")
print(f"Document signed with signature: {signature.signature_b64[:50]}...")

# Verify signature
is_valid = em.verify_signature(contract_text, signature, "doc_signing")
print(f"Signature valid: {is_valid}")

# Sign file directly
file_signature = em.sign_file("contract.pdf", "doc_signing")
file_valid = em.verify_file_signature("contract.pdf", file_signature, "doc_signing")
print(f"File signature valid: {file_valid}")

# Export public key for sharing
public_key_pem = em.export_public_key("doc_signing", format="pem")
print("Public key for verification:")
print(public_key_pem)

# Import someone else's public key
partner_public_key = """
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----
"""

em.import_public_key(partner_public_key, "partner_verification_key")

# Verify document signed by partner
partner_signature = em.load_signature_from_file("partner_document.sig")
partner_doc_valid = em.verify_signature("partner document content", partner_signature, "partner_verification_key")
```

### 4. Secure Hashing and Password Management

Advanced hashing for passwords and data integrity:

```python
from xlibrary.encryption import EncryptionManager, HashAlgorithm

em = EncryptionManager()

# Password hashing (uses Argon2 by default - best practice)
user_passwords = {
    "john_doe": "MySecurePassword123!",
    "jane_smith": "AnotherStrongPass456@",
    "admin": "SuperAdminPassword789#"
}

hashed_passwords = {}
for username, password in user_passwords.items():
    # Secure password hashing with salt
    password_hash = em.hash_password(password, algorithm=HashAlgorithm.ARGON2ID)
    hashed_passwords[username] = password_hash
    print(f"{username}: {password_hash.hash_value[:50]}...")

# Password verification
login_attempt = "MySecurePassword123!"
stored_hash = hashed_passwords["john_doe"]
is_correct = em.verify_password(login_attempt, stored_hash)
print(f"Login successful: {is_correct}")

# Data integrity hashing
important_data = "Critical financial data that must not be tampered with"
data_hashes = {
    "SHA256": em.hash_data(important_data, HashAlgorithm.SHA256),
    "SHA512": em.hash_data(important_data, HashAlgorithm.SHA512),
    "BLAKE2B": em.hash_data(important_data, HashAlgorithm.BLAKE2B)
}

for algorithm, hash_result in data_hashes.items():
    print(f"{algorithm}: {hash_result.hash_value}")

# File integrity verification
file_hash = em.hash_file("important_document.pdf", HashAlgorithm.SHA256)
print(f"File hash: {file_hash.hash_value}")

# Later, verify file hasn't been modified
current_hash = em.hash_file("important_document.pdf", HashAlgorithm.SHA256)
file_unchanged = (file_hash.hash_value == current_hash.hash_value)
print(f"File integrity verified: {file_unchanged}")
```

### 5. Key Management and Storage

Secure key generation, storage, and management:

```python
from xlibrary.encryption import EncryptionManager, SymmetricAlgorithm

em = EncryptionManager()

# Generate master keys for different purposes
master_keys = {
    "database_encryption": em.generate_master_key(
        "db_master_key",
        algorithm=SymmetricAlgorithm.AES_256_GCM,
        description="Master key for database encryption"
    ),
    "file_encryption": em.generate_master_key(
        "file_master_key",
        algorithm=SymmetricAlgorithm.CHACHA20_POLY1305,
        description="Master key for file encryption"
    ),
    "api_tokens": em.generate_master_key(
        "api_master_key",
        algorithm=SymmetricAlgorithm.AES_256_GCM,
        description="Master key for API token encryption"
    )
}

# Key derivation for specific uses
database_keys = {
    "users_table": em.derive_key("db_master_key", "users_table_encryption"),
    "orders_table": em.derive_key("db_master_key", "orders_table_encryption"),
    "payments_table": em.derive_key("db_master_key", "payments_table_encryption")
}

# Generate API keys and tokens
api_tokens = {
    "public_key": em.generate_api_key(prefix="pk_", length=32),
    "secret_key": em.generate_api_key(prefix="sk_", length=64),
    "webhook_secret": em.generate_api_key(prefix="whsec_", length=48)
}

print("Generated API tokens:")
for token_type, token in api_tokens.items():
    print(f"{token_type}: {token}")

# Key rotation schedule
def setup_key_rotation():
    """Setup automatic key rotation for security."""

    # Rotate database keys quarterly
    em.schedule_key_rotation(
        key_name="db_master_key",
        rotation_interval="quarterly",
        notification_email="security@company.com"
    )

    # Rotate API keys monthly
    em.schedule_key_rotation(
        key_name="api_master_key",
        rotation_interval="monthly",
        auto_update_applications=True
    )

setup_key_rotation()

# Export keys for backup (encrypted)
backup_data = em.export_keystore(
    backup_password="keystore_backup_password_2024",
    include_private_keys=True,
    encryption_algorithm=SymmetricAlgorithm.AES_256_GCM
)

with open("keystore_backup.enc", "wb") as backup_file:
    backup_file.write(backup_data)

print("Keystore backed up successfully")
```

---

## Common Use Cases

### 1. Application Configuration Encryption

```python
from xlibrary.encryption import EncryptionManager
import json

def encrypt_application_config(config_file):
    """Encrypt sensitive configuration data."""

    em = EncryptionManager()

    # Load configuration
    with open(config_file, 'r') as f:
        config = json.load(f)

    # Identify and encrypt sensitive fields
    sensitive_fields = [
        'database_password', 'api_keys', 'secret_tokens',
        'private_keys', 'smtp_password', 'oauth_secrets'
    ]

    encrypted_config = config.copy()

    for field in sensitive_fields:
        if field in config and config[field]:
            encrypted_value = em.encrypt_string(
                str(config[field]),
                password="config_encryption_key_2024"
            )
            encrypted_config[field] = {
                "encrypted": True,
                "value": encrypted_value.to_dict()
            }

    # Save encrypted configuration
    encrypted_file = config_file.replace('.json', '_encrypted.json')
    with open(encrypted_file, 'w') as f:
        json.dump(encrypted_config, f, indent=2)

    print(f"Configuration encrypted and saved to {encrypted_file}")
    return encrypted_file

def decrypt_application_config(encrypted_config_file):
    """Decrypt and load application configuration."""

    em = EncryptionManager()

    with open(encrypted_config_file, 'r') as f:
        encrypted_config = json.load(f)

    decrypted_config = encrypted_config.copy()

    # Decrypt sensitive fields
    for field, value in encrypted_config.items():
        if isinstance(value, dict) and value.get("encrypted"):
            encrypted_data = em.load_encrypted_data(value["value"])
            decrypted_value = em.decrypt_string(
                encrypted_data,
                password="config_encryption_key_2024"
            )
            decrypted_config[field] = decrypted_value

    return decrypted_config

# Usage
original_config = "app_config.json"
encrypted_config_file = encrypt_application_config(original_config)
runtime_config = decrypt_application_config(encrypted_config_file)
```

### 2. Secure Data Backup System

```python
from xlibrary.encryption import EncryptionManager, SymmetricAlgorithm
import shutil
from datetime import datetime

class SecureBackupManager:
    def __init__(self, backup_password):
        self.em = EncryptionManager()
        self.backup_password = backup_password

    def create_secure_backup(self, source_directory, backup_location):
        """Create encrypted backup of entire directory."""

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_name = f"backup_{timestamp}"

        print(f"üîÑ Creating secure backup: {backup_name}")

        # Step 1: Create compressed archive
        temp_archive = f"/tmp/{backup_name}.tar.gz"
        print("üì¶ Compressing files...")
        shutil.make_archive(temp_archive.replace('.tar.gz', ''), 'gztar', source_directory)

        # Step 2: Encrypt the archive
        encrypted_backup = f"{backup_location}/{backup_name}.enc"
        print("üîê Encrypting backup...")

        def backup_progress(current, total, filename):
            percent = (current / total) * 100
            print(f"Encryption progress: {percent:.1f}%")

        encryption_result = self.em.encrypt_file(
            temp_archive,
            encrypted_backup,
            password=self.backup_password,
            algorithm=SymmetricAlgorithm.AES_256_GCM,
            verify_integrity=True,
            progress_callback=backup_progress
        )

        # Step 3: Create backup manifest
        manifest = {
            "backup_name": backup_name,
            "created_at": datetime.now().isoformat(),
            "source_directory": source_directory,
            "encrypted_file": encrypted_backup,
            "integrity_hash": encryption_result.integrity_hash,
            "original_size": encryption_result.original_size,
            "encrypted_size": encryption_result.encrypted_size
        }

        manifest_file = f"{backup_location}/{backup_name}_manifest.json"
        with open(manifest_file, 'w') as f:
            json.dump(manifest, f, indent=2)

        # Cleanup
        os.remove(temp_archive)

        print(f"‚úÖ Secure backup created: {encrypted_backup}")
        return manifest

    def restore_secure_backup(self, backup_manifest_file, restore_location):
        """Restore encrypted backup."""

        # Load manifest
        with open(backup_manifest_file, 'r') as f:
            manifest = json.load(f)

        encrypted_file = manifest["encrypted_file"]

        print(f"üîì Restoring backup: {manifest['backup_name']}")

        # Decrypt backup
        temp_archive = f"/tmp/restore_{manifest['backup_name']}.tar.gz"

        def restore_progress(current, total, filename):
            percent = (current / total) * 100
            print(f"Decryption progress: {percent:.1f}%")

        decryption_result = self.em.decrypt_file(
            encrypted_file,
            temp_archive,
            password=self.backup_password,
            verify_integrity=True,
            expected_hash=manifest["integrity_hash"],
            progress_callback=restore_progress
        )

        # Extract archive
        print("üìÇ Extracting files...")
        shutil.unpack_archive(temp_archive, restore_location)

        # Cleanup
        os.remove(temp_archive)

        print(f"‚úÖ Backup restored to: {restore_location}")
        return decryption_result

# Usage
backup_manager = SecureBackupManager("secure_backup_password_2024!")

# Create backup
manifest = backup_manager.create_secure_backup(
    "/important/data/directory",
    "/secure/backups/"
)

# Restore backup later
backup_manager.restore_secure_backup(
    "/secure/backups/backup_20240115_143022_manifest.json",
    "/restored/data/"
)
```

### 3. Document Signing Workflow

```python
from xlibrary.encryption import EncryptionManager, AsymmetricAlgorithm
import json
from datetime import datetime

class DocumentSigningWorkflow:
    def __init__(self):
        self.em = EncryptionManager()

    def setup_signing_authority(self, authority_name, key_algorithm=AsymmetricAlgorithm.RSA_2048):
        """Setup document signing authority with key pair."""

        key_pair = self.em.generate_key_pair(key_algorithm, f"{authority_name}_signing")

        # Export public key for distribution
        public_key_pem = self.em.export_public_key(f"{authority_name}_signing", format="pem")

        authority_info = {
            "name": authority_name,
            "key_id": f"{authority_name}_signing",
            "algorithm": key_algorithm.value,
            "created_at": datetime.now().isoformat(),
            "public_key": public_key_pem
        }

        # Save authority info
        with open(f"{authority_name}_authority.json", "w") as f:
            json.dump(authority_info, f, indent=2)

        print(f"‚úÖ Signing authority '{authority_name}' created")
        return authority_info

    def sign_document(self, document_path, signer_key_id, metadata=None):
        """Sign document with digital signature."""

        # Read document content
        with open(document_path, 'rb') as f:
            document_content = f.read()

        # Create document hash
        document_hash = self.em.hash_data(document_content, algorithm="sha256")

        # Sign the document
        signature = self.em.sign_data(document_content, signer_key_id)

        # Create signature record
        signature_record = {
            "document_path": document_path,
            "document_hash": document_hash.hash_value,
            "signature": signature.to_dict(),
            "signer_key_id": signer_key_id,
            "signed_at": datetime.now().isoformat(),
            "metadata": metadata or {}
        }

        # Save signature file
        signature_file = f"{document_path}.sig"
        with open(signature_file, 'w') as f:
            json.dump(signature_record, f, indent=2)

        print(f"‚úÖ Document signed: {signature_file}")
        return signature_record

    def verify_document_signature(self, document_path, signature_file, public_key_id=None):
        """Verify document digital signature."""

        # Load signature record
        with open(signature_file, 'r') as f:
            signature_record = json.load(f)

        # Read current document content
        with open(document_path, 'rb') as f:
            current_content = f.read()

        # Verify document hasn't been modified
        current_hash = self.em.hash_data(current_content, algorithm="sha256")
        if current_hash.hash_value != signature_record["document_hash"]:
            return {
                "valid": False,
                "reason": "Document has been modified since signing",
                "document_hash_match": False
            }

        # Load signature
        signature = self.em.load_signature(signature_record["signature"])

        # Determine key for verification
        verification_key = public_key_id or signature_record["signer_key_id"]

        # Verify signature
        signature_valid = self.em.verify_signature(
            current_content,
            signature,
            verification_key
        )

        verification_result = {
            "valid": signature_valid,
            "document_hash_match": True,
            "signature_valid": signature_valid,
            "signer": signature_record["signer_key_id"],
            "signed_at": signature_record["signed_at"],
            "verified_at": datetime.now().isoformat()
        }

        return verification_result

# Usage
workflow = DocumentSigningWorkflow()

# Setup company signing authority
company_authority = workflow.setup_signing_authority(
    "CompanyLegal",
    AsymmetricAlgorithm.RSA_4096
)

# Sign important contract
contract_signature = workflow.sign_document(
    "important_contract.pdf",
    "CompanyLegal_signing",
    metadata={
        "contract_type": "Service Agreement",
        "parties": ["Company A", "Company B"],
        "effective_date": "2024-01-15"
    }
)

# Verify signature later
verification = workflow.verify_document_signature(
    "important_contract.pdf",
    "important_contract.pdf.sig"
)

print(f"Signature verification: {'‚úÖ Valid' if verification['valid'] else '‚ùå Invalid'}")
```

---

## Error Handling Patterns

### Secure Error Handling

```python
from xlibrary.encryption import (
    EncryptionManager, EncryptionError, KeyNotFoundError,
    InvalidSignatureError, WeakPasswordError
)

def secure_encryption_operation(data, password, key_name=None):
    """Robust encryption operation with comprehensive error handling."""

    try:
        em = EncryptionManager()

        if key_name:
            # Use stored key
            encrypted = em.encrypt_string_with_key(data, key_name)
        else:
            # Use password
            encrypted = em.encrypt_string(data, password)

        return {"success": True, "encrypted_data": encrypted}

    except WeakPasswordError as e:
        return {
            "success": False,
            "error": "Password too weak",
            "requirements": e.password_requirements,
            "suggestion": "Use at least 12 characters with mixed case, numbers, and symbols"
        }

    except KeyNotFoundError as e:
        return {
            "success": False,
            "error": f"Encryption key '{e.key_name}' not found",
            "suggestion": "Generate the key first or check key name spelling"
        }

    except EncryptionError as e:
        return {
            "success": False,
            "error": f"Encryption failed: {e}",
            "suggestion": "Check input data and parameters"
        }

    except Exception as e:
        return {
            "success": False,
            "error": f"Unexpected error: {e}",
            "suggestion": "Contact support if this persists"
        }

# Usage with error handling
result = secure_encryption_operation("sensitive data", "weak", "missing_key")
if result["success"]:
    print("Encryption successful!")
else:
    print(f"Error: {result['error']}")
    print(f"Suggestion: {result['suggestion']}")
```

---

## Best Practices

### 1. **Strong Password Requirements**
```python
# Use strong passwords for encryption
strong_password = "MyStr0ngP@ssw0rd2024!WithNumbers&Symbols"
encrypted = em.encrypt_string("data", strong_password)
```

### 2. **Key Derivation for Multiple Uses**
```python
# Derive different keys from master key
master_key = "master_password"
db_key = em.derive_key_from_password(master_key, salt=b"db_salt", key_length=32)
file_key = em.derive_key_from_password(master_key, salt=b"file_salt", key_length=32)
```

### 3. **Regular Key Rotation**
```python
# Implement key rotation schedule
em.schedule_key_rotation("production_key", interval="quarterly")
```

### 4. **Secure Memory Handling**
```python
# Use secure memory operations when available
with em.secure_memory_context():
    decrypted_data = em.decrypt_string(encrypted_data, password)
    # Process decrypted data
    # Memory automatically cleared on exit
```

---

## Troubleshooting

### Common Issues

**Weak password error:**
```python
# Use password strength checker
strength = em.check_password_strength("password123")
if strength.score < 80:
    print(f"Password too weak. Requirements: {strength.requirements}")
```

**Key not found error:**
```python
# List available keys
available_keys = em.list_keys()
print(f"Available keys: {available_keys}")
```

**Decryption fails:**
```python
# Verify password and check data integrity
try:
    decrypted = em.decrypt_string(encrypted_data, password)
except EncryptionError as e:
    if "authentication" in str(e).lower():
        print("Data may be corrupted or wrong password")
    else:
        print(f"Decryption error: {e}")
```

---

## Next Steps

Ready for advanced cryptographic operations?

- **[Detailed User Guide](07.04%20Chapter%207%20-%20Encryption%20Manager%20-%20User%20Guide%20-%20Detailed.md)** - Comprehensive cryptographic workflows and enterprise patterns
- **[Chapter 8: Imports Manager](08.01%20Chapter%208%20-%20Imports%20Manager%20-%20Design%20-%20Overview.md)** - Package and dependency management
- **[Design Documentation](07.01%20Chapter%207%20-%20Encryption%20Manager%20-%20Design%20-%20Overview.md)** - Architectural details

**You're now ready to implement military-grade security with xlibrary!** üîê