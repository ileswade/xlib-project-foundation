# Chapter 10.04: CLI Framework - User Guide - Detailed

## Advanced CLI Development

This comprehensive guide covers advanced patterns, enterprise features, and sophisticated CLI development techniques using the xlibrary CLI Framework.

## Advanced Command Patterns

### Complex Argument Handling

#### Custom Argument Types and Validation

```python
from xlibrary.cli import CLIFramework
from typing import List, Optional
import re
from pathlib import Path

cli = CLIFramework(name="advanced-cli", version="2.0.0")

def validate_email(value: str) -> str:
    """Custom email validator."""
    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    if not re.match(pattern, value):
        raise ValueError(f"Invalid email format: {value}")
    return value

def validate_port(value: str) -> int:
    """Custom port validator."""
    try:
        port = int(value)
        if not (1 <= port <= 65535):
            raise ValueError(f"Port must be between 1 and 65535, got {port}")
        return port
    except ValueError as e:
        raise ValueError(f"Invalid port number: {value}")

@cli.command()
def connect(
    host: str,
    port: int = cli.option(default=8080, validator=validate_port),
    email: str = cli.option(validator=validate_email),
    retries: int = cli.option(default=3, min_value=1, max_value=10),
    timeout: float = cli.option(default=30.0, min_value=1.0, max_value=300.0),
    config_files: List[Path] = cli.option(default_factory=list, file_exists=True),
    verbose: bool = False
):
    """Connect to server with advanced validation."""
    cli.console.print(f"Connecting to {host}:{port}")
    cli.console.print(f"Contact: {email}")
    cli.console.print(f"Retries: {retries}, Timeout: {timeout}s")

    for config_file in config_files:
        cli.console.print(f"Loading config: {config_file}")

    if verbose:
        cli.console.print("Verbose mode enabled")
```

#### Dynamic Command Generation

```python
def create_service_commands():
    """Generate commands for each service dynamically."""
    services = ['web', 'api', 'worker', 'scheduler']

    for service in services:
        @cli.command(name=f"{service}-status")
        def status(service_name=service):
            f"""Get status of {service_name} service."""
            cli.console.print(f"Checking {service_name} service status...")
            # Service status logic here

        @cli.command(name=f"{service}-restart")
        def restart(force: bool = False, service_name=service):
            f"""Restart {service_name} service."""
            if force or cli.confirm(f"Restart {service_name} service?"):
                cli.console.print(f"Restarting {service_name} service...")

        @cli.command(name=f"{service}-logs")
        def logs(lines: int = 100, follow: bool = False, service_name=service):
            f"""View {service_name} service logs."""
            cli.console.print(f"Showing {lines} lines from {service_name} logs")
            if follow:
                cli.console.print("Following log output (Ctrl+C to stop)...")

# Generate all service commands
create_service_commands()
```

### Advanced Interactive Workflows

#### Multi-Step Wizards

```python
@cli.command()
def setup_project():
    """Interactive project setup wizard."""
    cli.console.print("[bold blue]Project Setup Wizard[/]")
    cli.console.print("This wizard will guide you through setting up a new project.\n")

    # Step 1: Basic Information
    with cli.console.status("Collecting project information..."):
        project_name = cli.prompt(
            "Project name",
            validator=lambda x: x.replace('-', '_').replace(' ', '_').isidentifier()
        )

        project_type = cli.select(
            "Project type:",
            choices=[
                ("web", "Web Application"),
                ("api", "REST API Service"),
                ("cli", "Command Line Tool"),
                ("lib", "Python Library")
            ]
        )

    # Step 2: Dependencies
    cli.console.print(f"\n[bold]Configuring {project_type} project: {project_name}[/]")

    dependencies = cli.select_multiple(
        "Select dependencies:",
        choices=[
            ("fastapi", "FastAPI web framework"),
            ("sqlalchemy", "SQLAlchemy ORM"),
            ("redis", "Redis caching"),
            ("celery", "Celery task queue"),
            ("pytest", "Testing framework"),
            ("docker", "Docker containerization")
        ]
    )

    # Step 3: Advanced Configuration
    use_auth = cli.confirm("Enable authentication?")
    use_logging = cli.confirm("Configure structured logging?", default=True)
    use_monitoring = cli.confirm("Add monitoring and metrics?")

    # Step 4: Generate Project
    with cli.progress() as progress:
        setup_task = progress.add_task("Setting up project...", total=100)

        # Create directory structure
        progress.update(setup_task, description="Creating directories...", advance=20)
        create_project_structure(project_name)

        # Install dependencies
        progress.update(setup_task, description="Installing dependencies...", advance=30)
        install_dependencies(dependencies)

        # Configure features
        if use_auth:
            progress.update(setup_task, description="Configuring authentication...", advance=15)
            setup_authentication()

        if use_logging:
            progress.update(setup_task, description="Setting up logging...", advance=15)
            setup_logging()

        if use_monitoring:
            progress.update(setup_task, description="Configuring monitoring...", advance=15)
            setup_monitoring()

        progress.update(setup_task, description="Finalizing setup...", advance=5)
        finalize_project_setup()

    cli.console.print(f"\n[bold green]✓[/] Project '{project_name}' created successfully!")
    cli.console.print(f"[dim]Project location: ./{project_name}[/]")

    # Post-setup instructions
    next_steps = [
        f"cd {project_name}",
        "python -m venv venv",
        "source venv/bin/activate  # On Windows: venv\\Scripts\\activate",
        "pip install -r requirements.txt",
        "python main.py"
    ]

    cli.console.print("\n[bold]Next steps:[/]")
    for i, step in enumerate(next_steps, 1):
        cli.console.print(f"  {i}. [cyan]{step}[/]")
```

#### Advanced Form Handling

```python
from dataclasses import dataclass
from typing import Optional, Dict, Any

@dataclass
class DeploymentConfig:
    environment: str
    region: str
    instance_type: str
    instance_count: int
    auto_scaling: bool
    load_balancer: bool
    ssl_certificate: Optional[str] = None
    custom_domain: Optional[str] = None
    environment_vars: Dict[str, str] = None

@cli.command()
def deploy_application():
    """Advanced deployment configuration."""
    cli.console.print("[bold]Application Deployment Configuration[/]")

    # Environment selection with validation
    environment = cli.select(
        "Target environment:",
        choices=[
            ("dev", "Development (Free tier, single instance)"),
            ("staging", "Staging (Production-like, multiple instances)"),
            ("prod", "Production (High availability, auto-scaling)")
        ]
    )

    # Region selection based on environment
    if environment == "dev":
        regions = ["us-east-1", "eu-west-1"]
    else:
        regions = ["us-east-1", "us-west-2", "eu-west-1", "eu-central-1", "ap-southeast-1"]

    region = cli.select(f"Deployment region for {environment}:", choices=regions)

    # Instance configuration
    instance_types = {
        "dev": ["t3.micro", "t3.small"],
        "staging": ["t3.small", "t3.medium", "c5.large"],
        "prod": ["t3.medium", "t3.large", "c5.large", "c5.xlarge", "m5.large"]
    }

    instance_type = cli.select(
        "Instance type:",
        choices=instance_types[environment]
    )

    # Instance count with environment-specific limits
    max_instances = {"dev": 1, "staging": 5, "prod": 20}
    instance_count = cli.prompt(
        f"Number of instances (1-{max_instances[environment]}):",
        type=int,
        validator=lambda x: 1 <= x <= max_instances[environment]
    )

    # Advanced features for staging/prod
    auto_scaling = False
    load_balancer = False
    ssl_certificate = None
    custom_domain = None

    if environment in ["staging", "prod"]:
        auto_scaling = cli.confirm("Enable auto-scaling?", default=True)
        load_balancer = cli.confirm("Configure load balancer?", default=True)

        if cli.confirm("Configure SSL certificate?"):
            ssl_certificate = cli.prompt("SSL certificate ARN (optional):")

        if cli.confirm("Use custom domain?"):
            custom_domain = cli.prompt("Custom domain name:")

    # Environment variables
    environment_vars = {}
    if cli.confirm("Configure environment variables?"):
        while True:
            key = cli.prompt("Environment variable name (empty to finish):")
            if not key:
                break

            value = cli.prompt(f"Value for {key}:", password="SECRET" in key.upper())
            environment_vars[key] = value

    # Create configuration object
    config = DeploymentConfig(
        environment=environment,
        region=region,
        instance_type=instance_type,
        instance_count=instance_count,
        auto_scaling=auto_scaling,
        load_balancer=load_balancer,
        ssl_certificate=ssl_certificate,
        custom_domain=custom_domain,
        environment_vars=environment_vars
    )

    # Display configuration summary
    cli.console.print("\n[bold]Deployment Configuration Summary:[/]")
    display_deployment_config(config)

    # Confirm deployment
    if cli.confirm("\nProceed with deployment?"):
        perform_deployment(config)
    else:
        cli.console.print("[yellow]Deployment cancelled[/]")

def display_deployment_config(config: DeploymentConfig):
    """Display deployment configuration in a formatted table."""
    from rich.table import Table

    table = Table(title="Deployment Configuration")
    table.add_column("Setting", style="cyan")
    table.add_column("Value", style="green")

    table.add_row("Environment", config.environment)
    table.add_row("Region", config.region)
    table.add_row("Instance Type", config.instance_type)
    table.add_row("Instance Count", str(config.instance_count))
    table.add_row("Auto Scaling", "Yes" if config.auto_scaling else "No")
    table.add_row("Load Balancer", "Yes" if config.load_balancer else "No")

    if config.ssl_certificate:
        table.add_row("SSL Certificate", config.ssl_certificate)

    if config.custom_domain:
        table.add_row("Custom Domain", config.custom_domain)

    if config.environment_vars:
        env_vars = ", ".join(config.environment_vars.keys())
        table.add_row("Environment Variables", env_vars)

    cli.console.print(table)
```

## Plugin Architecture

### Creating CLI Plugins

#### Basic Plugin Structure

```python
# plugins/database_plugin.py
from xlibrary.cli import CLIPlugin, CLIFramework

class DatabasePlugin(CLIPlugin):
    """Database management plugin."""

    name = "database"
    version = "1.0.0"
    description = "Database operations and management"

    def __init__(self, cli: CLIFramework):
        super().__init__(cli)
        self.config = cli.config.get_section("database", {})

    def register_commands(self):
        """Register plugin commands."""

        @self.cli.group()
        def db():
            """Database operations."""
            pass

        @db.command()
        def migrate():
            """Run database migrations."""
            self.run_migrations()

        @db.command()
        def backup(output_file: str = None):
            """Create database backup."""
            self.create_backup(output_file)

        @db.command()
        def restore(backup_file: str):
            """Restore database from backup."""
            self.restore_backup(backup_file)

        @db.command()
        def status():
            """Show database status."""
            self.show_database_status()

    def run_migrations(self):
        """Execute database migrations."""
        with self.cli.console.status("Running migrations..."):
            # Migration logic here
            migrations = self.get_pending_migrations()

            if not migrations:
                self.cli.console.print("[green]No pending migrations[/]")
                return

            with self.cli.progress() as progress:
                task = progress.add_task("Applying migrations...", total=len(migrations))

                for migration in migrations:
                    self.apply_migration(migration)
                    progress.update(task, advance=1)

        self.cli.console.print(f"[green]Applied {len(migrations)} migrations[/]")

    def create_backup(self, output_file: str = None):
        """Create database backup."""
        if output_file is None:
            from datetime import datetime
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"backup_{timestamp}.sql"

        self.cli.console.print(f"Creating backup: {output_file}")
        # Backup logic here
        self.cli.console.print("[green]Backup completed[/]")

    def get_pending_migrations(self):
        """Get list of pending migrations."""
        # Return list of migrations
        return ["001_create_users.sql", "002_add_indexes.sql"]

    def apply_migration(self, migration: str):
        """Apply single migration."""
        self.cli.console.print(f"Applying {migration}...")
        # Migration application logic
        import time
        time.sleep(0.5)  # Simulate migration time

# Register plugin
def setup_plugin(cli: CLIFramework):
    """Plugin entry point."""
    return DatabasePlugin(cli)
```

#### Advanced Plugin with Dependencies

```python
# plugins/monitoring_plugin.py
from xlibrary.cli import CLIPlugin, CLIFramework
import asyncio
from typing import List, Dict, Any

class MonitoringPlugin(CLIPlugin):
    """System monitoring and alerting plugin."""

    name = "monitoring"
    version = "2.0.0"
    description = "System monitoring, metrics, and alerting"
    dependencies = ["requests", "psutil", "prometheus_client"]

    def __init__(self, cli: CLIFramework):
        super().__init__(cli)
        self.metrics_endpoint = cli.config.get("monitoring.metrics_endpoint")
        self.alert_webhooks = cli.config.get("monitoring.alert_webhooks", [])

    def register_commands(self):
        """Register monitoring commands."""

        @self.cli.group()
        def monitor():
            """System monitoring operations."""
            pass

        @monitor.command()
        def status():
            """Show system status dashboard."""
            self.show_system_dashboard()

        @monitor.command()
        def metrics(service: str = None):
            """Display metrics for service or all services."""
            self.show_metrics(service)

        @monitor.command()
        def alerts():
            """Show active alerts."""
            self.show_active_alerts()

        @monitor.command()
        def watch(
            service: str,
            interval: int = 5,
            threshold: float = 80.0
        ):
            """Watch service metrics in real-time."""
            asyncio.run(self.watch_service(service, interval, threshold))

    def show_system_dashboard(self):
        """Display comprehensive system dashboard."""
        from rich.layout import Layout
        from rich.panel import Panel
        from rich.table import Table

        layout = Layout()
        layout.split_row(
            Layout(name="left"),
            Layout(name="right")
        )

        # System metrics
        system_table = Table(title="System Metrics")
        system_table.add_column("Metric")
        system_table.add_column("Value")
        system_table.add_column("Status")

        metrics = self.get_system_metrics()
        for metric, value, status in metrics:
            color = "green" if status == "OK" else "red" if status == "CRITICAL" else "yellow"
            system_table.add_row(metric, value, f"[{color}]{status}[/]")

        # Service status
        service_table = Table(title="Service Status")
        service_table.add_column("Service")
        service_table.add_column("Status")
        service_table.add_column("Uptime")

        services = self.get_service_status()
        for service, status, uptime in services:
            color = "green" if status == "Running" else "red"
            service_table.add_row(service, f"[{color}]{status}[/]", uptime)

        layout["left"].update(Panel(system_table))
        layout["right"].update(Panel(service_table))

        self.cli.console.print(layout)

    async def watch_service(self, service: str, interval: int, threshold: float):
        """Watch service metrics with real-time updates."""
        self.cli.console.print(f"[bold]Watching {service} (threshold: {threshold}%)[/]")
        self.cli.console.print("Press Ctrl+C to stop watching\n")

        try:
            while True:
                metrics = self.get_service_metrics(service)

                # Display metrics
                self.cli.console.clear()
                self.display_live_metrics(service, metrics, threshold)

                # Check thresholds
                for metric_name, value in metrics.items():
                    if isinstance(value, (int, float)) and value > threshold:
                        await self.send_alert(service, metric_name, value, threshold)

                await asyncio.sleep(interval)

        except KeyboardInterrupt:
            self.cli.console.print("\n[yellow]Stopped watching[/]")

    def get_system_metrics(self):
        """Get current system metrics."""
        import psutil

        return [
            ("CPU Usage", f"{psutil.cpu_percent()}%", "OK" if psutil.cpu_percent() < 80 else "WARNING"),
            ("Memory Usage", f"{psutil.virtual_memory().percent}%", "OK" if psutil.virtual_memory().percent < 80 else "WARNING"),
            ("Disk Usage", f"{psutil.disk_usage('/').percent}%", "OK" if psutil.disk_usage('/').percent < 90 else "CRITICAL"),
            ("Load Average", f"{psutil.getloadavg()[0]:.2f}", "OK")
        ]

    async def send_alert(self, service: str, metric: str, value: float, threshold: float):
        """Send alert when threshold is exceeded."""
        alert_message = f"ALERT: {service} {metric} is {value}% (threshold: {threshold}%)"

        for webhook in self.alert_webhooks:
            try:
                # Send webhook alert
                import requests
                requests.post(webhook, json={"message": alert_message})
            except Exception as e:
                self.cli.console.print(f"[red]Failed to send alert: {e}[/]")
```

### Plugin Discovery and Loading

```python
# Core CLI application with plugin support
class AdvancedCLI(CLIFramework):
    """CLI application with plugin support."""

    def __init__(self, name: str, version: str = "1.0.0"):
        super().__init__(name, version)
        self.plugins = {}
        self.plugin_directories = [
            "./plugins",
            "~/.config/myapp/plugins",
            "/usr/local/share/myapp/plugins"
        ]

    def discover_plugins(self):
        """Discover and load plugins from configured directories."""
        import os
        import importlib.util
        from pathlib import Path

        for plugin_dir in self.plugin_directories:
            plugin_path = Path(plugin_dir).expanduser()

            if not plugin_path.exists():
                continue

            self.console.print(f"Scanning for plugins in: {plugin_path}")

            for plugin_file in plugin_path.glob("*_plugin.py"):
                try:
                    self.load_plugin(plugin_file)
                except Exception as e:
                    self.console.print(f"[red]Failed to load plugin {plugin_file}: {e}[/]")

    def load_plugin(self, plugin_file: Path):
        """Load individual plugin."""
        import importlib.util

        spec = importlib.util.spec_from_file_location(plugin_file.stem, plugin_file)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        if hasattr(module, 'setup_plugin'):
            plugin = module.setup_plugin(self)
            self.plugins[plugin.name] = plugin
            plugin.register_commands()

            self.console.print(f"[green]Loaded plugin: {plugin.name} v{plugin.version}[/]")
        else:
            raise ImportError(f"Plugin {plugin_file} missing setup_plugin function")

    @self.command()
    def plugins():
        """List loaded plugins."""
        if not self.plugins:
            self.console.print("[yellow]No plugins loaded[/]")
            return

        from rich.table import Table

        table = Table(title="Loaded Plugins")
        table.add_column("Name")
        table.add_column("Version")
        table.add_column("Description")

        for plugin in self.plugins.values():
            table.add_row(plugin.name, plugin.version, plugin.description)

        self.console.print(table)

# Application startup
if __name__ == "__main__":
    app = AdvancedCLI("myapp", "2.0.0")
    app.discover_plugins()
    app.run()
```

## Enterprise Features

### Single Sign-On Integration

```python
from xlibrary.cli import CLIFramework
import jwt
import requests
from typing import Optional

class EnterpriseCLI(CLIFramework):
    """Enterprise CLI with SSO integration."""

    def __init__(self, name: str, version: str = "1.0.0"):
        super().__init__(name, version)
        self.sso_config = self.config.get_section("sso", {})
        self.current_user = None

    def authenticate(self) -> bool:
        """Perform SSO authentication."""
        if self.current_user:
            return True

        # Check for cached token
        cached_token = self.get_cached_token()
        if cached_token and self.validate_token(cached_token):
            self.current_user = self.get_user_from_token(cached_token)
            return True

        # Perform SSO login
        return self.perform_sso_login()

    def perform_sso_login(self) -> bool:
        """Perform SSO login flow."""
        import webbrowser
        import urllib.parse
        from http.server import HTTPServer, BaseHTTPRequestHandler
        import threading

        auth_url = f"{self.sso_config['auth_url']}?" + urllib.parse.urlencode({
            'client_id': self.sso_config['client_id'],
            'response_type': 'code',
            'redirect_uri': 'http://localhost:8080/callback',
            'scope': 'openid profile email'
        })

        self.console.print("Opening browser for authentication...")
        webbrowser.open(auth_url)

        # Wait for callback
        auth_code = self.wait_for_callback()
        if not auth_code:
            self.console.print("[red]Authentication failed[/]")
            return False

        # Exchange code for token
        token = self.exchange_code_for_token(auth_code)
        if token:
            self.cache_token(token)
            self.current_user = self.get_user_from_token(token)
            self.console.print(f"[green]Authenticated as {self.current_user['name']}[/]")
            return True

        return False

    def require_auth(self, func):
        """Decorator to require authentication for commands."""
        def wrapper(*args, **kwargs):
            if not self.authenticate():
                self.console.print("[red]Authentication required[/]")
                self.exit(1)
            return func(*args, **kwargs)
        return wrapper

# Usage with authentication
@cli.command()
@cli.require_auth
def secure_operation():
    """Command that requires authentication."""
    cli.console.print(f"Executing secure operation as {cli.current_user['name']}")
```

### Audit Logging and Compliance

```python
import logging
import json
from datetime import datetime
from typing import Any, Dict

class AuditLogger:
    """Enterprise audit logging."""

    def __init__(self, cli: CLIFramework):
        self.cli = cli
        self.audit_config = cli.config.get_section("audit", {})
        self.setup_audit_logging()

    def setup_audit_logging(self):
        """Configure audit logging."""
        self.audit_logger = logging.getLogger("audit")
        self.audit_logger.setLevel(logging.INFO)

        # File handler for audit logs
        handler = logging.FileHandler(self.audit_config.get("log_file", "audit.log"))
        formatter = logging.Formatter('%(asctime)s - %(message)s')
        handler.setFormatter(formatter)
        self.audit_logger.addHandler(handler)

        # Optional syslog handler for centralized logging
        if self.audit_config.get("syslog_server"):
            from logging.handlers import SysLogHandler
            syslog_handler = SysLogHandler(
                address=(
                    self.audit_config["syslog_server"],
                    self.audit_config.get("syslog_port", 514)
                )
            )
            self.audit_logger.addHandler(syslog_handler)

    def log_command_execution(
        self,
        command: str,
        arguments: Dict[str, Any],
        user: str,
        result: str = "SUCCESS",
        details: str = None
    ):
        """Log command execution for audit purposes."""
        audit_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "event_type": "COMMAND_EXECUTION",
            "user": user,
            "command": command,
            "arguments": arguments,
            "result": result,
            "details": details,
            "session_id": self.get_session_id(),
            "source_ip": self.get_source_ip()
        }

        self.audit_logger.info(json.dumps(audit_entry))

    def log_data_access(
        self,
        resource: str,
        action: str,
        user: str,
        sensitive_data: bool = False
    ):
        """Log data access events."""
        audit_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "event_type": "DATA_ACCESS",
            "user": user,
            "resource": resource,
            "action": action,
            "sensitive_data": sensitive_data,
            "session_id": self.get_session_id()
        }

        self.audit_logger.info(json.dumps(audit_entry))

# Integration with CLI commands
class AuditedCLI(CLIFramework):
    """CLI with comprehensive audit logging."""

    def __init__(self, name: str, version: str = "1.0.0"):
        super().__init__(name, version)
        self.audit_logger = AuditLogger(self)

    def execute_command(self, command_name: str, **kwargs):
        """Override command execution to add audit logging."""
        try:
            result = super().execute_command(command_name, **kwargs)

            self.audit_logger.log_command_execution(
                command=command_name,
                arguments=kwargs,
                user=self.current_user['name'] if self.current_user else 'anonymous',
                result="SUCCESS"
            )

            return result

        except Exception as e:
            self.audit_logger.log_command_execution(
                command=command_name,
                arguments=kwargs,
                user=self.current_user['name'] if self.current_user else 'anonymous',
                result="FAILURE",
                details=str(e)
            )
            raise

@cli.command()
def access_sensitive_data(dataset: str):
    """Command that accesses sensitive data."""
    cli.audit_logger.log_data_access(
        resource=f"dataset:{dataset}",
        action="READ",
        user=cli.current_user['name'],
        sensitive_data=True
    )

    # Access data logic here
    cli.console.print(f"Accessing dataset: {dataset}")
```

### Multi-Tenant Support

```python
class MultiTenantCLI(CLIFramework):
    """CLI with multi-tenant support."""

    def __init__(self, name: str, version: str = "1.0.0"):
        super().__init__(name, version)
        self.current_tenant = None
        self.tenant_config = {}

    @self.command()
    def tenant(operation: str, tenant_id: str = None):
        """Tenant management operations."""
        if operation == "list":
            self.list_tenants()
        elif operation == "switch":
            if not tenant_id:
                tenant_id = self.prompt("Enter tenant ID:")
            self.switch_tenant(tenant_id)
        elif operation == "create":
            self.create_tenant()
        elif operation == "current":
            self.show_current_tenant()

    def switch_tenant(self, tenant_id: str):
        """Switch to different tenant context."""
        if not self.validate_tenant_access(tenant_id):
            self.console.print(f"[red]Access denied to tenant: {tenant_id}[/]")
            return

        self.current_tenant = tenant_id
        self.tenant_config = self.load_tenant_config(tenant_id)

        self.console.print(f"[green]Switched to tenant: {tenant_id}[/]")
        self.update_prompt_with_tenant()

    def validate_tenant_access(self, tenant_id: str) -> bool:
        """Validate user has access to tenant."""
        user_tenants = self.current_user.get('tenants', [])
        return tenant_id in user_tenants or self.current_user.get('role') == 'admin'

    def get_tenant_scoped_config(self, key: str, default=None):
        """Get configuration value scoped to current tenant."""
        if self.current_tenant:
            tenant_key = f"tenant.{self.current_tenant}.{key}"
            return self.config.get(tenant_key, default)
        return self.config.get(key, default)

    @self.command()
    def data_operations(action: str, resource: str):
        """Tenant-scoped data operations."""
        if not self.current_tenant:
            self.console.print("[red]No tenant selected. Use 'tenant switch <id>' first.[/]")
            return

        # All operations are automatically scoped to current tenant
        scoped_resource = f"tenant:{self.current_tenant}:{resource}"

        self.console.print(f"Performing {action} on {scoped_resource}")
        # Operation logic here
```

## Performance Optimization

### Async Command Processing

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor, as_completed

class AsyncCLI(CLIFramework):
    """CLI with async processing capabilities."""

    def __init__(self, name: str, version: str = "1.0.0"):
        super().__init__(name, version)
        self.executor = ThreadPoolExecutor(max_workers=10)

    @self.command()
    async def process_files_async(
        pattern: str,
        operation: str,
        max_concurrent: int = 5
    ):
        """Process multiple files concurrently."""
        import glob

        files = glob.glob(pattern)
        if not files:
            self.console.print("[yellow]No files found[/]")
            return

        semaphore = asyncio.Semaphore(max_concurrent)

        async def process_single_file(file_path):
            async with semaphore:
                return await self.process_file_async(file_path, operation)

        self.console.print(f"Processing {len(files)} files with {operation}...")

        with self.progress() as progress:
            task = progress.add_task("Processing...", total=len(files))

            tasks = [process_single_file(file) for file in files]

            for completed_task in asyncio.as_completed(tasks):
                result = await completed_task
                progress.update(task, advance=1)

                if result["success"]:
                    self.console.print(f"[green]✓[/] {result['file']}")
                else:
                    self.console.print(f"[red]✗[/] {result['file']}: {result['error']}")

    async def process_file_async(self, file_path: str, operation: str):
        """Process single file asynchronously."""
        try:
            # Simulate async file processing
            await asyncio.sleep(0.1)  # Replace with actual async operation
            return {"file": file_path, "success": True}
        except Exception as e:
            return {"file": file_path, "success": False, "error": str(e)}

    @self.command()
    def parallel_downloads(urls: List[str], output_dir: str = "downloads"):
        """Download multiple files in parallel."""
        import os
        import requests

        os.makedirs(output_dir, exist_ok=True)

        def download_file(url):
            try:
                response = requests.get(url, stream=True)
                response.raise_for_status()

                filename = os.path.basename(url) or "download"
                filepath = os.path.join(output_dir, filename)

                with open(filepath, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        f.write(chunk)

                return {"url": url, "file": filepath, "success": True}
            except Exception as e:
                return {"url": url, "success": False, "error": str(e)}

        self.console.print(f"Downloading {len(urls)} files to {output_dir}...")

        with self.progress() as progress:
            task = progress.add_task("Downloading...", total=len(urls))

            with ThreadPoolExecutor(max_workers=5) as executor:
                future_to_url = {executor.submit(download_file, url): url for url in urls}

                for future in as_completed(future_to_url):
                    result = future.result()
                    progress.update(task, advance=1)

                    if result["success"]:
                        self.console.print(f"[green]✓[/] Downloaded {result['file']}")
                    else:
                        self.console.print(f"[red]✗[/] Failed {result['url']}: {result['error']}")
```

### Caching and Memoization

```python
from functools import wraps
import pickle
import hashlib
from pathlib import Path

class CachedCLI(CLIFramework):
    """CLI with intelligent caching."""

    def __init__(self, name: str, version: str = "1.0.0"):
        super().__init__(name, version)
        self.cache_dir = Path.home() / ".cache" / name
        self.cache_dir.mkdir(parents=True, exist_ok=True)

    def cache_result(self, ttl_seconds: int = 3600):
        """Decorator to cache command results."""
        def decorator(func):
            @wraps(func)
            def wrapper(*args, **kwargs):
                # Generate cache key
                cache_key = self.generate_cache_key(func.__name__, args, kwargs)
                cache_file = self.cache_dir / f"{cache_key}.cache"

                # Check cache
                if self.is_cache_valid(cache_file, ttl_seconds):
                    self.console.print("[dim]Using cached result[/]")
                    return self.load_from_cache(cache_file)

                # Execute function and cache result
                result = func(*args, **kwargs)
                self.save_to_cache(cache_file, result)
                return result

            return wrapper
        return decorator

    def generate_cache_key(self, func_name: str, args: tuple, kwargs: dict) -> str:
        """Generate unique cache key for function call."""
        key_data = f"{func_name}:{args}:{sorted(kwargs.items())}"
        return hashlib.md5(key_data.encode()).hexdigest()

    def is_cache_valid(self, cache_file: Path, ttl_seconds: int) -> bool:
        """Check if cached result is still valid."""
        if not cache_file.exists():
            return False

        import time
        file_age = time.time() - cache_file.stat().st_mtime
        return file_age < ttl_seconds

    @self.command()
    @cache_result(ttl_seconds=1800)  # Cache for 30 minutes
    def expensive_operation(data_source: str):
        """Expensive operation that benefits from caching."""
        self.console.print("Performing expensive computation...")

        # Simulate expensive operation
        import time
        time.sleep(2)

        result = f"Processed data from {data_source}"
        self.console.print("[green]Operation completed[/]")
        return result

    @self.command()
    def clear_cache():
        """Clear all cached results."""
        import shutil
        shutil.rmtree(self.cache_dir)
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.console.print("[green]Cache cleared[/]")
```

## Testing CLI Applications

### Comprehensive Testing Framework

```python
import pytest
from click.testing import CliRunner
from unittest.mock import patch, MagicMock

class CLITestFramework:
    """Comprehensive CLI testing utilities."""

    def __init__(self, cli_app):
        self.cli_app = cli_app
        self.runner = CliRunner()

    def run_command(self, command, input_data=None, env=None):
        """Run CLI command and return result."""
        return self.runner.invoke(
            self.cli_app,
            command.split() if isinstance(command, str) else command,
            input=input_data,
            env=env
        )

    def assert_success(self, result):
        """Assert command executed successfully."""
        assert result.exit_code == 0, f"Command failed: {result.output}"

    def assert_failure(self, result, expected_exit_code=1):
        """Assert command failed with expected exit code."""
        assert result.exit_code == expected_exit_code

    def assert_output_contains(self, result, expected_text):
        """Assert command output contains expected text."""
        assert expected_text in result.output

    def assert_output_matches(self, result, pattern):
        """Assert command output matches regex pattern."""
        import re
        assert re.search(pattern, result.output)

# Example test suite
class TestAdvancedCLI:
    """Test suite for advanced CLI features."""

    def setup_method(self):
        """Setup test environment."""
        self.test_framework = CLITestFramework(cli)

    def test_basic_command(self):
        """Test basic command execution."""
        result = self.test_framework.run_command("hello --name Alice")
        self.test_framework.assert_success(result)
        self.test_framework.assert_output_contains(result, "Hello, Alice!")

    def test_interactive_command(self):
        """Test interactive command with input."""
        result = self.test_framework.run_command(
            "setup-project",
            input_data="test-project\nweb\ny\nn\ny\n"  # Simulate user input
        )
        self.test_framework.assert_success(result)
        self.test_framework.assert_output_contains(result, "Project 'test-project' created")

    @patch('requests.get')
    def test_api_command(self, mock_get):
        """Test command that makes API calls."""
        mock_response = MagicMock()
        mock_response.json.return_value = {"status": "success"}
        mock_get.return_value = mock_response

        result = self.test_framework.run_command("api-call https://example.com/api")
        self.test_framework.assert_success(result)

    def test_error_handling(self):
        """Test error handling in commands."""
        result = self.test_framework.run_command("connect invalid-host 999999")
        self.test_framework.assert_failure(result)
        self.test_framework.assert_output_contains(result, "Invalid port number")

    def test_configuration_commands(self):
        """Test configuration management."""
        # Set configuration
        result = self.test_framework.run_command("config set database.host localhost")
        self.test_framework.assert_success(result)

        # Get configuration
        result = self.test_framework.run_command("config get database.host")
        self.test_framework.assert_success(result)
        self.test_framework.assert_output_contains(result, "localhost")

    @pytest.mark.asyncio
    async def test_async_command(self):
        """Test asynchronous command execution."""
        with patch('glob.glob', return_value=['file1.txt', 'file2.txt']):
            result = self.test_framework.run_command("process-files-async *.txt clean")
            self.test_framework.assert_success(result)

    def test_plugin_loading(self):
        """Test plugin discovery and loading."""
        result = self.test_framework.run_command("plugins")
        self.test_framework.assert_success(result)
        # Should list loaded plugins

    def test_authentication_flow(self):
        """Test authentication requirements."""
        with patch.object(self.cli_app, 'current_user', None):
            result = self.test_framework.run_command("secure-operation")
            self.test_framework.assert_failure(result)
            self.test_framework.assert_output_contains(result, "Authentication required")

    def test_audit_logging(self):
        """Test audit logging functionality."""
        with patch('logging.Logger.info') as mock_log:
            result = self.test_framework.run_command("access-sensitive-data user-data")
            self.test_framework.assert_success(result)

            # Verify audit log entry
            mock_log.assert_called()
            logged_data = mock_log.call_args[0][0]
            assert "DATA_ACCESS" in logged_data
            assert "user-data" in logged_data

# Performance testing
class TestCLIPerformance:
    """Performance testing for CLI operations."""

    def test_command_startup_time(self):
        """Test CLI startup performance."""
        import time

        start_time = time.time()
        result = CLITestFramework(cli).run_command("--help")
        end_time = time.time()

        assert end_time - start_time < 1.0, "CLI startup too slow"

    def test_large_data_processing(self):
        """Test performance with large datasets."""
        # Create test data
        test_files = [f"test_{i}.txt" for i in range(100)]

        with patch('glob.glob', return_value=test_files):
            start_time = time.time()
            result = CLITestFramework(cli).run_command("process-files *.txt")
            end_time = time.time()

            assert end_time - start_time < 10.0, "Large data processing too slow"

# Integration testing
class TestCLIIntegration:
    """Integration tests for CLI with external services."""

    @pytest.mark.integration
    def test_database_operations(self):
        """Test database integration."""
        # Requires test database setup
        result = CLITestFramework(cli).run_command("db migrate")
        assert result.exit_code == 0

    @pytest.mark.integration
    def test_api_integration(self):
        """Test API integration."""
        # Requires test API server
        result = CLITestFramework(cli).run_command("api status")
        assert result.exit_code == 0

if __name__ == "__main__":
    # Run tests
    pytest.main([__file__])
```

## Summary

The xlibrary CLI Framework provides a comprehensive foundation for building enterprise-grade command-line applications with:

- **Advanced argument processing** with custom validation and type conversion
- **Rich interactive workflows** with wizards and form handling
- **Flexible plugin architecture** supporting dynamic loading and dependency management
- **Enterprise features** including SSO, audit logging, and multi-tenant support
- **Performance optimizations** with async processing and intelligent caching
- **Comprehensive testing** framework for reliable CLI applications

This advanced guide demonstrates patterns for building sophisticated CLI tools that can scale from simple utilities to complex enterprise applications while maintaining excellent user experience and operational reliability.