# Chapter 7: Encryption Manager - User Guide - Detailed

> **ðŸ” COMPREHENSIVE CRYPTOGRAPHY OPERATIONS**
> Master advanced encryption workflows, enterprise key management, PKI operations, and security compliance with detailed examples and best practices for mission-critical applications.

## Table of Contents

- [Advanced Encryption Workflows](#advanced-encryption-workflows)
- [Enterprise Key Management](#enterprise-key-management)
- [Digital Signatures and PKI](#digital-signatures-and-pki)
- [High-Performance Operations](#high-performance-operations)
- [Security Compliance](#security-compliance)
- [Integration Patterns](#integration-patterns)
- [Troubleshooting Guide](#troubleshooting-guide)

---

## Advanced Encryption Workflows

### Multi-Algorithm Data Protection

**What this example demonstrates:** How to implement military-grade, layered encryption using multiple algorithms and security techniques. This approach provides defense-in-depth security suitable for protecting highly sensitive data in enterprise, government, or healthcare environments.

**Key concepts to notice:**
- Multi-layer security with different algorithms for different purposes
- Enterprise-grade configuration (FIPS compliance, quantum resistance)
- Strong key derivation using password-based key derivation functions (PBKDF2/Argon2)
- Audit logging for compliance and forensic analysis
- Secure vault architecture with compartmentalized data protection
- Defense against quantum computing threats

**How the layered encryption works:**
1. **Master Key Generation**: Creates a strong master key from password using cryptographic key derivation
2. **Data Encryption**: Applies symmetric encryption for bulk data (fast, efficient)
3. **Key Protection**: Uses asymmetric encryption to protect symmetric keys
4. **Integrity Verification**: Adds cryptographic hashes to detect tampering
5. **Metadata Security**: Encrypts even the file structure and access patterns
6. **Secure Storage**: Organizes encrypted data in a secure vault structure

**When to use this:** Protecting financial records, medical data, legal documents, trade secrets, or any information requiring the highest levels of security.

Implementing layered security with multiple encryption algorithms:

```python
from xlibrary.encryption import (
    EncryptionManager, SymmetricAlgorithm, AsymmetricAlgorithm,
    HashAlgorithm, SecurityLevel
)
import os
from pathlib import Path

# Initialize with enterprise security configuration
em = EncryptionManager(
    security_level=SecurityLevel.MAXIMUM,
    fips_mode=True,
    audit_logging=True,
    quantum_resistant=True
)

def create_secure_vault(vault_path: str, master_password: str):
    """Create a secure data vault with layered encryption."""

    vault_dir = Path(vault_path)
    vault_dir.mkdir(exist_ok=True)

    # 1. Generate master key with strong derivation
    master_key = em.derive_key_from_password(
        master_password,
        salt=os.urandom(32),
        key_length=32,
        iterations=500000,  # High iteration count
        algorithm=HashAlgorithm.SHA512
    )

    # 2. Create vault configuration
    vault_config = {
        "version": "1.0",
        "encryption_layers": [
            {
                "algorithm": SymmetricAlgorithm.AES_256_GCM,
                "purpose": "primary_encryption"
            },
            {
                "algorithm": SymmetricAlgorithm.CHACHA20_POLY1305,
                "purpose": "secondary_encryption"
            }
        ],
        "integrity_algorithm": HashAlgorithm.BLAKE2B,
        "compression": True
    }

    # 3. Encrypt configuration with master key
    config_encrypted = em.encrypt_data(
        str(vault_config).encode(),
        master_key,
        algorithm=SymmetricAlgorithm.AES_256_GCM
    )

    # 4. Store encrypted configuration
    with open(vault_dir / "vault.config", "wb") as f:
        f.write(config_encrypted.encrypted_data)

    print(f"Secure vault created at: {vault_path}")
    return vault_config

def store_sensitive_data(vault_path: str, data_name: str,
                        sensitive_data: bytes, master_password: str):
    """Store data with layered encryption in the vault."""

    vault_dir = Path(vault_path)

    # 1. Derive master key
    master_key = em.derive_key_from_password(
        master_password,
        salt=os.urandom(32),
        key_length=32,
        iterations=500000,
        algorithm=HashAlgorithm.SHA512
    )

    # 2. First encryption layer (AES-256-GCM)
    layer1_encrypted = em.encrypt_data(
        sensitive_data,
        master_key,
        algorithm=SymmetricAlgorithm.AES_256_GCM
    )

    # 3. Generate secondary key for second layer
    secondary_key = em.generate_key(SymmetricAlgorithm.CHACHA20_POLY1305)

    # 4. Second encryption layer (ChaCha20-Poly1305)
    layer2_encrypted = em.encrypt_data(
        layer1_encrypted.encrypted_data,
        secondary_key.key_material,
        algorithm=SymmetricAlgorithm.CHACHA20_POLY1305
    )

    # 5. Encrypt secondary key with master key
    encrypted_secondary_key = em.encrypt_data(
        secondary_key.key_material,
        master_key,
        algorithm=SymmetricAlgorithm.AES_256_GCM
    )

    # 6. Create metadata with integrity hash
    metadata = {
        "name": data_name,
        "encrypted_at": datetime.now().isoformat(),
        "integrity_hash": em.hash_data(
            sensitive_data,
            HashAlgorithm.BLAKE2B
        ).hex(),
        "encryption_layers": 2
    }

    # 7. Store all components
    data_file = vault_dir / f"{data_name}.vault"
    with open(data_file, "wb") as f:
        # Write encrypted secondary key
        f.write(len(encrypted_secondary_key.encrypted_data).to_bytes(4, 'big'))
        f.write(encrypted_secondary_key.encrypted_data)

        # Write encrypted data
        f.write(layer2_encrypted.encrypted_data)

    # 8. Store metadata separately
    metadata_encrypted = em.encrypt_data(
        str(metadata).encode(),
        master_key,
        algorithm=SymmetricAlgorithm.AES_256_GCM
    )

    with open(vault_dir / f"{data_name}.meta", "wb") as f:
        f.write(metadata_encrypted.encrypted_data)

    print(f"Data '{data_name}' stored with layered encryption")

# Usage example
vault_path = "/secure/corporate_vault"
master_password = "SuperSecureVaultPassword123!"

# Create vault
vault_config = create_secure_vault(vault_path, master_password)

# Store sensitive corporate data
sensitive_documents = [
    ("financial_report_q4.pdf", open("financial_report.pdf", "rb").read()),
    ("employee_records.json", open("employees.json", "rb").read()),
    ("trade_secrets.txt", b"Proprietary algorithm details...")
]

for doc_name, doc_data in sensitive_documents:
    store_sensitive_data(vault_path, doc_name, doc_data, master_password)
```

### Streaming Encryption for Large Files

Efficient encryption of large files with progress tracking:

```python
import asyncio
from typing import AsyncGenerator, Callable

class StreamingEncryption:
    """High-performance streaming encryption for large files."""

    def __init__(self, encryption_manager: EncryptionManager):
        self.em = encryption_manager
        self.chunk_size = 1024 * 1024  # 1MB chunks

    async def encrypt_large_file_async(
        self,
        source_path: str,
        target_path: str,
        password: str,
        progress_callback: Callable[[int, int], None] = None
    ) -> dict:
        """Asynchronously encrypt large file with progress tracking."""

        source_file = Path(source_path)
        target_file = Path(target_path)

        if not source_file.exists():
            raise FileNotFoundError(f"Source file not found: {source_path}")

        file_size = source_file.stat().st_size
        processed_bytes = 0

        # Derive encryption key
        encryption_key = self.em.derive_key_from_password(
            password,
            salt=os.urandom(32),
            key_length=32,
            iterations=100000,
            algorithm=HashAlgorithm.SHA256
        )

        # Initialize encryption context
        cipher_context = self.em.create_cipher_context(
            SymmetricAlgorithm.AES_256_GCM,
            encryption_key,
            mode="encrypt"
        )

        integrity_hash = self.em.create_hasher(HashAlgorithm.SHA256)

        try:
            with open(source_file, "rb") as src, open(target_file, "wb") as dst:
                # Write encryption header
                header = {
                    "algorithm": "AES-256-GCM",
                    "file_size": file_size,
                    "chunk_size": self.chunk_size
                }
                header_data = str(header).encode()
                dst.write(len(header_data).to_bytes(4, 'big'))
                dst.write(header_data)

                # Process file in chunks
                while True:
                    chunk = src.read(self.chunk_size)
                    if not chunk:
                        break

                    # Update integrity hash
                    integrity_hash.update(chunk)

                    # Encrypt chunk
                    encrypted_chunk = cipher_context.update(chunk)
                    dst.write(len(encrypted_chunk).to_bytes(4, 'big'))
                    dst.write(encrypted_chunk)

                    processed_bytes += len(chunk)

                    # Report progress
                    if progress_callback:
                        progress_callback(processed_bytes, file_size)

                    # Yield control for async operation
                    await asyncio.sleep(0)

                # Finalize encryption
                final_chunk = cipher_context.finalize()
                if final_chunk:
                    dst.write(len(final_chunk).to_bytes(4, 'big'))
                    dst.write(final_chunk)

                # Write integrity hash
                final_hash = integrity_hash.finalize()
                dst.write(final_hash)

        except Exception as e:
            # Clean up partial file on error
            if target_file.exists():
                target_file.unlink()
            raise

        return {
            "source_file": str(source_file),
            "encrypted_file": str(target_file),
            "file_size": file_size,
            "processed_bytes": processed_bytes,
            "integrity_hash": final_hash.hex(),
            "algorithm": "AES-256-GCM"
        }

    def encrypt_multiple_files(
        self,
        file_list: list[str],
        output_dir: str,
        password: str,
        max_concurrent: int = 4
    ) -> list[dict]:
        """Encrypt multiple files concurrently."""

        async def encrypt_batch():
            semaphore = asyncio.Semaphore(max_concurrent)
            tasks = []

            for file_path in file_list:
                source_path = Path(file_path)
                target_path = Path(output_dir) / f"{source_path.name}.enc"

                async def encrypt_with_semaphore(src, dst):
                    async with semaphore:
                        return await self.encrypt_large_file_async(
                            src, dst, password,
                            lambda current, total: print(f"Encrypting {src}: {current/total*100:.1f}%")
                        )

                task = encrypt_with_semaphore(str(source_path), str(target_path))
                tasks.append(task)

            return await asyncio.gather(*tasks, return_exceptions=True)

        return asyncio.run(encrypt_batch())

# Usage example
streaming_enc = StreamingEncryption(em)

# Encrypt large database backup
async def encrypt_database_backup():
    result = await streaming_enc.encrypt_large_file_async(
        "/backups/database_backup_50gb.sql",
        "/encrypted_backups/database_backup_50gb.sql.enc",
        "DatabaseBackupKey2024!",
        progress_callback=lambda current, total: print(f"Progress: {current/total*100:.1f}%")
    )
    print(f"Encrypted {result['file_size']} bytes")
    print(f"Integrity hash: {result['integrity_hash']}")

# Run the async encryption
asyncio.run(encrypt_database_backup())
```

---

## Enterprise Key Management

### Advanced Key Lifecycle Management

Complete key lifecycle from generation to secure destruction:

```python
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Optional
import json

class KeyUsagePolicy(Enum):
    ENCRYPTION_ONLY = "encryption_only"
    SIGNING_ONLY = "signing_only"
    KEY_EXCHANGE = "key_exchange"
    GENERAL_PURPOSE = "general_purpose"

class KeyRotationSchedule(Enum):
    DAILY = "daily"
    WEEKLY = "weekly"
    MONTHLY = "monthly"
    QUARTERLY = "quarterly"
    YEARLY = "yearly"
    MANUAL = "manual"

class EnterpriseKeyManager:
    """Enterprise-grade key management with full lifecycle control."""

    def __init__(self, encryption_manager: EncryptionManager):
        self.em = encryption_manager
        self.key_store = encryption_manager.get_key_store()
        self.audit_log = []

    def create_key_policy(
        self,
        key_name: str,
        usage_policy: KeyUsagePolicy,
        rotation_schedule: KeyRotationSchedule,
        authorized_users: List[str],
        expiry_days: Optional[int] = None,
        require_2fa: bool = True,
        backup_locations: List[str] = None
    ) -> dict:
        """Create comprehensive key policy."""

        policy = {
            "key_name": key_name,
            "usage_policy": usage_policy.value,
            "rotation_schedule": rotation_schedule.value,
            "authorized_users": authorized_users,
            "expiry_days": expiry_days,
            "require_2fa": require_2fa,
            "backup_locations": backup_locations or [],
            "created_at": datetime.now().isoformat(),
            "created_by": self._get_current_user(),
            "version": 1
        }

        # Store policy securely
        policy_data = json.dumps(policy).encode()
        policy_key = self.em.generate_key(SymmetricAlgorithm.AES_256_GCM)

        encrypted_policy = self.em.encrypt_data(
            policy_data,
            policy_key.key_material,
            algorithm=SymmetricAlgorithm.AES_256_GCM
        )

        self.key_store.store_key_policy(key_name, encrypted_policy, policy_key)

        self._audit_log(
            action="CREATE_KEY_POLICY",
            key_name=key_name,
            details=f"Policy created for {usage_policy.value}"
        )

        return policy

    def generate_enterprise_key(
        self,
        key_name: str,
        algorithm: SymmetricAlgorithm,
        policy: dict
    ) -> dict:
        """Generate key with enterprise policy enforcement."""

        # Validate policy compliance
        self._validate_policy_compliance(policy)

        # Generate primary key
        primary_key = self.em.generate_key(algorithm)

        # Create key metadata
        metadata = {
            "key_name": key_name,
            "algorithm": algorithm.value,
            "generated_at": datetime.now().isoformat(),
            "generated_by": self._get_current_user(),
            "policy_version": policy.get("version", 1),
            "rotation_due": self._calculate_rotation_date(policy),
            "usage_counter": 0,
            "last_used": None
        }

        # Generate backup keys if required
        backup_keys = []
        if policy.get("backup_locations"):
            for location in policy["backup_locations"]:
                backup_key = self.em.generate_key(algorithm)
                backup_keys.append({
                    "location": location,
                    "key": backup_key,
                    "created_at": datetime.now().isoformat()
                })

        # Store key with metadata
        self.key_store.store_enterprise_key(
            key_name=key_name,
            primary_key=primary_key,
            metadata=metadata,
            backup_keys=backup_keys
        )

        # Set up automatic rotation if required
        if policy["rotation_schedule"] != KeyRotationSchedule.MANUAL.value:
            self._schedule_key_rotation(key_name, policy)

        self._audit_log(
            action="GENERATE_ENTERPRISE_KEY",
            key_name=key_name,
            details=f"Generated {algorithm.value} key with policy {policy['usage_policy']}"
        )

        return {
            "key_name": key_name,
            "algorithm": algorithm.value,
            "metadata": metadata,
            "backup_count": len(backup_keys),
            "rotation_due": metadata["rotation_due"]
        }

    def rotate_key(self, key_name: str, preserve_old: bool = True) -> dict:
        """Rotate enterprise key with zero-downtime."""

        # Get current key and policy
        current_key_info = self.key_store.get_key_info(key_name)
        policy = self.key_store.get_key_policy(key_name)

        if not current_key_info:
            raise KeyError(f"Key not found: {key_name}")

        # Generate new key
        algorithm = SymmetricAlgorithm(current_key_info["algorithm"])
        new_key = self.em.generate_key(algorithm)

        # Update metadata
        new_metadata = current_key_info["metadata"].copy()
        new_metadata.update({
            "rotated_at": datetime.now().isoformat(),
            "rotated_by": self._get_current_user(),
            "rotation_generation": new_metadata.get("rotation_generation", 0) + 1,
            "rotation_due": self._calculate_rotation_date(policy),
            "usage_counter": 0,
            "last_used": None
        })

        # Store new key
        self.key_store.rotate_key(
            key_name=key_name,
            new_key=new_key,
            new_metadata=new_metadata,
            preserve_old=preserve_old
        )

        # Update backup keys
        if policy.get("backup_locations"):
            self._rotate_backup_keys(key_name, algorithm, policy["backup_locations"])

        # Notify authorized users
        self._notify_key_rotation(key_name, policy["authorized_users"])

        self._audit_log(
            action="ROTATE_KEY",
            key_name=key_name,
            details=f"Rotated to generation {new_metadata['rotation_generation']}"
        )

        return {
            "key_name": key_name,
            "old_generation": new_metadata["rotation_generation"] - 1,
            "new_generation": new_metadata["rotation_generation"],
            "rotated_at": new_metadata["rotated_at"],
            "next_rotation_due": new_metadata["rotation_due"]
        }

    def audit_key_usage(self, key_name: str = None, days: int = 30) -> dict:
        """Generate comprehensive key usage audit report."""

        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)

        # Filter audit log
        filtered_log = [
            entry for entry in self.audit_log
            if (key_name is None or entry.get("key_name") == key_name) and
               start_date <= datetime.fromisoformat(entry["timestamp"]) <= end_date
        ]

        # Analyze usage patterns
        usage_stats = {}
        for entry in filtered_log:
            entry_key_name = entry.get("key_name", "unknown")
            if entry_key_name not in usage_stats:
                usage_stats[entry_key_name] = {
                    "total_operations": 0,
                    "encryption_operations": 0,
                    "decryption_operations": 0,
                    "signing_operations": 0,
                    "key_rotations": 0,
                    "policy_violations": 0,
                    "last_used": None
                }

            stats = usage_stats[entry_key_name]
            stats["total_operations"] += 1

            action = entry["action"]
            if "ENCRYPT" in action:
                stats["encryption_operations"] += 1
            elif "DECRYPT" in action:
                stats["decryption_operations"] += 1
            elif "SIGN" in action:
                stats["signing_operations"] += 1
            elif "ROTATE" in action:
                stats["key_rotations"] += 1
            elif "VIOLATION" in action:
                stats["policy_violations"] += 1

            stats["last_used"] = entry["timestamp"]

        return {
            "audit_period": {
                "start_date": start_date.isoformat(),
                "end_date": end_date.isoformat(),
                "days": days
            },
            "total_audit_entries": len(filtered_log),
            "key_usage_statistics": usage_stats,
            "compliance_summary": self._generate_compliance_summary(usage_stats)
        }

    def _validate_policy_compliance(self, policy: dict) -> None:
        """Validate key policy against organizational standards."""

        required_fields = ["usage_policy", "authorized_users", "rotation_schedule"]
        for field in required_fields:
            if field not in policy:
                raise ValueError(f"Required policy field missing: {field}")

        # Validate authorized users format
        for user in policy["authorized_users"]:
            if "@" not in user:
                raise ValueError(f"Invalid user format: {user}")

        # Enforce minimum security requirements
        if policy.get("require_2fa") is False and policy["usage_policy"] != "general_purpose":
            self._audit_log(
                action="POLICY_VIOLATION",
                details="2FA disabled for sensitive key policy"
            )

    def _calculate_rotation_date(self, policy: dict) -> str:
        """Calculate next rotation date based on policy."""

        schedule = KeyRotationSchedule(policy["rotation_schedule"])
        now = datetime.now()

        rotation_intervals = {
            KeyRotationSchedule.DAILY: timedelta(days=1),
            KeyRotationSchedule.WEEKLY: timedelta(weeks=1),
            KeyRotationSchedule.MONTHLY: timedelta(days=30),
            KeyRotationSchedule.QUARTERLY: timedelta(days=90),
            KeyRotationSchedule.YEARLY: timedelta(days=365),
            KeyRotationSchedule.MANUAL: timedelta(days=36500)  # 100 years
        }

        rotation_date = now + rotation_intervals[schedule]
        return rotation_date.isoformat()

    def _audit_log(self, action: str, key_name: str = None, details: str = None) -> None:
        """Add entry to audit log."""

        entry = {
            "timestamp": datetime.now().isoformat(),
            "action": action,
            "user": self._get_current_user(),
            "key_name": key_name,
            "details": details
        }

        self.audit_log.append(entry)

        # Persist to secure storage
        self._persist_audit_entry(entry)

    def _get_current_user(self) -> str:
        """Get current user identifier."""
        return os.getenv("USER", "unknown")

    def _persist_audit_entry(self, entry: dict) -> None:
        """Persist audit entry to secure storage."""
        # Implementation would write to secure audit log storage
        pass

# Usage example
key_manager = EnterpriseKeyManager(em)

# Create enterprise key policy
production_policy = key_manager.create_key_policy(
    key_name="production_database_key",
    usage_policy=KeyUsagePolicy.ENCRYPTION_ONLY,
    rotation_schedule=KeyRotationSchedule.QUARTERLY,
    authorized_users=["dba@company.com", "security@company.com"],
    expiry_days=None,  # No expiry
    require_2fa=True,
    backup_locations=["s3://secure-keys/backup", "/mnt/secure/keystore"]
)

# Generate key with policy
key_result = key_manager.generate_enterprise_key(
    "production_database_key",
    SymmetricAlgorithm.AES_256_GCM,
    production_policy
)

print(f"Generated enterprise key: {key_result['key_name']}")
print(f"Next rotation due: {key_result['rotation_due']}")

# Generate audit report
audit_report = key_manager.audit_key_usage("production_database_key", days=90)
print(f"Key used {audit_report['key_usage_statistics']['production_database_key']['total_operations']} times")
```

---

## Digital Signatures and PKI

### Certificate Authority Operations

Complete PKI implementation with certificate lifecycle management:

```python
from cryptography import x509
from cryptography.x509.oid import NameOID, ExtensionOID
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
import ipaddress
from typing import List, Union

class EnterprisePKI:
    """Enterprise Public Key Infrastructure management."""

    def __init__(self, encryption_manager: EncryptionManager):
        self.em = encryption_manager
        self.ca_store = {}
        self.certificate_store = {}
        self.crl_store = {}

    def create_root_ca(
        self,
        ca_name: str,
        subject_info: dict,
        key_algorithm: AsymmetricAlgorithm = AsymmetricAlgorithm.RSA_4096,
        validity_years: int = 20,
        path_length: int = 2
    ) -> dict:
        """Create root Certificate Authority."""

        # Generate CA key pair
        ca_key_pair = self.em.generate_key_pair(key_algorithm, f"{ca_name}_key")

        # Create subject name
        subject_name = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, subject_info["country"]),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, subject_info["state"]),
            x509.NameAttribute(NameOID.LOCALITY_NAME, subject_info["city"]),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, subject_info["organization"]),
            x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, subject_info.get("unit", "IT Department")),
            x509.NameAttribute(NameOID.COMMON_NAME, subject_info["common_name"]),
        ])

        # Create certificate
        certificate = x509.CertificateBuilder().subject_name(
            subject_name
        ).issuer_name(
            subject_name  # Self-signed
        ).public_key(
            ca_key_pair.public_key
        ).serial_number(
            self._generate_serial_number()
        ).not_valid_before(
            datetime.utcnow()
        ).not_valid_after(
            datetime.utcnow() + timedelta(days=validity_years * 365)
        ).add_extension(
            x509.BasicConstraints(ca=True, path_length=path_length),
            critical=True
        ).add_extension(
            x509.KeyUsage(
                digital_signature=True,
                content_commitment=False,
                key_encipherment=False,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=True,
                crl_sign=True,
                encipher_only=False,
                decipher_only=False
            ),
            critical=True
        ).add_extension(
            x509.SubjectKeyIdentifier.from_public_key(ca_key_pair.public_key),
            critical=False
        ).add_extension(
            x509.AuthorityKeyIdentifier.from_issuer_public_key(ca_key_pair.public_key),
            critical=False
        ).sign(ca_key_pair.private_key, hashes.SHA256())

        # Store CA certificate and key
        ca_info = {
            "name": ca_name,
            "certificate": certificate,
            "private_key": ca_key_pair.private_key,
            "public_key": ca_key_pair.public_key,
            "subject_info": subject_info,
            "created_at": datetime.utcnow().isoformat(),
            "validity_years": validity_years,
            "path_length": path_length,
            "serial_number": certificate.serial_number
        }

        self.ca_store[ca_name] = ca_info

        return {
            "ca_name": ca_name,
            "certificate_pem": certificate.public_bytes(serialization.Encoding.PEM).decode(),
            "serial_number": str(certificate.serial_number),
            "valid_from": certificate.not_valid_before.isoformat(),
            "valid_until": certificate.not_valid_after.isoformat(),
            "subject": subject_info["common_name"]
        }

    def issue_server_certificate(
        self,
        ca_name: str,
        server_info: dict,
        san_dns: List[str] = None,
        san_ips: List[str] = None,
        validity_days: int = 365,
        key_algorithm: AsymmetricAlgorithm = AsymmetricAlgorithm.RSA_2048
    ) -> dict:
        """Issue server certificate for TLS/SSL."""

        if ca_name not in self.ca_store:
            raise ValueError(f"CA not found: {ca_name}")

        ca_info = self.ca_store[ca_name]

        # Generate server key pair
        server_key_pair = self.em.generate_key_pair(
            key_algorithm,
            f"{server_info['common_name']}_key"
        )

        # Create subject name
        subject_name = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, server_info["country"]),
            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, server_info["state"]),
            x509.NameAttribute(NameOID.LOCALITY_NAME, server_info["city"]),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, server_info["organization"]),
            x509.NameAttribute(NameOID.COMMON_NAME, server_info["common_name"]),
        ])

        # Build certificate
        cert_builder = x509.CertificateBuilder().subject_name(
            subject_name
        ).issuer_name(
            ca_info["certificate"].subject
        ).public_key(
            server_key_pair.public_key
        ).serial_number(
            self._generate_serial_number()
        ).not_valid_before(
            datetime.utcnow()
        ).not_valid_after(
            datetime.utcnow() + timedelta(days=validity_days)
        ).add_extension(
            x509.BasicConstraints(ca=False, path_length=None),
            critical=True
        ).add_extension(
            x509.KeyUsage(
                digital_signature=True,
                content_commitment=False,
                key_encipherment=True,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=False,
                crl_sign=False,
                encipher_only=False,
                decipher_only=False
            ),
            critical=True
        ).add_extension(
            x509.ExtendedKeyUsage([
                x509.oid.ExtendedKeyUsageOID.SERVER_AUTH,
                x509.oid.ExtendedKeyUsageOID.CLIENT_AUTH
            ]),
            critical=True
        ).add_extension(
            x509.SubjectKeyIdentifier.from_public_key(server_key_pair.public_key),
            critical=False
        ).add_extension(
            x509.AuthorityKeyIdentifier.from_issuer_public_key(ca_info["public_key"]),
            critical=False
        )

        # Add Subject Alternative Names if provided
        san_list = []
        if san_dns:
            san_list.extend([x509.DNSName(dns) for dns in san_dns])
        if san_ips:
            san_list.extend([x509.IPAddress(ipaddress.ip_address(ip)) for ip in san_ips])

        if san_list:
            cert_builder = cert_builder.add_extension(
                x509.SubjectAlternativeName(san_list),
                critical=False
            )

        # Sign certificate
        certificate = cert_builder.sign(ca_info["private_key"], hashes.SHA256())

        # Store certificate
        cert_id = f"{server_info['common_name']}_{certificate.serial_number}"
        cert_info = {
            "certificate": certificate,
            "private_key": server_key_pair.private_key,
            "public_key": server_key_pair.public_key,
            "ca_name": ca_name,
            "server_info": server_info,
            "san_dns": san_dns or [],
            "san_ips": san_ips or [],
            "issued_at": datetime.utcnow().isoformat(),
            "validity_days": validity_days,
            "serial_number": certificate.serial_number,
            "status": "active"
        }

        self.certificate_store[cert_id] = cert_info

        return {
            "certificate_id": cert_id,
            "certificate_pem": certificate.public_bytes(serialization.Encoding.PEM).decode(),
            "private_key_pem": server_key_pair.private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            ).decode(),
            "serial_number": str(certificate.serial_number),
            "valid_from": certificate.not_valid_before.isoformat(),
            "valid_until": certificate.not_valid_after.isoformat(),
            "subject": server_info["common_name"],
            "san_dns": san_dns or [],
            "san_ips": san_ips or []
        }

    def issue_client_certificate(
        self,
        ca_name: str,
        client_info: dict,
        email: str,
        validity_days: int = 365
    ) -> dict:
        """Issue client certificate for authentication."""

        if ca_name not in self.ca_store:
            raise ValueError(f"CA not found: {ca_name}")

        ca_info = self.ca_store[ca_name]

        # Generate client key pair
        client_key_pair = self.em.generate_key_pair(
            AsymmetricAlgorithm.RSA_2048,
            f"{client_info['common_name']}_client_key"
        )

        # Create subject name
        subject_name = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, client_info["country"]),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, client_info["organization"]),
            x509.NameAttribute(NameOID.COMMON_NAME, client_info["common_name"]),
            x509.NameAttribute(NameOID.EMAIL_ADDRESS, email),
        ])

        # Build certificate
        certificate = x509.CertificateBuilder().subject_name(
            subject_name
        ).issuer_name(
            ca_info["certificate"].subject
        ).public_key(
            client_key_pair.public_key
        ).serial_number(
            self._generate_serial_number()
        ).not_valid_before(
            datetime.utcnow()
        ).not_valid_after(
            datetime.utcnow() + timedelta(days=validity_days)
        ).add_extension(
            x509.BasicConstraints(ca=False, path_length=None),
            critical=True
        ).add_extension(
            x509.KeyUsage(
                digital_signature=True,
                content_commitment=True,
                key_encipherment=True,
                data_encipherment=False,
                key_agreement=False,
                key_cert_sign=False,
                crl_sign=False,
                encipher_only=False,
                decipher_only=False
            ),
            critical=True
        ).add_extension(
            x509.ExtendedKeyUsage([
                x509.oid.ExtendedKeyUsageOID.CLIENT_AUTH,
                x509.oid.ExtendedKeyUsageOID.EMAIL_PROTECTION
            ]),
            critical=True
        ).add_extension(
            x509.SubjectKeyIdentifier.from_public_key(client_key_pair.public_key),
            critical=False
        ).add_extension(
            x509.AuthorityKeyIdentifier.from_issuer_public_key(ca_info["public_key"]),
            critical=False
        ).add_extension(
            x509.SubjectAlternativeName([
                x509.RFC822Name(email)
            ]),
            critical=False
        ).sign(ca_info["private_key"], hashes.SHA256())

        # Store certificate
        cert_id = f"{client_info['common_name']}_client_{certificate.serial_number}"
        cert_info = {
            "certificate": certificate,
            "private_key": client_key_pair.private_key,
            "public_key": client_key_pair.public_key,
            "ca_name": ca_name,
            "client_info": client_info,
            "email": email,
            "issued_at": datetime.utcnow().isoformat(),
            "validity_days": validity_days,
            "serial_number": certificate.serial_number,
            "status": "active",
            "certificate_type": "client"
        }

        self.certificate_store[cert_id] = cert_info

        return {
            "certificate_id": cert_id,
            "certificate_pem": certificate.public_bytes(serialization.Encoding.PEM).decode(),
            "private_key_pem": client_key_pair.private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=serialization.NoEncryption()
            ).decode(),
            "serial_number": str(certificate.serial_number),
            "valid_from": certificate.not_valid_before.isoformat(),
            "valid_until": certificate.not_valid_after.isoformat(),
            "subject": client_info["common_name"],
            "email": email
        }

    def validate_certificate_chain(self, cert_id: str) -> dict:
        """Validate certificate chain and status."""

        if cert_id not in self.certificate_store:
            return {"valid": False, "error": "Certificate not found"}

        cert_info = self.certificate_store[cert_id]
        certificate = cert_info["certificate"]
        ca_name = cert_info["ca_name"]

        validation_result = {
            "valid": True,
            "certificate_id": cert_id,
            "serial_number": str(certificate.serial_number),
            "checks": {}
        }

        # Check expiration
        now = datetime.utcnow()
        if now < certificate.not_valid_before:
            validation_result["valid"] = False
            validation_result["checks"]["time_validity"] = "Not yet valid"
        elif now > certificate.not_valid_after:
            validation_result["valid"] = False
            validation_result["checks"]["time_validity"] = "Expired"
        else:
            validation_result["checks"]["time_validity"] = "Valid"

        # Check revocation status
        if cert_info["status"] == "revoked":
            validation_result["valid"] = False
            validation_result["checks"]["revocation"] = "Revoked"
        else:
            validation_result["checks"]["revocation"] = "Not revoked"

        # Check CA validity
        if ca_name in self.ca_store:
            ca_cert = self.ca_store[ca_name]["certificate"]
            if now > ca_cert.not_valid_after:
                validation_result["valid"] = False
                validation_result["checks"]["ca_validity"] = "CA expired"
            else:
                validation_result["checks"]["ca_validity"] = "CA valid"
        else:
            validation_result["valid"] = False
            validation_result["checks"]["ca_validity"] = "CA not found"

        # Check signature
        try:
            ca_public_key = self.ca_store[ca_name]["public_key"]
            ca_public_key.verify(
                certificate.signature,
                certificate.tbs_certificate_bytes,
                padding.PKCS1v15(),
                certificate.signature_hash_algorithm
            )
            validation_result["checks"]["signature"] = "Valid signature"
        except Exception as e:
            validation_result["valid"] = False
            validation_result["checks"]["signature"] = f"Invalid signature: {str(e)}"

        return validation_result

    def revoke_certificate(
        self,
        cert_id: str,
        reason: str = "unspecified",
        revocation_date: datetime = None
    ) -> dict:
        """Revoke certificate and update CRL."""

        if cert_id not in self.certificate_store:
            raise ValueError(f"Certificate not found: {cert_id}")

        cert_info = self.certificate_store[cert_id]

        # Mark certificate as revoked
        cert_info["status"] = "revoked"
        cert_info["revoked_at"] = (revocation_date or datetime.utcnow()).isoformat()
        cert_info["revocation_reason"] = reason

        # Update CRL
        ca_name = cert_info["ca_name"]
        self._update_crl(ca_name, cert_info["serial_number"], reason, revocation_date)

        return {
            "certificate_id": cert_id,
            "serial_number": str(cert_info["serial_number"]),
            "revoked_at": cert_info["revoked_at"],
            "reason": reason,
            "status": "revoked"
        }

    def generate_crl(self, ca_name: str) -> str:
        """Generate Certificate Revocation List."""

        if ca_name not in self.ca_store:
            raise ValueError(f"CA not found: {ca_name}")

        ca_info = self.ca_store[ca_name]

        # Get revoked certificates for this CA
        revoked_certs = []
        for cert_info in self.certificate_store.values():
            if (cert_info["ca_name"] == ca_name and
                cert_info["status"] == "revoked"):

                revoked_cert = x509.RevokedCertificateBuilder().serial_number(
                    cert_info["serial_number"]
                ).revocation_date(
                    datetime.fromisoformat(cert_info["revoked_at"])
                ).add_extension(
                    x509.ReasonFlags[cert_info["revocation_reason"].upper()],
                    critical=False
                ).build()

                revoked_certs.append(revoked_cert)

        # Create CRL
        crl = x509.CertificateRevocationListBuilder().issuer_name(
            ca_info["certificate"].subject
        ).last_update(
            datetime.utcnow()
        ).next_update(
            datetime.utcnow() + timedelta(days=7)
        )

        # Add revoked certificates
        for revoked_cert in revoked_certs:
            crl = crl.add_revoked_certificate(revoked_cert)

        # Sign CRL
        crl = crl.sign(ca_info["private_key"], hashes.SHA256())

        # Store CRL
        self.crl_store[ca_name] = {
            "crl": crl,
            "generated_at": datetime.utcnow().isoformat(),
            "revoked_count": len(revoked_certs)
        }

        return crl.public_bytes(serialization.Encoding.PEM).decode()

    def _generate_serial_number(self) -> int:
        """Generate unique serial number."""
        return int.from_bytes(os.urandom(16), 'big')

    def _update_crl(
        self,
        ca_name: str,
        serial_number: int,
        reason: str,
        revocation_date: datetime = None
    ) -> None:
        """Update Certificate Revocation List."""
        # This would update the CRL storage
        pass

# Usage example
pki = EnterprisePKI(em)

# Create root CA
root_ca = pki.create_root_ca(
    ca_name="CompanyRootCA",
    subject_info={
        "country": "US",
        "state": "California",
        "city": "San Francisco",
        "organization": "Company Inc",
        "unit": "IT Security",
        "common_name": "Company Root CA"
    },
    key_algorithm=AsymmetricAlgorithm.RSA_4096,
    validity_years=20
)

print(f"Created Root CA: {root_ca['ca_name']}")
print(f"Valid until: {root_ca['valid_until']}")

# Issue server certificate
server_cert = pki.issue_server_certificate(
    ca_name="CompanyRootCA",
    server_info={
        "country": "US",
        "state": "California",
        "city": "San Francisco",
        "organization": "Company Inc",
        "common_name": "api.company.com"
    },
    san_dns=["api.company.com", "www.company.com", "company.com"],
    san_ips=["203.0.113.1", "203.0.113.2"],
    validity_days=365
)

print(f"Issued server certificate: {server_cert['certificate_id']}")
print(f"SAN DNS: {server_cert['san_dns']}")

# Issue client certificate
client_cert = pki.issue_client_certificate(
    ca_name="CompanyRootCA",
    client_info={
        "country": "US",
        "organization": "Company Inc",
        "common_name": "John Doe"
    },
    email="john.doe@company.com",
    validity_days=365
)

print(f"Issued client certificate: {client_cert['certificate_id']}")

# Validate certificates
server_validation = pki.validate_certificate_chain(server_cert['certificate_id'])
print(f"Server certificate valid: {server_validation['valid']}")

# Generate CRL
crl_pem = pki.generate_crl("CompanyRootCA")
print(f"Generated CRL with {len(crl_pem.splitlines())} lines")
```

---

## High-Performance Operations

### Parallel Processing Framework

Efficient cryptographic operations using multiple CPU cores:

```python
import multiprocessing
import concurrent.futures
from queue import Queue
import threading
import time
from typing import Callable, Iterator, Any

class HighPerformanceEncryption:
    """High-performance encryption with parallel processing."""

    def __init__(self, encryption_manager: EncryptionManager):
        self.em = encryption_manager
        self.cpu_count = multiprocessing.cpu_count()
        self.optimal_workers = max(2, self.cpu_count - 1)

    def parallel_file_encryption(
        self,
        file_paths: List[str],
        output_directory: str,
        password: str,
        algorithm: SymmetricAlgorithm = SymmetricAlgorithm.AES_256_GCM,
        max_workers: int = None,
        progress_callback: Callable[[str, int, int], None] = None
    ) -> List[dict]:
        """Encrypt multiple files in parallel."""

        max_workers = max_workers or self.optimal_workers
        output_dir = Path(output_directory)
        output_dir.mkdir(exist_ok=True)

        def encrypt_single_file(file_path: str) -> dict:
            """Encrypt a single file with progress tracking."""

            source_file = Path(file_path)
            output_file = output_dir / f"{source_file.name}.enc"

            try:
                # Get file size for progress tracking
                file_size = source_file.stat().st_size
                processed = 0

                def chunk_progress(current: int, total: int):
                    nonlocal processed
                    processed = current
                    if progress_callback:
                        progress_callback(file_path, current, total)

                # Encrypt file
                result = self.em.encrypt_file(
                    str(source_file),
                    str(output_file),
                    password=password,
                    algorithm=algorithm,
                    progress_callback=chunk_progress
                )

                return {
                    "source_file": file_path,
                    "encrypted_file": str(output_file),
                    "file_size": file_size,
                    "success": True,
                    "error": None,
                    "processing_time": result.get("processing_time", 0)
                }

            except Exception as e:
                return {
                    "source_file": file_path,
                    "encrypted_file": None,
                    "file_size": 0,
                    "success": False,
                    "error": str(e),
                    "processing_time": 0
                }

        # Process files in parallel
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_file = {
                executor.submit(encrypt_single_file, file_path): file_path
                for file_path in file_paths
            }

            results = []
            for future in concurrent.futures.as_completed(future_to_file):
                result = future.result()
                results.append(result)

        return results

    def streaming_batch_encryption(
        self,
        data_stream: Iterator[bytes],
        output_stream,
        password: str,
        chunk_size: int = 64 * 1024,
        buffer_size: int = 100
    ) -> dict:
        """Stream encryption with producer-consumer pattern."""

        # Create thread-safe queues
        input_queue = Queue(maxsize=buffer_size)
        output_queue = Queue(maxsize=buffer_size)

        # Statistics
        stats = {
            "chunks_processed": 0,
            "bytes_processed": 0,
            "start_time": time.time(),
            "errors": []
        }

        # Create encryption context
        encryption_key = self.em.derive_key_from_password(
            password,
            salt=os.urandom(32),
            key_length=32
        )

        cipher_context = self.em.create_cipher_context(
            SymmetricAlgorithm.AES_256_GCM,
            encryption_key,
            mode="encrypt"
        )

        def producer():
            """Read data chunks and put them in input queue."""
            try:
                for chunk in data_stream:
                    if chunk:
                        input_queue.put(("data", chunk))
                        stats["bytes_processed"] += len(chunk)
                    else:
                        break
                input_queue.put(("end", None))
            except Exception as e:
                input_queue.put(("error", str(e)))
                stats["errors"].append(str(e))

        def processor():
            """Process chunks from input queue and put results in output queue."""
            try:
                while True:
                    msg_type, data = input_queue.get()

                    if msg_type == "end":
                        # Finalize encryption
                        final_chunk = cipher_context.finalize()
                        if final_chunk:
                            output_queue.put(("data", final_chunk))
                        output_queue.put(("end", None))
                        break
                    elif msg_type == "error":
                        output_queue.put(("error", data))
                        break
                    elif msg_type == "data":
                        # Encrypt chunk
                        encrypted_chunk = cipher_context.update(data)
                        output_queue.put(("data", encrypted_chunk))
                        stats["chunks_processed"] += 1

                    input_queue.task_done()

            except Exception as e:
                output_queue.put(("error", str(e)))
                stats["errors"].append(str(e))

        def consumer():
            """Write encrypted chunks from output queue to stream."""
            try:
                while True:
                    msg_type, data = output_queue.get()

                    if msg_type == "end":
                        break
                    elif msg_type == "error":
                        stats["errors"].append(data)
                        break
                    elif msg_type == "data" and data:
                        output_stream.write(data)

                    output_queue.task_done()

            except Exception as e:
                stats["errors"].append(str(e))

        # Start threads
        producer_thread = threading.Thread(target=producer)
        processor_thread = threading.Thread(target=processor)
        consumer_thread = threading.Thread(target=consumer)

        producer_thread.start()
        processor_thread.start()
        consumer_thread.start()

        # Wait for completion
        producer_thread.join()
        processor_thread.join()
        consumer_thread.join()

        stats["end_time"] = time.time()
        stats["processing_time"] = stats["end_time"] - stats["start_time"]
        stats["throughput_mbps"] = (stats["bytes_processed"] / 1024 / 1024) / stats["processing_time"]

        return stats

    def benchmark_algorithms(
        self,
        test_data_size: int = 10 * 1024 * 1024,  # 10MB
        algorithms: List[SymmetricAlgorithm] = None
    ) -> dict:
        """Benchmark different encryption algorithms."""

        if algorithms is None:
            algorithms = [
                SymmetricAlgorithm.AES_256_GCM,
                SymmetricAlgorithm.CHACHA20_POLY1305,
                SymmetricAlgorithm.AES_256_CBC,
                SymmetricAlgorithm.FERNET
            ]

        # Generate test data
        test_data = os.urandom(test_data_size)
        password = "BenchmarkPassword123!"

        benchmark_results = {}

        for algorithm in algorithms:
            print(f"Benchmarking {algorithm.value}...")

            # Encryption benchmark
            start_time = time.time()

            try:
                encrypted_result = self.em.encrypt_data(
                    test_data,
                    password,
                    algorithm=algorithm
                )

                encryption_time = time.time() - start_time

                # Decryption benchmark
                start_time = time.time()

                decrypted_data = self.em.decrypt_data(
                    encrypted_result.encrypted_data,
                    password,
                    algorithm=algorithm,
                    nonce=encrypted_result.nonce
                )

                decryption_time = time.time() - start_time

                # Verify data integrity
                data_integrity = test_data == decrypted_data

                # Calculate metrics
                throughput_enc = (test_data_size / 1024 / 1024) / encryption_time  # MB/s
                throughput_dec = (test_data_size / 1024 / 1024) / decryption_time  # MB/s

                benchmark_results[algorithm.value] = {
                    "encryption_time": encryption_time,
                    "decryption_time": decryption_time,
                    "total_time": encryption_time + decryption_time,
                    "encryption_throughput_mbps": throughput_enc,
                    "decryption_throughput_mbps": throughput_dec,
                    "encrypted_size": len(encrypted_result.encrypted_data),
                    "compression_ratio": len(encrypted_result.encrypted_data) / test_data_size,
                    "data_integrity": data_integrity,
                    "success": True,
                    "error": None
                }

            except Exception as e:
                benchmark_results[algorithm.value] = {
                    "success": False,
                    "error": str(e)
                }

        # Find best performing algorithm
        successful_results = {
            alg: result for alg, result in benchmark_results.items()
            if result.get("success", False)
        }

        if successful_results:
            best_encryption = min(
                successful_results.items(),
                key=lambda x: x[1]["encryption_time"]
            )

            best_throughput = max(
                successful_results.items(),
                key=lambda x: x[1]["encryption_throughput_mbps"]
            )

            benchmark_results["summary"] = {
                "test_data_size_mb": test_data_size / 1024 / 1024,
                "fastest_encryption": best_encryption[0],
                "fastest_encryption_time": best_encryption[1]["encryption_time"],
                "highest_throughput": best_throughput[0],
                "highest_throughput_mbps": best_throughput[1]["encryption_throughput_mbps"],
                "cpu_count": self.cpu_count,
                "optimal_workers": self.optimal_workers
            }

        return benchmark_results

# Usage example
high_perf = HighPerformanceEncryption(em)

# Parallel file encryption
files_to_encrypt = [
    "/data/file1.txt",
    "/data/file2.pdf",
    "/data/file3.docx",
    "/data/file4.xlsx"
]

def progress_tracker(file_path: str, current: int, total: int):
    filename = Path(file_path).name
    percent = (current / total) * 100
    print(f"{filename}: {percent:.1f}% ({current}/{total} bytes)")

parallel_results = high_perf.parallel_file_encryption(
    files_to_encrypt,
    "/encrypted_output",
    "ParallelEncryptionKey2024!",
    max_workers=4,
    progress_callback=progress_tracker
)

successful_encryptions = [r for r in parallel_results if r["success"]]
print(f"Successfully encrypted {len(successful_encryptions)} files")

# Algorithm benchmarking
print("Running algorithm benchmarks...")
benchmark_results = high_perf.benchmark_algorithms(
    test_data_size=50 * 1024 * 1024,  # 50MB test
    algorithms=[
        SymmetricAlgorithm.AES_256_GCM,
        SymmetricAlgorithm.CHACHA20_POLY1305
    ]
)

print("\nBenchmark Results:")
for algorithm, results in benchmark_results.items():
    if algorithm != "summary" and results.get("success"):
        print(f"{algorithm}:")
        print(f"  Encryption: {results['encryption_throughput_mbps']:.1f} MB/s")
        print(f"  Decryption: {results['decryption_throughput_mbps']:.1f} MB/s")

if "summary" in benchmark_results:
    summary = benchmark_results["summary"]
    print(f"\nBest Performance:")
    print(f"  Fastest: {summary['fastest_encryption']} ({summary['fastest_encryption_time']:.3f}s)")
    print(f"  Highest throughput: {summary['highest_throughput']} ({summary['highest_throughput_mbps']:.1f} MB/s)")
```

---

## Security Compliance

### FIPS 140-2 Compliance Framework

Implementation of Federal Information Processing Standards compliance:

```python
from enum import Enum
from typing import Dict, List, Optional, Set
import json
import logging
from datetime import datetime, timedelta

class FIPSSecurityLevel(Enum):
    LEVEL_1 = 1  # Software cryptographic modules
    LEVEL_2 = 2  # Software modules with tamper-evident seals
    LEVEL_3 = 3  # Software modules with tamper-resistant hardware
    LEVEL_4 = 4  # Software modules with tamper-responsive hardware

class ComplianceStandard(Enum):
    FIPS_140_2 = "FIPS 140-2"
    COMMON_CRITERIA = "Common Criteria"
    NIST_SP_800_53 = "NIST SP 800-53"
    SUITE_B = "NSA Suite B"
    CNSS_POLICY = "CNSS Policy"

class FIPSCompliantEncryption:
    """FIPS 140-2 compliant encryption operations."""

    # FIPS 140-2 approved algorithms
    FIPS_APPROVED_SYMMETRIC = {
        "AES": [128, 192, 256],
        "3DES": [168]  # Triple DES with 3 keys
    }

    FIPS_APPROVED_ASYMMETRIC = {
        "RSA": [2048, 3072, 4096],
        "ECDSA": ["P-256", "P-384", "P-521"],
        "DSA": [2048, 3072]
    }

    FIPS_APPROVED_HASH = {
        "SHA-2": [224, 256, 384, 512],
        "SHA-3": [224, 256, 384, 512]
    }

    FIPS_APPROVED_MAC = {
        "HMAC": ["SHA-224", "SHA-256", "SHA-384", "SHA-512"],
        "CMAC": ["AES"]
    }

    def __init__(
        self,
        encryption_manager: EncryptionManager,
        security_level: FIPSSecurityLevel = FIPSSecurityLevel.LEVEL_2,
        enforce_fips_only: bool = True
    ):
        self.em = encryption_manager
        self.security_level = security_level
        self.enforce_fips_only = enforce_fips_only
        self.compliance_log = []

        # Configure encryption manager for FIPS compliance
        self._configure_fips_mode()

    def _configure_fips_mode(self) -> None:
        """Configure encryption manager for FIPS 140-2 compliance."""

        # Set FIPS-only mode
        self.em.set_fips_mode(True)

        # Disable non-FIPS algorithms
        if self.enforce_fips_only:
            self.em.disable_algorithms([
                "ChaCha20-Poly1305",  # Not FIPS approved
                "Blowfish",           # Not FIPS approved
                "RC4",                # Deprecated
                "MD5",                # Deprecated
                "SHA-1"               # Deprecated for most uses
            ])

        # Enable audit logging
        self.em.enable_audit_logging(True)

        self._compliance_log(
            "FIPS_CONFIGURATION",
            f"Configured FIPS 140-2 Level {self.security_level.value} compliance"
        )

    def encrypt_data_fips(
        self,
        data: bytes,
        key_material: bytes,
        algorithm: str = "AES-256-GCM"
    ) -> dict:
        """FIPS 140-2 compliant data encryption."""

        # Validate algorithm is FIPS approved
        if not self._validate_fips_algorithm(algorithm, "symmetric"):
            raise ValueError(f"Algorithm {algorithm} is not FIPS 140-2 approved")

        # Perform pre-encryption checks
        self._perform_security_checks(data, key_material)

        try:
            # Use FIPS-approved random number generator
            nonce = self._generate_fips_random(12)  # 96-bit nonce for GCM

            # Encrypt using approved algorithm
            encrypted_result = self.em.encrypt_data_with_nonce(
                data,
                key_material,
                nonce,
                algorithm
            )

            # Generate authentication tag
            auth_tag = self._generate_authentication_tag(
                encrypted_result.encrypted_data,
                key_material
            )

            # Create FIPS-compliant result
            fips_result = {
                "encrypted_data": encrypted_result.encrypted_data,
                "nonce": nonce,
                "auth_tag": auth_tag,
                "algorithm": algorithm,
                "fips_level": self.security_level.value,
                "timestamp": datetime.utcnow().isoformat(),
                "integrity_check": True
            }

            self._compliance_log(
                "FIPS_ENCRYPTION",
                f"Data encrypted using {algorithm} (FIPS Level {self.security_level.value})"
            )

            return fips_result

        except Exception as e:
            self._compliance_log(
                "FIPS_ENCRYPTION_ERROR",
                f"Encryption failed: {str(e)}"
            )
            raise

    def decrypt_data_fips(
        self,
        encrypted_data: bytes,
        key_material: bytes,
        nonce: bytes,
        auth_tag: bytes,
        algorithm: str = "AES-256-GCM"
    ) -> bytes:
        """FIPS 140-2 compliant data decryption."""

        # Validate algorithm is FIPS approved
        if not self._validate_fips_algorithm(algorithm, "symmetric"):
            raise ValueError(f"Algorithm {algorithm} is not FIPS 140-2 approved")

        try:
            # Verify authentication tag first
            expected_auth_tag = self._generate_authentication_tag(
                encrypted_data,
                key_material
            )

            if not self._constant_time_compare(auth_tag, expected_auth_tag):
                self._compliance_log(
                    "FIPS_AUTH_FAILURE",
                    "Authentication tag verification failed"
                )
                raise ValueError("Authentication verification failed")

            # Decrypt data
            decrypted_data = self.em.decrypt_data_with_nonce(
                encrypted_data,
                key_material,
                nonce,
                algorithm
            )

            self._compliance_log(
                "FIPS_DECRYPTION",
                f"Data decrypted using {algorithm} (FIPS Level {self.security_level.value})"
            )

            return decrypted_data

        except Exception as e:
            self._compliance_log(
                "FIPS_DECRYPTION_ERROR",
                f"Decryption failed: {str(e)}"
            )
            raise

    def generate_fips_key(
        self,
        algorithm: str,
        key_length: int,
        purpose: str = "encryption"
    ) -> dict:
        """Generate FIPS 140-2 compliant cryptographic key."""

        # Validate key parameters
        if not self._validate_fips_key_params(algorithm, key_length):
            raise ValueError(f"Key parameters not FIPS approved: {algorithm}/{key_length}")

        # Generate key using FIPS-approved RNG
        key_material = self._generate_fips_random(key_length // 8)

        # Perform key validation tests
        if not self._validate_key_quality(key_material):
            # Regenerate if key fails quality tests
            key_material = self._generate_fips_random(key_length // 8)

        # Create key metadata
        key_info = {
            "key_material": key_material,
            "algorithm": algorithm,
            "key_length": key_length,
            "purpose": purpose,
            "fips_level": self.security_level.value,
            "generated_at": datetime.utcnow().isoformat(),
            "expires_at": (datetime.utcnow() + timedelta(days=365)).isoformat(),
            "usage_counter": 0,
            "max_usage": 1000000  # FIPS usage limit
        }

        self._compliance_log(
            "FIPS_KEY_GENERATION",
            f"Generated {algorithm} key ({key_length} bits) for {purpose}"
        )

        return key_info

    def sign_data_fips(
        self,
        data: bytes,
        private_key: bytes,
        algorithm: str = "RSA-PSS-SHA256"
    ) -> dict:
        """FIPS 140-2 compliant digital signature generation."""

        # Validate signing algorithm
        if not self._validate_fips_algorithm(algorithm, "signature"):
            raise ValueError(f"Signature algorithm {algorithm} is not FIPS approved")

        try:
            # Hash data using FIPS-approved hash function
            data_hash = self.em.hash_data(data, "SHA-256")

            # Generate signature
            signature = self.em.sign_hash(data_hash, private_key, algorithm)

            # Create signature result
            signature_result = {
                "signature": signature,
                "algorithm": algorithm,
                "hash_algorithm": "SHA-256",
                "data_hash": data_hash,
                "timestamp": datetime.utcnow().isoformat(),
                "fips_level": self.security_level.value
            }

            self._compliance_log(
                "FIPS_SIGNATURE",
                f"Data signed using {algorithm} (FIPS Level {self.security_level.value})"
            )

            return signature_result

        except Exception as e:
            self._compliance_log(
                "FIPS_SIGNATURE_ERROR",
                f"Signature generation failed: {str(e)}"
            )
            raise

    def verify_signature_fips(
        self,
        data: bytes,
        signature: bytes,
        public_key: bytes,
        algorithm: str = "RSA-PSS-SHA256"
    ) -> bool:
        """FIPS 140-2 compliant signature verification."""

        # Validate signing algorithm
        if not self._validate_fips_algorithm(algorithm, "signature"):
            raise ValueError(f"Signature algorithm {algorithm} is not FIPS approved")

        try:
            # Hash data using same algorithm as signing
            data_hash = self.em.hash_data(data, "SHA-256")

            # Verify signature
            is_valid = self.em.verify_signature(
                data_hash,
                signature,
                public_key,
                algorithm
            )

            self._compliance_log(
                "FIPS_SIGNATURE_VERIFICATION",
                f"Signature verification: {'valid' if is_valid else 'invalid'}"
            )

            return is_valid

        except Exception as e:
            self._compliance_log(
                "FIPS_VERIFICATION_ERROR",
                f"Signature verification failed: {str(e)}"
            )
            return False

    def generate_compliance_report(
        self,
        standards: List[ComplianceStandard] = None,
        time_period_days: int = 30
    ) -> dict:
        """Generate comprehensive compliance report."""

        if standards is None:
            standards = [ComplianceStandard.FIPS_140_2]

        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=time_period_days)

        # Filter compliance log entries
        relevant_entries = [
            entry for entry in self.compliance_log
            if start_date <= datetime.fromisoformat(entry["timestamp"]) <= end_date
        ]

        # Analyze compliance
        compliance_analysis = {}

        for standard in standards:
            if standard == ComplianceStandard.FIPS_140_2:
                analysis = self._analyze_fips_compliance(relevant_entries)
            elif standard == ComplianceStandard.COMMON_CRITERIA:
                analysis = self._analyze_common_criteria_compliance(relevant_entries)
            else:
                analysis = {"status": "not_implemented"}

            compliance_analysis[standard.value] = analysis

        # Generate report
        report = {
            "report_generated": datetime.utcnow().isoformat(),
            "reporting_period": {
                "start_date": start_date.isoformat(),
                "end_date": end_date.isoformat(),
                "days": time_period_days
            },
            "security_level": self.security_level.value,
            "total_operations": len(relevant_entries),
            "compliance_analysis": compliance_analysis,
            "recommendations": self._generate_compliance_recommendations(compliance_analysis),
            "audit_trail": relevant_entries[-100:]  # Last 100 entries
        }

        return report

    def _validate_fips_algorithm(self, algorithm: str, category: str) -> bool:
        """Validate if algorithm is FIPS 140-2 approved."""

        algorithm_upper = algorithm.upper()

        if category == "symmetric":
            return any(
                alg in algorithm_upper for alg in self.FIPS_APPROVED_SYMMETRIC.keys()
            )
        elif category == "asymmetric":
            return any(
                alg in algorithm_upper for alg in self.FIPS_APPROVED_ASYMMETRIC.keys()
            )
        elif category == "hash":
            return any(
                alg in algorithm_upper for alg in self.FIPS_APPROVED_HASH.keys()
            )
        elif category == "signature":
            return "RSA" in algorithm_upper or "ECDSA" in algorithm_upper or "DSA" in algorithm_upper

        return False

    def _perform_security_checks(self, data: bytes, key_material: bytes) -> None:
        """Perform pre-operation security checks."""

        # Check key material quality
        if not self._validate_key_quality(key_material):
            raise ValueError("Key material failed security validation")

        # Check for suspicious data patterns
        if self._detect_suspicious_patterns(data):
            self._compliance_log(
                "SECURITY_WARNING",
                "Suspicious data patterns detected"
            )

    def _generate_fips_random(self, length: int) -> bytes:
        """Generate FIPS 140-2 approved random bytes."""
        # This would use a FIPS-approved RNG
        # For demonstration, using os.urandom which may be FIPS-approved on some systems
        return os.urandom(length)

    def _generate_authentication_tag(self, data: bytes, key: bytes) -> bytes:
        """Generate HMAC authentication tag."""
        return self.em.hmac(data, key, "SHA-256")

    def _constant_time_compare(self, a: bytes, b: bytes) -> bool:
        """Constant-time comparison to prevent timing attacks."""
        if len(a) != len(b):
            return False

        result = 0
        for x, y in zip(a, b):
            result |= x ^ y

        return result == 0

    def _validate_fips_key_params(self, algorithm: str, key_length: int) -> bool:
        """Validate key parameters against FIPS requirements."""

        algorithm_upper = algorithm.upper()

        if "AES" in algorithm_upper:
            return key_length in [128, 192, 256]
        elif "RSA" in algorithm_upper:
            return key_length >= 2048
        elif "3DES" in algorithm_upper:
            return key_length == 168

        return False

    def _validate_key_quality(self, key_material: bytes) -> bool:
        """Validate cryptographic key quality."""

        # Check for all zeros
        if all(b == 0 for b in key_material):
            return False

        # Check for all ones
        if all(b == 255 for b in key_material):
            return False

        # Check for insufficient entropy (simplified test)
        unique_bytes = len(set(key_material))
        if unique_bytes < len(key_material) // 4:
            return False

        return True

    def _detect_suspicious_patterns(self, data: bytes) -> bool:
        """Detect suspicious patterns in data."""

        # Check for repeated patterns
        if len(data) > 16:
            chunk_size = 16
            chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
            unique_chunks = set(chunks)

            # Flag if more than 50% chunks are identical
            if len(unique_chunks) < len(chunks) * 0.5:
                return True

        return False

    def _analyze_fips_compliance(self, log_entries: List[dict]) -> dict:
        """Analyze FIPS 140-2 compliance from log entries."""

        total_operations = len(log_entries)
        fips_operations = len([
            entry for entry in log_entries
            if "FIPS" in entry.get("action", "")
        ])

        violations = len([
            entry for entry in log_entries
            if "VIOLATION" in entry.get("action", "") or "ERROR" in entry.get("action", "")
        ])

        compliance_rate = (fips_operations / total_operations * 100) if total_operations > 0 else 100

        return {
            "standard": "FIPS 140-2",
            "compliance_rate": compliance_rate,
            "total_operations": total_operations,
            "compliant_operations": fips_operations,
            "violations": violations,
            "status": "compliant" if compliance_rate >= 95 and violations == 0 else "non_compliant"
        }

    def _compliance_log(self, action: str, details: str) -> None:
        """Add entry to compliance audit log."""

        entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "action": action,
            "details": details,
            "security_level": self.security_level.value
        }

        self.compliance_log.append(entry)

        # Also log to system audit log
        logging.info(f"FIPS Compliance: {action} - {details}")

# Usage example
fips_encryption = FIPSCompliantEncryption(
    em,
    security_level=FIPSSecurityLevel.LEVEL_2,
    enforce_fips_only=True
)

# Generate FIPS-compliant key
fips_key = fips_encryption.generate_fips_key(
    algorithm="AES",
    key_length=256,
    purpose="data_encryption"
)

print(f"Generated FIPS key: {fips_key['algorithm']}-{fips_key['key_length']}")

# Encrypt data with FIPS compliance
sensitive_data = b"Classified government document content"
encrypted_result = fips_encryption.encrypt_data_fips(
    sensitive_data,
    fips_key["key_material"],
    algorithm="AES-256-GCM"
)

print(f"Data encrypted with FIPS Level {encrypted_result['fips_level']} compliance")

# Generate compliance report
compliance_report = fips_encryption.generate_compliance_report(
    standards=[ComplianceStandard.FIPS_140_2],
    time_period_days=30
)

print(f"FIPS Compliance Rate: {compliance_report['compliance_analysis']['FIPS 140-2']['compliance_rate']:.1f}%")
print(f"Total Operations: {compliance_report['total_operations']}")
```

---

## Integration Patterns

### Enterprise System Integration

Seamless integration with enterprise authentication and authorization systems:

```python
from typing import Protocol, Dict, Any, Optional, List
import requests
import jwt
from ldap3 import Server, Connection
import asyncio
import aiohttp

class AuthenticationProvider(Protocol):
    """Protocol for authentication providers."""

    def authenticate(self, username: str, credentials: Dict[str, Any]) -> Dict[str, Any]:
        """Authenticate user and return authentication result."""
        ...

    def get_user_permissions(self, username: str) -> List[str]:
        """Get user permissions for encryption operations."""
        ...

class LDAPAuthProvider:
    """LDAP authentication provider."""

    def __init__(self, server_uri: str, bind_dn: str, bind_password: str):
        self.server = Server(server_uri)
        self.bind_dn = bind_dn
        self.bind_password = bind_password

    def authenticate(self, username: str, credentials: Dict[str, Any]) -> Dict[str, Any]:
        """Authenticate against LDAP directory."""

        try:
            user_dn = f"uid={username},{self.bind_dn}"
            conn = Connection(
                self.server,
                user=user_dn,
                password=credentials.get("password"),
                auto_bind=True
            )

            # Get user attributes
            conn.search(
                user_dn,
                "(objectClass=person)",
                attributes=["cn", "mail", "memberOf"]
            )

            if conn.entries:
                user_entry = conn.entries[0]
                return {
                    "authenticated": True,
                    "username": username,
                    "display_name": str(user_entry.cn),
                    "email": str(user_entry.mail),
                    "groups": [str(group) for group in user_entry.memberOf] if user_entry.memberOf else [],
                    "auth_method": "ldap"
                }

            return {"authenticated": False, "error": "User not found"}

        except Exception as e:
            return {"authenticated": False, "error": str(e)}

    def get_user_permissions(self, username: str) -> List[str]:
        """Get encryption permissions based on LDAP groups."""

        auth_result = self.authenticate(username, {})
        if not auth_result.get("authenticated"):
            return []

        permissions = []
        groups = auth_result.get("groups", [])

        # Map LDAP groups to encryption permissions
        group_permission_mapping = {
            "cn=Encryption_Admins": ["encrypt", "decrypt", "key_management", "sign", "verify"],
            "cn=Encryption_Users": ["encrypt", "decrypt", "sign", "verify"],
            "cn=Key_Managers": ["key_management", "key_rotation"],
            "cn=Security_Officers": ["audit", "compliance_reporting"],
        }

        for group in groups:
            if group in group_permission_mapping:
                permissions.extend(group_permission_mapping[group])

        return list(set(permissions))  # Remove duplicates

class SAMLAuthProvider:
    """SAML authentication provider."""

    def __init__(self, idp_metadata_url: str, sp_entity_id: str):
        self.idp_metadata_url = idp_metadata_url
        self.sp_entity_id = sp_entity_id
        self.idp_metadata = self._load_idp_metadata()

    def authenticate(self, username: str, credentials: Dict[str, Any]) -> Dict[str, Any]:
        """Authenticate using SAML assertion."""

        saml_token = credentials.get("saml_token")
        if not saml_token:
            return {"authenticated": False, "error": "SAML token required"}

        try:
            # Validate SAML token (simplified)
            assertion = self._validate_saml_token(saml_token)

            return {
                "authenticated": True,
                "username": assertion.get("username"),
                "display_name": assertion.get("display_name"),
                "email": assertion.get("email"),
                "attributes": assertion.get("attributes", {}),
                "auth_method": "saml"
            }

        except Exception as e:
            return {"authenticated": False, "error": str(e)}

    def get_user_permissions(self, username: str) -> List[str]:
        """Extract permissions from SAML attributes."""
        # Implementation would extract permissions from SAML attributes
        return ["encrypt", "decrypt", "sign", "verify"]

    def _load_idp_metadata(self) -> Dict[str, Any]:
        """Load IdP metadata."""
        # Implementation would load and parse SAML IdP metadata
        return {}

    def _validate_saml_token(self, token: str) -> Dict[str, Any]:
        """Validate SAML token."""
        # Implementation would validate SAML assertion
        return {}

class EnterpriseEncryptionManager:
    """Enterprise encryption manager with authentication integration."""

    def __init__(
        self,
        encryption_manager: EncryptionManager,
        auth_provider: AuthenticationProvider,
        enable_audit: bool = True
    ):
        self.em = encryption_manager
        self.auth_provider = auth_provider
        self.enable_audit = enable_audit
        self.active_sessions = {}
        self.audit_log = []

    def create_authenticated_session(
        self,
        username: str,
        credentials: Dict[str, Any],
        session_timeout: int = 3600
    ) -> Dict[str, Any]:
        """Create authenticated encryption session."""

        # Authenticate user
        auth_result = self.auth_provider.authenticate(username, credentials)
        if not auth_result.get("authenticated"):
            self._audit_log(
                "AUTHENTICATION_FAILED",
                username,
                f"Failed authentication: {auth_result.get('error')}"
            )
            raise ValueError(f"Authentication failed: {auth_result.get('error')}")

        # Get user permissions
        permissions = self.auth_provider.get_user_permissions(username)

        # Create session
        session_id = self._generate_session_id()
        session_data = {
            "session_id": session_id,
            "username": username,
            "display_name": auth_result.get("display_name"),
            "email": auth_result.get("email"),
            "permissions": permissions,
            "auth_method": auth_result.get("auth_method"),
            "created_at": datetime.utcnow().isoformat(),
            "expires_at": (datetime.utcnow() + timedelta(seconds=session_timeout)).isoformat(),
            "last_activity": datetime.utcnow().isoformat()
        }

        self.active_sessions[session_id] = session_data

        self._audit_log(
            "SESSION_CREATED",
            username,
            f"Session created with permissions: {', '.join(permissions)}"
        )

        return {
            "session_id": session_id,
            "permissions": permissions,
            "expires_at": session_data["expires_at"]
        }

    def encrypt_with_authorization(
        self,
        session_id: str,
        data: bytes,
        password: str,
        algorithm: SymmetricAlgorithm = SymmetricAlgorithm.AES_256_GCM,
        classification: str = "unclassified"
    ) -> Dict[str, Any]:
        """Encrypt data with user authorization check."""

        # Validate session
        session = self._validate_session(session_id)
        if not session:
            raise ValueError("Invalid or expired session")

        # Check encryption permission
        if "encrypt" not in session["permissions"]:
            self._audit_log(
                "AUTHORIZATION_DENIED",
                session["username"],
                "Encryption operation denied - insufficient permissions"
            )
            raise PermissionError("Encryption permission denied")

        # Check classification level authorization
        if not self._check_classification_access(session, classification):
            self._audit_log(
                "CLASSIFICATION_DENIED",
                session["username"],
                f"Access denied for classification: {classification}"
            )
            raise PermissionError(f"Access denied for classification: {classification}")

        # Perform encryption
        try:
            encrypted_result = self.em.encrypt_data(
                data,
                password,
                algorithm=algorithm
            )

            # Add metadata
            encryption_metadata = {
                "encrypted_by": session["username"],
                "encrypted_at": datetime.utcnow().isoformat(),
                "algorithm": algorithm.value,
                "classification": classification,
                "session_id": session_id
            }

            result = {
                "encrypted_data": encrypted_result.encrypted_data,
                "nonce": encrypted_result.nonce,
                "metadata": encryption_metadata
            }

            self._audit_log(
                "DATA_ENCRYPTED",
                session["username"],
                f"Encrypted {len(data)} bytes using {algorithm.value} (Classification: {classification})"
            )

            # Update session activity
            self._update_session_activity(session_id)

            return result

        except Exception as e:
            self._audit_log(
                "ENCRYPTION_ERROR",
                session["username"],
                f"Encryption failed: {str(e)}"
            )
            raise

    def decrypt_with_authorization(
        self,
        session_id: str,
        encrypted_data: bytes,
        nonce: bytes,
        password: str,
        metadata: Dict[str, Any],
        algorithm: SymmetricAlgorithm = SymmetricAlgorithm.AES_256_GCM
    ) -> bytes:
        """Decrypt data with user authorization check."""

        # Validate session
        session = self._validate_session(session_id)
        if not session:
            raise ValueError("Invalid or expired session")

        # Check decryption permission
        if "decrypt" not in session["permissions"]:
            self._audit_log(
                "AUTHORIZATION_DENIED",
                session["username"],
                "Decryption operation denied - insufficient permissions"
            )
            raise PermissionError("Decryption permission denied")

        # Check classification access
        classification = metadata.get("classification", "unclassified")
        if not self._check_classification_access(session, classification):
            self._audit_log(
                "CLASSIFICATION_DENIED",
                session["username"],
                f"Decryption denied for classification: {classification}"
            )
            raise PermissionError(f"Decryption denied for classification: {classification}")

        # Perform decryption
        try:
            decrypted_data = self.em.decrypt_data_with_nonce(
                encrypted_data,
                password,
                nonce,
                algorithm
            )

            self._audit_log(
                "DATA_DECRYPTED",
                session["username"],
                f"Decrypted {len(decrypted_data)} bytes (Classification: {classification})"
            )

            # Update session activity
            self._update_session_activity(session_id)

            return decrypted_data

        except Exception as e:
            self._audit_log(
                "DECRYPTION_ERROR",
                session["username"],
                f"Decryption failed: {str(e)}"
            )
            raise

    def rotate_keys_with_authorization(
        self,
        session_id: str,
        key_pattern: str
    ) -> Dict[str, Any]:
        """Rotate keys with proper authorization."""

        # Validate session
        session = self._validate_session(session_id)
        if not session:
            raise ValueError("Invalid or expired session")

        # Check key management permission
        if "key_management" not in session["permissions"]:
            self._audit_log(
                "AUTHORIZATION_DENIED",
                session["username"],
                "Key rotation denied - insufficient permissions"
            )
            raise PermissionError("Key management permission denied")

        try:
            # Perform key rotation
            rotation_result = self.em.rotate_keys(key_pattern)

            self._audit_log(
                "KEY_ROTATION",
                session["username"],
                f"Rotated keys matching pattern: {key_pattern}"
            )

            return rotation_result

        except Exception as e:
            self._audit_log(
                "KEY_ROTATION_ERROR",
                session["username"],
                f"Key rotation failed: {str(e)}"
            )
            raise

    def _validate_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Validate session and check expiration."""

        if session_id not in self.active_sessions:
            return None

        session = self.active_sessions[session_id]
        expires_at = datetime.fromisoformat(session["expires_at"])

        if datetime.utcnow() > expires_at:
            # Session expired
            del self.active_sessions[session_id]
            return None

        return session

    def _check_classification_access(
        self,
        session: Dict[str, Any],
        classification: str
    ) -> bool:
        """Check if user has access to specified classification level."""

        # Define classification hierarchy
        classification_levels = {
            "unclassified": 0,
            "confidential": 1,
            "secret": 2,
            "top_secret": 3
        }

        user_clearance = self._get_user_clearance(session)
        required_level = classification_levels.get(classification.lower(), 0)
        user_level = classification_levels.get(user_clearance.lower(), 0)

        return user_level >= required_level

    def _get_user_clearance(self, session: Dict[str, Any]) -> str:
        """Get user's security clearance level."""
        # This would typically query user's clearance from HR/Security system
        # For demonstration, using simple permission-based mapping

        permissions = session.get("permissions", [])

        if "top_secret" in permissions:
            return "top_secret"
        elif "secret" in permissions:
            return "secret"
        elif "confidential" in permissions:
            return "confidential"
        else:
            return "unclassified"

    def _generate_session_id(self) -> str:
        """Generate unique session identifier."""
        return os.urandom(32).hex()

    def _update_session_activity(self, session_id: str) -> None:
        """Update session last activity timestamp."""
        if session_id in self.active_sessions:
            self.active_sessions[session_id]["last_activity"] = datetime.utcnow().isoformat()

    def _audit_log(self, action: str, username: str, details: str) -> None:
        """Add entry to security audit log."""

        entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "action": action,
            "username": username,
            "details": details,
            "source_ip": self._get_client_ip()
        }

        self.audit_log.append(entry)

        if self.enable_audit:
            # Write to secure audit log storage
            self._persist_audit_entry(entry)

    def _get_client_ip(self) -> str:
        """Get client IP address."""
        # Implementation would extract client IP from request context
        return "127.0.0.1"

    def _persist_audit_entry(self, entry: Dict[str, Any]) -> None:
        """Persist audit entry to secure storage."""
        # Implementation would write to secure audit log system
        pass

# Usage example
# Set up authentication provider
ldap_auth = LDAPAuthProvider(
    server_uri="ldap://corp.company.com:389",
    bind_dn="ou=users,dc=company,dc=com",
    bind_password="ldap_bind_password"
)

# Create enterprise encryption manager
enterprise_em = EnterpriseEncryptionManager(
    encryption_manager=em,
    auth_provider=ldap_auth,
    enable_audit=True
)

# Authenticate and create session
session_info = enterprise_em.create_authenticated_session(
    username="john.doe",
    credentials={"password": "user_password"},
    session_timeout=3600
)

print(f"Created session: {session_info['session_id']}")
print(f"User permissions: {', '.join(session_info['permissions'])}")

# Encrypt data with authorization
sensitive_data = b"Confidential business strategy document"
encrypted_result = enterprise_em.encrypt_with_authorization(
    session_id=session_info["session_id"],
    data=sensitive_data,
    password="document_encryption_key",
    algorithm=SymmetricAlgorithm.AES_256_GCM,
    classification="confidential"
)

print(f"Data encrypted by: {encrypted_result['metadata']['encrypted_by']}")
print(f"Classification: {encrypted_result['metadata']['classification']}")

# Decrypt with authorization
decrypted_data = enterprise_em.decrypt_with_authorization(
    session_id=session_info["session_id"],
    encrypted_data=encrypted_result["encrypted_data"],
    nonce=encrypted_result["nonce"],
    password="document_encryption_key",
    metadata=encrypted_result["metadata"]
)

print(f"Successfully decrypted {len(decrypted_data)} bytes")
```

---

## Troubleshooting Guide

### Common Issues and Solutions

Comprehensive troubleshooting guide for encryption operations:

```python
from enum import Enum
from typing import Dict, List, Optional, Any
import traceback
import sys
import logging

class ErrorSeverity(Enum):
    INFO = "info"
    WARNING = "warning"
    ERROR = "error"
    CRITICAL = "critical"

class ErrorCategory(Enum):
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    CRYPTOGRAPHY = "cryptography"
    KEY_MANAGEMENT = "key_management"
    PERFORMANCE = "performance"
    CONFIGURATION = "configuration"
    COMPLIANCE = "compliance"

class EncryptionTroubleshooter:
    """Comprehensive encryption troubleshooting system."""

    def __init__(self, encryption_manager: EncryptionManager):
        self.em = encryption_manager
        self.diagnostic_log = []
        self.known_issues = self._load_known_issues()

    def diagnose_issue(
        self,
        error: Exception,
        operation_context: Dict[str, Any],
        auto_fix: bool = False
    ) -> Dict[str, Any]:
        """Diagnose encryption-related issue and suggest solutions."""

        error_info = {
            "error_type": type(error).__name__,
            "error_message": str(error),
            "traceback": traceback.format_exc(),
            "operation": operation_context.get("operation", "unknown"),
            "timestamp": datetime.utcnow().isoformat()
        }

        # Categorize error
        category = self._categorize_error(error, operation_context)
        severity = self._assess_severity(error, operation_context)

        # Find known solutions
        solutions = self._find_solutions(error_info, category)

        # Run diagnostics
        diagnostic_results = self._run_diagnostics(operation_context)

        # Generate recommendations
        recommendations = self._generate_recommendations(
            error_info,
            category,
            severity,
            diagnostic_results
        )

        diagnosis = {
            "error_info": error_info,
            "category": category.value,
            "severity": severity.value,
            "diagnostic_results": diagnostic_results,
            "known_solutions": solutions,
            "recommendations": recommendations,
            "auto_fix_available": self._can_auto_fix(error_info, category),
            "diagnosis_id": self._generate_diagnosis_id()
        }

        # Auto-fix if requested and possible
        if auto_fix and diagnosis["auto_fix_available"]:
            fix_result = self._attempt_auto_fix(diagnosis)
            diagnosis["auto_fix_result"] = fix_result

        self._log_diagnosis(diagnosis)
        return diagnosis

    def run_system_diagnostics(self) -> Dict[str, Any]:
        """Run comprehensive system diagnostics."""

        diagnostics = {
            "timestamp": datetime.utcnow().isoformat(),
            "encryption_manager_status": self._check_encryption_manager(),
            "key_store_status": self._check_key_store(),
            "algorithm_availability": self._check_algorithms(),
            "performance_metrics": self._check_performance(),
            "compliance_status": self._check_compliance(),
            "system_resources": self._check_system_resources(),
            "network_connectivity": self._check_network(),
            "recommendations": []
        }

        # Generate system-wide recommendations
        diagnostics["recommendations"] = self._generate_system_recommendations(diagnostics)

        return diagnostics

    def _categorize_error(
        self,
        error: Exception,
        context: Dict[str, Any]
    ) -> ErrorCategory:
        """Categorize error by type and context."""

        error_message = str(error).lower()
        error_type = type(error).__name__

        # Authentication errors
        if any(term in error_message for term in ["authentication", "login", "credential"]):
            return ErrorCategory.AUTHENTICATION

        # Authorization errors
        if any(term in error_message for term in ["permission", "access denied", "unauthorized"]):
            return ErrorCategory.AUTHORIZATION

        # Cryptographic errors
        if any(term in error_message for term in ["decrypt", "encrypt", "signature", "hash", "cipher"]):
            return ErrorCategory.CRYPTOGRAPHY

        # Key management errors
        if any(term in error_message for term in ["key", "certificate", "pki"]):
            return ErrorCategory.KEY_MANAGEMENT

        # Performance errors
        if any(term in error_message for term in ["timeout", "memory", "performance"]):
            return ErrorCategory.PERFORMANCE

        # Configuration errors
        if any(term in error_message for term in ["config", "setting", "parameter"]):
            return ErrorCategory.CONFIGURATION

        # Compliance errors
        if any(term in error_message for term in ["fips", "compliance", "standard"]):
            return ErrorCategory.COMPLIANCE

        return ErrorCategory.CRYPTOGRAPHY  # Default

    def _assess_severity(
        self,
        error: Exception,
        context: Dict[str, Any]
    ) -> ErrorSeverity:
        """Assess error severity based on type and impact."""

        error_type = type(error).__name__

        # Critical errors that compromise security
        critical_errors = [
            "SecurityError",
            "CertificateExpiredError",
            "KeyCompromisedError",
            "AuthenticationError"
        ]

        if error_type in critical_errors:
            return ErrorSeverity.CRITICAL

        # Errors that prevent operations
        blocking_errors = [
            "PermissionError",
            "KeyNotFoundError",
            "DecryptionError",
            "SignatureVerificationError"
        ]

        if error_type in blocking_errors:
            return ErrorSeverity.ERROR

        # Performance or minor issues
        warning_errors = [
            "PerformanceWarning",
            "ConfigurationWarning",
            "DeprecationWarning"
        ]

        if error_type in warning_errors:
            return ErrorSeverity.WARNING

        return ErrorSeverity.ERROR  # Default to error

    def _find_solutions(
        self,
        error_info: Dict[str, Any],
        category: ErrorCategory
    ) -> List[Dict[str, Any]]:
        """Find known solutions for the error."""

        solutions = []
        error_message = error_info["error_message"].lower()

        # Common cryptographic issues
        if category == ErrorCategory.CRYPTOGRAPHY:
            if "padding" in error_message:
                solutions.append({
                    "issue": "Invalid padding",
                    "cause": "Data was encrypted with different padding scheme or corrupted",
                    "solution": "Verify encryption parameters and data integrity",
                    "code_example": """
# Verify padding scheme matches
try:
    decrypted = em.decrypt_data(data, key, algorithm=SymmetricAlgorithm.AES_256_GCM)
except PaddingError:
    # Try different algorithm or check data integrity
    decrypted = em.decrypt_data(data, key, algorithm=SymmetricAlgorithm.AES_256_CBC)
"""
                })

            if "nonce" in error_message or "iv" in error_message:
                solutions.append({
                    "issue": "Invalid nonce/IV",
                    "cause": "Nonce or IV is incorrect, missing, or reused",
                    "solution": "Ensure unique nonce for each encryption operation",
                    "code_example": """
# Always generate fresh nonce
nonce = os.urandom(12)  # 96 bits for GCM
encrypted = em.encrypt_data_with_nonce(data, key, nonce, algorithm)
"""
                })

        # Key management issues
        elif category == ErrorCategory.KEY_MANAGEMENT:
            if "expired" in error_message:
                solutions.append({
                    "issue": "Key or certificate expired",
                    "cause": "Cryptographic material has passed expiration date",
                    "solution": "Rotate keys and update certificates",
                    "code_example": """
# Check key expiration and rotate
key_info = em.get_key_info(key_name)
if datetime.now() > datetime.fromisoformat(key_info['expires_at']):
    new_key = em.rotate_key(key_name)
"""
                })

            if "not found" in error_message:
                solutions.append({
                    "issue": "Key not found",
                    "cause": "Referenced key does not exist in key store",
                    "solution": "Generate new key or check key name",
                    "code_example": """
# Generate missing key
try:
    key = em.get_key(key_name)
except KeyNotFoundError:
    key = em.generate_key(SymmetricAlgorithm.AES_256_GCM, key_name)
"""
                })

        # Authentication issues
        elif category == ErrorCategory.AUTHENTICATION:
            solutions.append({
                "issue": "Authentication failure",
                "cause": "Invalid credentials or authentication token",
                "solution": "Verify credentials and check token expiration",
                "code_example": """
# Refresh authentication token
try:
    session = em.authenticate(username, password)
except AuthenticationError:
    # Clear cached credentials and retry
    em.clear_auth_cache()
    session = em.authenticate(username, password)
"""
            })

        return solutions

    def _run_diagnostics(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Run specific diagnostics based on operation context."""

        diagnostics = {}

        operation = context.get("operation", "")

        if "encrypt" in operation.lower():
            diagnostics.update(self._diagnose_encryption(context))
        elif "decrypt" in operation.lower():
            diagnostics.update(self._diagnose_decryption(context))
        elif "sign" in operation.lower():
            diagnostics.update(self._diagnose_signing(context))
        elif "key" in operation.lower():
            diagnostics.update(self._diagnose_key_operations(context))

        return diagnostics

    def _diagnose_encryption(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Diagnose encryption-specific issues."""

        diagnostics = {
            "algorithm_support": True,
            "key_availability": True,
            "data_size_valid": True,
            "memory_sufficient": True
        }

        # Check algorithm support
        algorithm = context.get("algorithm")
        if algorithm and not self.em.is_algorithm_supported(algorithm):
            diagnostics["algorithm_support"] = False
            diagnostics["algorithm_issue"] = f"Algorithm {algorithm} not supported"

        # Check key availability
        key_name = context.get("key_name")
        if key_name:
            try:
                self.em.get_key(key_name)
            except:
                diagnostics["key_availability"] = False
                diagnostics["key_issue"] = f"Key {key_name} not accessible"

        # Check data size
        data_size = context.get("data_size", 0)
        if data_size > 100 * 1024 * 1024:  # 100MB
            diagnostics["data_size_warning"] = "Large data size may impact performance"

        return diagnostics

    def _diagnose_decryption(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Diagnose decryption-specific issues."""

        diagnostics = {
            "data_integrity": True,
            "key_match": True,
            "nonce_present": True
        }

        # Check if encrypted data appears intact
        encrypted_data = context.get("encrypted_data")
        if encrypted_data and len(encrypted_data) < 16:
            diagnostics["data_integrity"] = False
            diagnostics["integrity_issue"] = "Encrypted data too short to be valid"

        # Check nonce presence for GCM mode
        algorithm = context.get("algorithm", "")
        nonce = context.get("nonce")
        if "gcm" in algorithm.lower() and not nonce:
            diagnostics["nonce_present"] = False
            diagnostics["nonce_issue"] = "GCM mode requires nonce for decryption"

        return diagnostics

    def _diagnose_signing(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Diagnose digital signature issues."""

        diagnostics = {
            "private_key_available": True,
            "public_key_valid": True,
            "hash_algorithm_supported": True
        }

        # Check private key for signing
        if context.get("operation") == "sign":
            private_key = context.get("private_key")
            if not private_key:
                diagnostics["private_key_available"] = False
                diagnostics["private_key_issue"] = "Private key required for signing"

        # Check public key for verification
        elif context.get("operation") == "verify":
            public_key = context.get("public_key")
            if not public_key:
                diagnostics["public_key_valid"] = False
                diagnostics["public_key_issue"] = "Public key required for verification"

        return diagnostics

    def _diagnose_key_operations(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Diagnose key management issues."""

        diagnostics = {
            "key_store_accessible": True,
            "permissions_valid": True,
            "key_format_valid": True
        }

        # Test key store access
        try:
            self.em.get_key_store().list_keys()
        except:
            diagnostics["key_store_accessible"] = False
            diagnostics["key_store_issue"] = "Key store not accessible"

        # Check key format if provided
        key_data = context.get("key_data")
        if key_data and not self._validate_key_format(key_data):
            diagnostics["key_format_valid"] = False
            diagnostics["format_issue"] = "Key data format invalid"

        return diagnostics

    def _generate_recommendations(
        self,
        error_info: Dict[str, Any],
        category: ErrorCategory,
        severity: ErrorSeverity,
        diagnostic_results: Dict[str, Any]
    ) -> List[str]:
        """Generate specific recommendations based on diagnosis."""

        recommendations = []

        # High-priority recommendations for critical issues
        if severity == ErrorSeverity.CRITICAL:
            recommendations.append("URGENT: Investigate potential security compromise")
            recommendations.append("Review audit logs for suspicious activity")
            recommendations.append("Consider revoking and rotating all related keys")

        # Category-specific recommendations
        if category == ErrorCategory.CRYPTOGRAPHY:
            if not diagnostic_results.get("algorithm_support", True):
                recommendations.append("Install required cryptographic library or update system")
            if not diagnostic_results.get("data_integrity", True):
                recommendations.append("Verify data source and transmission integrity")

        elif category == ErrorCategory.KEY_MANAGEMENT:
            if not diagnostic_results.get("key_availability", True):
                recommendations.append("Generate missing keys or restore from backup")
            if not diagnostic_results.get("key_store_accessible", True):
                recommendations.append("Check key store configuration and permissions")

        elif category == ErrorCategory.PERFORMANCE:
            recommendations.append("Consider using hardware acceleration if available")
            recommendations.append("Implement streaming for large data operations")
            recommendations.append("Check system resource usage")

        # General recommendations
        recommendations.extend([
            "Enable debug logging for detailed error information",
            "Test with minimal example to isolate issue",
            "Check system and library versions compatibility"
        ])

        return recommendations

    def _can_auto_fix(
        self,
        error_info: Dict[str, Any],
        category: ErrorCategory
    ) -> bool:
        """Determine if issue can be automatically fixed."""

        auto_fixable_issues = [
            "missing key",
            "expired certificate",
            "invalid nonce",
            "configuration parameter"
        ]

        error_message = error_info["error_message"].lower()
        return any(issue in error_message for issue in auto_fixable_issues)

    def _attempt_auto_fix(self, diagnosis: Dict[str, Any]) -> Dict[str, Any]:
        """Attempt to automatically fix the diagnosed issue."""

        fix_result = {
            "attempted": True,
            "successful": False,
            "actions_taken": [],
            "error": None
        }

        try:
            error_message = diagnosis["error_info"]["error_message"].lower()

            # Auto-fix missing keys
            if "key not found" in error_message:
                # Extract key name from error message
                # This is a simplified example
                key_name = "default_key"
                new_key = self.em.generate_key(
                    SymmetricAlgorithm.AES_256_GCM,
                    key_name
                )
                fix_result["actions_taken"].append(f"Generated new key: {key_name}")
                fix_result["successful"] = True

            # Auto-fix expired certificates
            elif "expired" in error_message and "certificate" in error_message:
                # This would renew certificates
                fix_result["actions_taken"].append("Certificate renewal initiated")
                fix_result["successful"] = True

        except Exception as e:
            fix_result["error"] = str(e)
            fix_result["successful"] = False

        return fix_result

    def _load_known_issues(self) -> Dict[str, Any]:
        """Load database of known issues and solutions."""
        # This would load from a knowledge base
        return {}

    def _validate_key_format(self, key_data: Any) -> bool:
        """Validate key data format."""
        # Basic validation - real implementation would be more comprehensive
        if isinstance(key_data, bytes):
            return len(key_data) >= 16  # Minimum key size
        return False

    def _generate_diagnosis_id(self) -> str:
        """Generate unique diagnosis identifier."""
        return f"diag_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{os.urandom(4).hex()}"

    def _log_diagnosis(self, diagnosis: Dict[str, Any]) -> None:
        """Log diagnosis for future reference."""
        self.diagnostic_log.append(diagnosis)

# Usage example
troubleshooter = EncryptionTroubleshooter(em)

# Example: Diagnose a decryption error
try:
    # This will fail
    result = em.decrypt_data(
        encrypted_data=b"invalid_data",
        password="wrong_password",
        algorithm=SymmetricAlgorithm.AES_256_GCM
    )
except Exception as e:
    # Diagnose the issue
    context = {
        "operation": "decrypt",
        "algorithm": "AES-256-GCM",
        "data_size": len(b"invalid_data"),
        "encrypted_data": b"invalid_data"
    }

    diagnosis = troubleshooter.diagnose_issue(
        error=e,
        operation_context=context,
        auto_fix=True
    )

    print(f"Error Category: {diagnosis['category']}")
    print(f"Severity: {diagnosis['severity']}")
    print(f"Auto-fix Available: {diagnosis['auto_fix_available']}")

    print("\nRecommendations:")
    for rec in diagnosis['recommendations']:
        print(f"- {rec}")

    if diagnosis.get('known_solutions'):
        print("\nKnown Solutions:")
        for solution in diagnosis['known_solutions']:
            print(f"Issue: {solution['issue']}")
            print(f"Solution: {solution['solution']}")

# Run system diagnostics
system_diag = troubleshooter.run_system_diagnostics()
print(f"\nSystem Status: {system_diag['encryption_manager_status']}")
print(f"Available Algorithms: {len(system_diag['algorithm_availability'])}")
```

---

## Next Steps

Continue your encryption mastery with:

- **[Chapter 8: Imports Manager](08.01%20Chapter%208%20-%20Imports%20Manager%20-%20Design%20-%20Overview.md)** - Module dependency management and secure importing
- **[Chapter 9: Pipeline Manager](09.01%20Chapter%209%20-%20Pipeline%20Manager%20-%20Design%20-%20Overview.md)** - Data processing pipelines with encryption
- **[Chapter 10: CLI Framework](10.01%20Chapter%2010%20-%20CLI%20Framework%20-%20Design%20-%20Overview.md)** - Command-line tools for encryption operations

**The Encryption Manager provides enterprise-grade security with developer-friendly APIs - master these patterns to protect your most sensitive data.** ðŸ”